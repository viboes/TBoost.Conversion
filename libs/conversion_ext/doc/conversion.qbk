[/
 / Copyright (c) 2009-2011 Vicente J. Botet Escriba
 /
 / Distributed under the Boost Software License, Version 1.0. (See accompanying
 / file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 /]

[article Toward Boost.Conversion
    [quickbook 1.5]
    [version 0.6.0]
    [authors [Botet Escriba, Vicente J.]]
    [copyright 2009-2011 Vicente J. Botet Escriba]
    [id boost.conversion]
    [/dirname conversion]
    [/purpose Conversion utilities]
    [license
        Distributed under the Boost Software License, Version 1.0.
        (See accompanying file LICENSE_1_0.txt or copy at
        [@http://www.boost.org/LICENSE_1_0.txt])
    ]
]

[def __convert_to__  `convert_to`]
[def __assign_to__  `assign_to`]

[import ../../../boost/conversion/boost/chrono_time_point_to_posix_time_ptime.hpp]
[import ../../../boost/conversion/std/pair.hpp]
[import ../../../boost/conversion/boost/optional.hpp]

[/
[section Preface]

[:[".]]
[:[*['-- ]]]

[endsect]
/]

[warning Conversion is not a part of the Boost libraries.]

[/========================]
[section Overview]
[/========================]

[/====================================]
[heading How to Use This Documentation]
[/====================================]

This documentation makes use of the following naming and formatting conventions.

* Code is in `fixed width font` and is syntax-highlighted.
* Replaceable text that you will need to supply is in [~italics].
* If a name refers to a free function, it is specified like this:
  `free_function()`; that is, it is in code font and its name is followed by `()`   to indicate that it is a free function.
* If a name refers to a class template, it is specified like this:   `class_template<>`; that is, it is in code font and its name is followed by `<>`   to indicate that it is a class template.
* If a name refers to a function-like macro, it is specified like this: `MACRO()`;
  that is, it is uppercase in code font and its name is followed by `()` to   indicate that it is a function-like macro. Object-like macros appear without the   trailing `()`.
* Names that refer to /concepts/ in the generic programming sense are   specified in CamelCase.

[note In addition, notes such as this one specify non-essential information that provides additional background or rationale.]

Finally, you can mentally add the following to any code fragments in this document:

    // Include all of the core Conversion files
    #include <boost/conversion.hpp>

    using namespace boost::conversion;

[section Motivation]

I've needed recently to convert from boost::chrono::time_point<Clock, Duration> to boost::posix_time::ptime and from  boost::chrono::duration<Rep, Period> to boost::posix_time::time_duration. This kind of conversions are needed quite often when you use code from two different libraries that have implemented the same concept using of course different representations and have hard coded the library interface to its own implementation. Well this is a normal situation we can't avoid. Life is life.

Quite often we need to convert unrelated types `Source` and `Target`. As these classes are unrelated, neither of them offers conversion operators to the other. Usually we get it by defining a specific function such as

    Target ConvertToTarget(Source& v);

In my case I started by defining

    template <typename Rep, typename Period>
    boost::posix_time::time_duration convert_to_posix_time_time_duration(
            const boost::chrono::duration<Rep, Period>& from);

    template <typename Clock, typename Duration>
    posix_time::ptime convert_to_posix_time_ptime(const chrono::time_point<Clock, Duration>& from);

Imagine now that you need to convert a `std::pair<Source, Source>` to a `std::pair<Target, Target>`. The standard defines conversions of pairs if the related types are C++ convertible:

    template <typename T1, typename T2>
    struct pair {
        ...
        template<class U, class V>
        //requires Constructible<T1, const U&> && Constructible<T2, const V&>
        std::pair(const pair<U, V>& p);

        template<class U , class V>
        //requires HasAssign<T1, const U&> && HasAssign<T2, const V&>
        std::pair& operator=(const std::pair<U , V>& p);
        ...
    };

As the types `Target` and `Source` are not C++ convertible other than using a specific function, we need to use a workaround.

Well we can again define a specific function

    std::pair<Target,Target> ConvertToPairOfTarget(std::pair<Source,Source>& v) {
        return std::make_pair(ConvertToTarget(v.fisrt), ConvertToTarget(v.second));
    }

While the `ConvertToTarget` could be specific, the `ConvertToPairOfTarget` should be generic

    template <typename Target1, typename Target2, typename Source1, typename Source2)
    std::pair<Target1,Target2> ConvertToPair(std::pair<Source1,Source2>& v);

In order to do that we need that the pair template parameters define a common function, let it call `convert_to`,

    template <typename Target, typename Source)
    Target convert_to(Source& v);

so `ConvertToPair` can be defined as

    template <typename Target1, typename Target2, typename Source1, typename Source2)
    std::pair<Target1,Target2> ConvertToPair(std::pair<Source1,Source2>& v) {
        return std::make_pair(convert_to<Target1>(v.fisrt), convert_to<Target2>(v.second));
    }

We need to specialize the `convert_to` function for the specific classes `Source` and `Target`. We can do it as follows

    Target  convert_to(Source& v) {return ConvertToTarget(v);}

Note that the preceding overloadings don't works, as C++ doesn't use the result type on overload resolution.

In my case I needed

    template <typename Rep, typename Period>
    boost::posix_time::time_duration convert_to(const boost::chrono::duration<Rep, Period>& from)
    {
            return convert_to_posix_time_time_duration(from);
    }

    template <typename Clock, typename Duration>
    boost::posix_time::ptime convert_to(const boost::chrono::time_point<Clock, Duration>& from)
    {
            return convert_to_posix_time_ptime(from);
    }

So now I can convert

    std::pair<chrono::time_point<Clock, Duration>, boost::chrono::duration<Rep, Period> >

to

    std::pair<boost::posix_time::ptime, boost::posix_time::time_duration>

using the `ConvertToPair` function.

What about converting `std::pair<Source,std::pair<Source,Source> >` to `std::pair<Target,std::pair<Target,Target> >`? The issue now is that `convert_to(std::make_pair<to, std::make_pair<to,to> >)` does not compiles because the conversion of `std::pair` is named `ConvertToPair`. So we need to specialize the function `convert_to` for pairs.


    template <typename T1, typename T2, typename S1, typename S2)
    static std::pair<T1,T2> convert_to(std::pair<Source1,Source2>& from) {
    {
        return std::pair<T1,T2>(convert_to<T1>(from.first), convert_to<T2>(from.second));
    }

There is still a last point. The preceding design works well with unrelated classes, but what about classes that already define some kind of conversion, using a constructor or a conversion operator. Do we need to make specialization for these conversion? The answer is no. We need just to define the default implementation of `convert_to` function to just return the explicit conversion.

    template < typename Target, typename Source>
    Target convert_to(const Source& from)
    {
        return Target(from);
    }

As noted above these overloadings don't work,and the library use a customization point that takes in account the result type.

What have we learned? Classes or algorithms relying on a conversion by copy-construction or by the conversion operator can be made more generic by relaying in a function that explicitly states this conversion. Thus, instead of requiring

    Target(from)

we could require

    convert_to<Target>(from)

The same can be applied to classes or algorithms relying on the assignment operator. So instead of requiring

    to = from

we could use

    assign_to(to, from);

The default implementation of __assign_to__ relies on the assignment operator

    template < typename Target, typename Source >
    To& assign_to(Target& to, const Source& from)
    {
        to = from;
        return to;
    }

For classes that are explicitly convertible and having a self assignment operator it is easy to make a specialization of __assign_to__ as follows.

    to = convert_to<Target>(from);

The rationale is that if there was not a copy constructor from a Source seems reasonable to think that there will not be an assignment operator. So in most of the cases, once we have specialized the convert_to function we recover a reasonable implementation for the __assign_to__ function.

When doing multiple assignments we use to do

    a = b = c;

With __assign_to__ we could do

    assign_to(a, assign_to(b, c));

and if we find this not really readable we can try with the make assigner to `mat' free function.

    mat(a) = mat(b) = c;

The behavior of `mat` recall the tie function of [*Boost.Tuple], but instead of allowing multiple assignations, allows a single `assign_to` call.

So one of the advantages of using this common functions is uniformity. The other is that now we are able to find all the explicit conversions to one type, as we can do with explicit casts.



[endsect]

[/==================]
[section Description]
[/==================]

[*Boost.Conversion] manages with generic extrinsic conversion between unrelated types.


[*Boost.Conversion] provides:

* a generic __convert_to__ function which can be customized by the user to make explicit conversion between unrelated types.
* a generic __assign_to__ function which can be customized by the user to make explicit assignments between unrelated types.
* a generic __try_convert_to__ function which can be customized by the user to make explicit optional conversion between unrelated types.
* a generic __try_assign_to__ function which can be customized by the user to make explicit optional assignments between unrelated types.
* a generic __convert_to_or_fallback__ function which can be customized by the user to make explicit conversion between unrelated types relying on a fallback when the conversion fails.

* a generic `mat` function returning a `assignable_to` wrapper which replace assignments by a calls to __assign_to__ 
* a generic `mcf` function returning a a `convertible_from` wrapper which replace the implicit conversion operators by a calls to __convert_to__.
* a `convertible_to` wrapper that acts as a implicit converter when passing parameters to a function.

[/* a generic `convert_to_via` function which convert a type `From` to another `To` using a temporary one `Via`.]
[/* a generic `pack` function used to pack Source and target constructor arguments.]

* conversion between `std::complex` of explicitly convertible types.
* conversion between `std::pair` of explicitly convertible types.
* conversion between `std::vector` of explicitly convertible types.
* conversion from/to `std::string` for types for which lexical cast works.

* conversion between `boost::array` of explicitly convertible types.
* conversion between `boost::chrono::time_point` and `boost::ptime`.
* conversion between `boost::chrono::duration` and `boost::time_duration`.
* conversion between `boost::numeric::interval` of explicitly convertible types.
* conversion between `boost::optional` of explicitly convertible types.
* conversion between `boost::rational` of explicitly convertible types.
* conversion between Boost.Fusion sequences (tuples) of explicitly convertible types.

[endsect]

[endsect]

[/==============================]
[section:users_guide Users' Guide]
[/==============================]

[/======================================]
[section:getting_started Getting Started]
[/======================================]

[/======================================]
[section:install Installing Conversion]
[/======================================]

[/=================================]
[heading Getting Boost.Conversion]
[/=================================]

You can get the last stable release of Boost.Conversion by downloading [^conversion.zip] from the
[@http://www.boostpro.com/vault/index.php?action=downloadfile&filename=conversion.zip&directory=Utilities& Boost Vault Utilities directory]

You can also access the latest (unstable?) state from the [@https://svn.boost.org/svn/boost/sandbox/conversion Boost Sandbox].

[/=================================]
[heading Building Boost.Conversion]
[/=================================]

There is no need to compile [*Boost.Conversion], since it's a header only library. Just include your Boost header directory in your compiler include path.

[/=========================]
[heading Requirements]
[/=========================]

The genric part of [*Boost.Conversion] depends only on Boost.Config. Of course it depends on the specific libraries when specific conversion are used.

[/========================]
[heading Exceptions safety]
[/========================]

All functions in the library are exception-neutral and provide strong guarantee of exception safety as long as the underlying parameters provide it.

[/====================]
[heading Thread safety]
[/====================]

All functions in the library are thread-unsafe except when noted explicitly.

[/=======================]
[heading Tested compilers]
[/=======================]

Currently, [*Boost.Conversion] has been tested in the following compilers/platforms:

Windows with

* MSVC 10.0

Cygwin 1.7 with

* GCC 4.3.4

MinGW with

* GCC 4.5.0
* GCC 4.5.0 -std=c++0x
* GCC 4.5.2
* GCC 4.5.2 -std=c++0x
* GCC 4.6.0
* GCC 4.6.0 -std=c++0x

Ubuntu 10.10

* GCC 4.4.5
* GCC 4.4.5 -std=c++0x
* GCC 4.5.1
* GCC 4.5.1 -std=c++0x
* clang 2.8

Darwin 10

* GCC 4.1.2
* clang 1.6
* clang 2.9
* clang 2.9 -std=c++0x


[note Please let us know how this works on other platforms/compilers.]

[note Please send any questions, comments and bug reports to boost <at> lists <dot> boost <dot> org.]

[endsect]
[/=============================]
[section Hello World! ]
[/=============================]


[endsect]

[endsect]

[section Tutorial]

[section Using generic conversions]

When you need to make a generic explicit conversion or assignation you need to include the file `boost/conversion/convert_to.hpp` or `boost/conversion/assign_to.hpp` and just use the boost conversion function.

    #include <boost/conversion/convert_to.hpp>
    using namespace boost::conversion;

    // ...

    int i = convert_to<int>(3.5);

[endsect]

[section Using specific conversions]

When you need to make a specific conversion you will need to include the specific conversion file. E.g.

    #include <boost/conversion/std/pair.hpp>

    std::pair<int,int> pint(0,1);
    std::pair<double,double> pdouble=boost::conversion::convert_to<std::pair<double,double> >(pint);

Do not forget to include this files when you use a generic class or algorithm using the generic __convert_to__ or __assign_to__, otherwise your program should not compile. E.g. if you want to convert a pair of `chrono::time_point<>` to a pair of `posix_time::ptime` do not forget to include in addition to the `boost/conversion/std/pair.hpp` the file `boost/conversion/boost/chrono_posix_time.hpp`

[endsect]

[section How to specialize the conversion functions?]

Boost.Conversion has a customization point for each on of the provided function. For example, to customize the converter_to function you should partially specialize the functor converter_cp.
 
  namespace  boost { 
    namespace conversion {
      template < typename Target, typename Source, typename Enable=void >
      struct convert_cp {
        Target operator()(const Source& val)
      };
    }
  }

A possible specialization for for pairs follows:

        template <typename Target1, typename Target2, typename Source1, typename Source2>
        struct convert_cp< std::pair<Target1,Target2>, std::pair<Source1,Source2> > 
        {
            std::pair<Target1,Target2> operator()(std::pair<Source1,Source2>& v) 
            {
                return std::pair<T1,T2>(convert_to<T1>(from.first), convert_to<T2>(from.second));
            }
        };

    }

The same applies to the generic __assign_to__ function.

    
[endsect]

[/
[section How to convert to types needing some constructors arguments?]

Sometimes we need the conversion construct the resulting type with some arguments. This could be the case for example of std::vector, for which we need to pass an allocator to the constructor. In order to maintain the same signature, the library provides a `pack` function that will wrap the Source and the Target constructor parameters in a single parameter. So the overloading must be done on the result of this `pack` function.

[endsect]
]

[endsect]

[section Examples]
[section chrono::time_point and posix_time::ptime]

[CHRONO_TIME_POINT_TO_POSIX_TIME_PTIME_HPP]

[endsect]
[section boost::optional]
[OPTIONAL_HPP]

[endsect]
[section std::pair]
[PAIR_HPP]
[endsect]
[endsect]

[section:ext_references External Resources]
[variablelist
[
    [[@http://www.boostpro.com/vault/index.php?action=downloadfile&filename=boost-string-convert.zip&directory=&
    [*Boost.Convert]]]
    [Vladimir Batov. Not yet reviewed]
]

[
    [[@http://www.boost.org/libs/conversion/lexical_cast.htm [*Boost.Conversion.LexicalCast]]]
    [general literal text conversions, such as an int represented as a string, or vice-versa from Kevlin Henney]
]

[
    [[@http://www.boost.org/libs/numeric/conversion [*Boost.NumericConversion]]]
    [Optimized Policy-based Numeric Conversions from Fernando Cacciola.]
]

[
    [[@http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2380.pdf [*N2380 - Explicit Conversion Operator Draft Working Paper (revision 2)]]]
    [Lois Goldthwaite, Michael Wong, Jens Mauer, Alisdair Meredith.]
]
[
    [[@http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2200.pdf [*N2200 - Operator Overloading]]]
    [Gary Powell, Doug Gregor, Jaakko Jarvi.]
]

[
    [[@http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1671.pdf [*N1671 - Overloading operator.() & operator.*()]]]
    [Gary Powell, Doug Gregor, Jaakko Jarvi.]
]

[
    [[@http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1676.htm [*N1676 - Non-member overloaded copy assignment operator]]]
    [Bronek Kozicki.]
]

[
    [[@http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1694.html [*N1694 - A Proposal to Extend the Function Call Operator]]]
    [Bronek Kozicki.]
]

]

[endsect]

[endsect]
[section Reference]

[xinclude core.xml]
[xinclude std.xml]
[xinclude boost.xml]

[endsect]


[/=================]
[section Appendices]
[/=================]

[section:history Appendix A: History]

[section [*Version 0.6.0, June 20, 2011] ]

This is a major evolution of the library.

[*New Features:]

* Added `try_convert_to`, `try_assign_to`, `convert_to_or_fallback` functions.
* Added converter factory `make_converter_to`.
* Added type traits `is_extrinsic_convertible` and `is_extrinsic_assignable`.
* Added `convertible_to`/`convertible_from` and `assignable_to` wrappers and the corresponding `mcf`, `mat` free functions.
* Added two levels of customization points `converter`/`converter_cp`, `assigner'/`assigner_cp', and so on.
* On compilers supporting it the interface is now concept-based, for specialization or overloading.

[*Deprecated Features:]

* The customization point using ADL has been disabled as it makes the library more complex.
* `pack` will be removed before review as is not well designed, and a tuple of references should works as well.
* `convert_to_via` will be removed before review as don't really useful.
* `mca` will be removed before review, the news `mcf` and `mat` should be used..

[endsect]

[section [*Version 0.5.1, Fefruary 20, 2011] ]

[*Bug]

* Fix bug on chain mca assignment.

[endsect]

[section [*Version 0.5.0, May 30, 2010] ]

[*New Features:]

* Added a pack function able to pack the Source and the Target constructor arguments in one parameter.
* Added conversion between std::vector of explicitly convertible types.
* Added is_convertible_to meta-function. Inherits: If an imaginary lvalue of type From is convertible to type To using convert_to then inherits from true_type, otherwise inherits from false_type.

    template <class From, class To>
    struct is_convertible : public true_type-or-false_type {};

* Added is_assignable_to meta-function.

[endsect]

[section [*Version 0.4.0, October 27, 2009] ]

['Applying the same technique that boost::swap applies making use of ADL]

[*New Features:]

A `Source` class is convertible to a `Target` class if:

* Either:  A function with the signature `convert_to<Target>(Source const&, boost::dummy::type_tag<To> const&)` is available via argument dependent lookup
* Or: A template specialization of `boost::conversion::convert_to<Target, Source>` exists for `Target` and `Source`
* Or: `Target` is copy constructible from `Source` (default implementation)

[endsect]

[section [*Version 0.3.0, October 22, 2009] ]

['Changing the order of `to` and `from` parameters on __assign_to__ function + Added `mca` function]

[*Incompatibility:]

* Changing the order of `to` and `from` parameters on __assign_to__.
* Now `boost/conversion/convert_to.hpp` and `boost/conversion/assign_to.hpp` files are separated.

[*New Features:]

* Added `<boost/conversion.hpp>` global file.
* Added `mca()` function.
* Added `convert_to_via` function.

[*Test:]

* Added test for the new features


[endsect]
[section [*Version 0.2.0, Mai 16, 2009] ]

['Adding array + fusion::tuples + Adaptation to Boost 1.39]

[*New Features:]

* conversion between `boost::array` of explicitly convertible types.
* conversion between Boost.Fusion sequences of explicitly convertible types.

[endsect]
[section [*Version 0.1.0, April 16, 2009] ]

['Announcement of Conversions]

[*Features:]

* a generic __convert_to__ function which can be specialized by the user to make explicit conversion between unrelated types.
* a generic __assign_to__ function which can be specialized by the user to make explicit assignation between unrelated types.
* conversion between C-arrays of explicitly convertible types.

* conversion between `std::complex` of explicitly convertible types.
* conversion between `std::pair` of explicitly convertible types.
* conversion between `std::string` and Streamable types.

* conversion between `boost::optional` of explicitly convertible types.
* conversion between `boost::rational` of explicitly convertible types.
* conversion between `boost::interval` of explicitly convertible types.

* conversion between `boost::chrono::time_point` and `boost::ptime`.
* conversion between `boost::chrono::duration` and `boost::time_duration`.

[endsect]
[endsect]

[section:rationale Appendix B: Rationale]

[/
[heading Trick to avoid recursion on the convert_to calls]

The implementation of this utility contains various workarounds:

* `conversion_impl` is put outside the boost::conversion namespace, to avoid infinite recursion (causing stack overflow) when converting objects of a primitive type.
* `conversion_impl` has a using-directive `using namespace boost::conversion_2;`, rather than a using-declaration, because some compilers (including MSVC 7.1, Borland 5.9.3, and Intel 8.1) don't do argument-dependent lookup when it has a using-declaration instead.
* `boost::conversion::convert_to` has an additional template argument, a tag, to avoid ambiguity between the `boost::conversion::convert_to`  and `boost::conversion_2::convert_to` and the when converting from objects of a Boost type that does not have its own `boost::conversion::convert_to` overload. This additional argument is a reference to a base tag class `dummy::base_tag<Target> const&` for the `boost::conversion::convert_to` and a reference derived tag class `dummy::type_tag<To> const&` for all others. 

    namespace dummy {
        template <typename T> struct base_tag {};
        template <typename T> struct type_tag : public base_tag<T> {};
    }
    
In this way 

    template <typename Target, typename Source>
    Target boost::conversion::convert_to(Source const& from, dummy::base_tag<Target> const& p=dummy::base_tag<Target>()) {

would be never chosen when called in this context

    using namespace boost::conversion_2;
    return convert_to(from, dummy::type_tag<Target>());

as the library defines

    namespace conversion_2 {
        template < typename To, typename From >
        To boost::conversion::convert_to(const From& val, dummy::type_tag<To> const&);
    }

[heading Trick to avoid the use of the tag on the user side]

The tag type is there to avoid infinite recursion, but it is quite cumbersome at the user side. 

    a = convert_to(b, dummy::type_tag<A>());
    
To avoid to pass it as parameter the tag parameter has a default value boost::dummy::base_tag<Target>(). 

    template <typename Target, typename Source>
    Target boost::conversion::convert_to(Source const& from, boost::dummy::base_tag<Target> const& p=boost::dummy::base_tag<Target>()) {

This default value needs however to give the Target template parameter

    a= convert_to<A>(b);
]

[heading Mathematical background]

Let be

    A a,a2;
    B b;
    C c;

* Reflexive: A is convertible to A if it is CopyConstructible or a specialization of convert_to is provided.

* Anti-Symetric : A convertible to B don't implies B convertible to A

* Loss of precision: Conversions can loss precision but not at infinitum

Two convertible types don't loss precision if

    b = convert_to<B>(a);
    a2 = convert_to<A>(b);
    assert(a==a2);

If they can loss precision they satisfy

    b = convert_to<B>(a)
    a2 = convert_to<A>(b)
    assert(a==a2 || ct(a2)==b

* Transitive: A convertible to B && B convertible to C implies A convertible to C

The implementation could use a intermediary B b to make the conversion or make the conversion directly.

    template <>
    convert_to<C,A>(const C& c) {
        return convert_to<A>(convert_to<B>(c));
    }

The library provides a convert_to_via function which helps to implement that.


[heading Ambiguity of multiple overloadings]

[warning Ambiguity of multiple overloadings]


[endsect]

[section:implementation Appendix C: Implementation Notes]


[heading Why `convert_to` between tuples is not implemented using `boost::fusion::transform`?]

`convert_to<T>` is a kind of transformation, so the natural implementation of `convert_to` for homogeneous containers could be to use the transform function.

This can not be applied to heterogeneous containers as tuples because the function change with the type.

[endsect]
[section:acknowledgements Appendix D: Acknowledgements]

Thanks to Vladimir Batov for proposing Boost.StringConversion which was the source of inspiration of this generic library. Boost.Conversion has inherited from some of the needs of  Boost.StringConversion.
Thanks to Edward Diener for showing me indirectly that multiple assignments should be taken in account.
Thanks to Jeffrey Lee Hellrung for showing me that Boost.Conversion should use also ADL as customization point, even if I have decided to disable it so simplify the library.
Thanks to Robert Stewart for suggesting the use of a functor as customization point and for all the constructive comments he made on the Boost ML.  
Thanks to Tomas Heller to showing me how to cut the dependency on Boost.Phoenix while introducing the overload of convert_to on Phoenix actors.

And last thanks to Gordon Woodhull for proposing himself as review manager of the library pushing me to make the library ready for review. 

[endsect]
[section  Appendix E: Tests]

[section Builtins]
[table
    [[Name]                             [kind]      [Description]                                   [Result] [Ticket]]
    [[convert_to_with_builtin_types]    [run]       [check `convert_to` works for builting types]     [Pass]   [#]]
    [[assign_to_with_builtin_types]     [run]       [check `assign_to` works for builtin types]      [Pass]   [#]]
    [[assign_to_transitive]             [run]       [Use of `assign_to` transitively]                 [Pass]   [#]]
    [[mca_assign_to_with_builtin_types] [run]       [check `mca` `works` for builtin types]      [Pass]   [#]]
    [[mca_assign_to_transitive]         [run]       [use of `mca` to multiple assignments]           [Pass]   [#]]
]
[endsect]


[section Intrinsic Conversions]
[table
    [[Name]                                         [kind]          [Description]                                           [Result] [Ticket]]
    [[convert_to_with_implicit_constructor]         [run]       [check `convert_to` works when there is an implicit constructor] [Pass]   [#]]
    [[convert_to_with_explicit_constructor]         [run]       [check `convert_to` works when there is an explicit constructor] [Pass]   [#]]
    [[convert_to_with_conversion_operator]          [run]       [check `assign_to` works when there is an conversion operator]  [Pass]   [#]]
    [[assign_to_with_assignment_operator]           [run]       [check `assign_to` works when there is an assignment operator] [Pass]   [#]]
    [[assign_to_with_assignment_operator_and_implicit_constructor]  [run]   [check `assign_to` works when there is an assignment operator and implicit constructor] [Pass]   [#]]
    [[assign_to_with_assignment_operator_and_conversion_operator]   [run]   [check `convert_to` works when there is an assignment operator and a conversion operator] [Pass]   [#]]
    [[mca_with_assignment_operator]           [run]       [check `mca` works when there is an assignment operator] [Pass]   [#]]
    [[mca_with_assignment_operator_and_implicit_constructor]  [run]   [check `mca` works when there is an assignment operator and implicit constructor] [Pass]   [#]]
    [[mca_with_assignment_operator_and_conversion_operator]   [run]   [check `mca` works when there is an assignment operator and a conversion operator] [Pass]   [#]]
]
[endsect]

[section Extrinsic Conversions]
[table
    [[Name]                 [kind]  [Description]                                           [Result] [Ticket]]
    [[explicit_convert_to]  [run]   [check `convert_to` works when `convert_to` is overloaded]  [Pass]   [#]]
    [[explicit_assign_to]   [run]   [check `assign_to` works when `assign_to` is overloaded]    [Pass]   [#]]
    [[explicit_mca]   [run]   [check `mca` works when `assign_to` is overloaded]    [Pass]   [#]]
]
[endsect]

[section Std]
[table
    [[Name]                     [kind]      [Description]                                                                   [Result] [Ticket]]
    [[convert_to_pair]          [run]       [check `convert_to` `std::pair` works when the parameters are convertible]               [Pass]   [#]]
    [[convert_to_complex]       [run]       [check `convert_to` `std::complex` works when the parameters are convertible]            [Pass]   [#]]
    [[convert_to_vector]       [run]       [check `convert_to` `std::vector` works when the parameters are convertible]            [Pass]   [#]]
    [[convert_to_string]        [run]       [check `convert_to` `std::string` works when the parameter defines the `operator<<`]       [Pass]   [#]]
    [[convert_from_string]      [run]       [check `convert_to` from `std::string` works when the parameter defines the `operator>>`]  [Pass]   [#]]
]
[endsect]

[section Boost]
[table
    [[Name]                     [kind]  [Description]                                                           [Result] [Ticket]]
    [[convert_to_rational]      [run]   [check `convert_to` `boost::rational` works when the parameters are convertible]   [Pass]   [#]]
    [[convert_to_interval]      [run]   [check `convert_to` `boost::interval` works when the parameters are convertible]   [Pass]   [#]]
    [[convert_to_optional]      [run]   [check `convert_to` `boost::optional` works when the parameters are convertible]   [Pass]   [#]]
    [[convert_to_time_point]    [run]   [check `convert_to` `boost::chrono::system_clock::time_point` from boost::posix_time::ptime works]                          [Pass]   [#]]
    [[convert_to_ptime]         [run]   [check `convert_to` `boost::posix_time::ptime` from boost::chrono::system_clock::time_point works]                          [Pass]   [#]]
    [[convert_to_duration]      [run]   [check `convert_to` `boost::chrono::duration` from `boost::posix_time::time_duration` works]                    [Pass]   [#]]
    [[convert_to_time_duration] [run]   [check `convert_to` `boost::posix_time::time_duration` from `boost::chrono::duration` works]                    [Pass]   [#]]
    [[convert_to_array]      [run]   [check `convert_to` `boost::array` works when the parameters are convertible]   [Pass]   [#]]
    [[convert_to_tuple]      [run]   [check `convert_to` `boost::tuple` works when the parameters are convertible]   [Pass]   [#]]
]
[endsect]

[endsect]
[section  Appendix F: Tickets]

[endsect]

[/=====================================]
[section:todo  Appendix F: Future plans]
[/=====================================]

[heading Tasks to do before review]


[heading For later releases]

* conversion between types for which lexical_cast works.
* conversion between types for which numeric_cast works.

[heading Make a proposal to the C++ standard]

C++1x has explicit conversion operators, but they must always be defined in the source class. The same applies to the assignment operator, it must be defined on the Target class.

It will be interesting to be able to add constructors and assignments operators to the class std::pair, so we can say that two pairs are convertible if the parameters are explicitly convertible using a convert_to function

    template<class U , class V>
    //requires HasConvertTo<T1, const U&> && HasConvertTo<T2, const V&>
    std::pair& operator=(const std::pair<U , V>& p) {
        return std::make_pair(convert_to<T1>(p.first), convert_to<T2>(p.second));
    }

But this is not possible. We can not add operations to a class.

Another possibility could be to make an evolution to the standard, so the convertible concept takes car of extrinsic conversions. We could be able to implicitly or explicitly add extrinsic conversion operators between unrelated types. Non-member assignment operators could also be specialized.

  template < typename To, typename From >
  operator To(const From& val);

  template < typename To, typename From >
  To& operator=(To& to, const From& from);

For example we could define the explicit conversion from as chrono::time_point<Clock, Duration> to posix_time::ptime follows

    template < class Clock, class Duration>
    explicit operator boost::posix_time::ptime(const boost::chrono::time_point<Clock, Duration>& from) {
        typedef boost::chrono::time_point<Clock, Duration> time_point_t;
        typedef boost::chrono::nanoseconds duration_t;
        typedef boost::duration_t::rep rep_t;
        rep_t d = boost::chrono::duration_cast<duration_t>(from.time_since_epoch()).count();
        rep_t sec = d/1000000000;
        rep_t nsec = d%1000000000;
        return  boost::posix_time::from_time_t(0)+
                boost::posix_time::seconds(static_cast<long>(sec))+
                boost::posix_time::nanoseconds(nsec);
    }

With this explicit conversion and the equivalent for duration, the actual definition of std::pair will allows to 

    std::pair<chrono::time_point<Clock, Duration>, boost::chrono::duration<Rep, Period> > tp_dur_pair;
    std::pair<boost::posix_time::ptime, boost::posix_time::time_duration> ppt;
    ppt = tp_dur_pair;


[endsect]
[endsect]


