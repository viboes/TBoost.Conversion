[/
 / Copyright (c) 2009-2011 Vicente J. Botet Escriba
 /
 / Distributed under the Boost Software License, Version 1.0. (See accompanying
 / file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 /]

[article Toward Boost.Conversion
    [quickbook 1.5]
    [version 0.6.0]
    [authors [Botet Escriba, Vicente J.]]
    [copyright 2009-2011 Vicente J. Botet Escriba]
    [id boost.conversion]
    [/dirname conversion]
    [/purpose Conversion utilities]
    [license
        Distributed under the Boost Software License, Version 1.0.
        (See accompanying file LICENSE_1_0.txt or copy at
        [@http://www.boost.org/LICENSE_1_0.txt])
    ]
]

[def __Boost_Conversion__  *Boost.Conversion*]

[def __explicit_convert_to  `explicit_convert_to`]
[def __implicit_convert_to  `implicit_convert_to`]
[def __convert_to  `convert_to`]
[def __convertible_to  `convertible_to`]
[def __implicitly  `implicitly`]
[def __convertible_from  `convertible_from`]
[def __implicit_converter_cp  `implicit_converter_cp`]
[def __explicit_converter_cp  `explicit_converter_cp`]

[def __try_convert_to  `try_convert_to`]
[def __convert_to_or_fallback  `convert_to_or_fallback`]
[def __assign_to  `assign_to`]
[def __assignable_to  `assignable_to`]
[def __lvalue  `lvalue`]
[def __assigner_cp  `assigner_cp`]
[def __try_assign_to  `try_assign_to`]

[def __is_extrinsically_convertible  `is_extrinsically_convertible`]
[def __is_extrinsically_explicit_convertible  `is_extrinsically_explicit_convertible`]


[import ../../../boost/conversion/boost/chrono_time_point_to_posix_time_ptime.hpp]
[import ../../../boost/conversion/std/pair.hpp]
[import ../../../boost/conversion/boost/optional.hpp]
[import ../example/even.cpp]
[import ../example/swap.cpp]
[import ../example/no_throw.cpp]
[import ../example/overload.cpp]
[import ../example/fallback.cpp]

[/
[section Preface]

[:[".]]
[:[*['-- ]]]

[endsect]
/]

[warning Conversion is not a part of the Boost libraries.]

[/========================]
[section Overview]
[/========================]

[/====================================]
[heading How to Use This Documentation]
[/====================================]

This documentation makes use of the following naming and formatting conventions.

* Code is in `fixed width font` and is syntax-highlighted.
* Replaceable text that you will need to supply is in [~italics].
* If a name refers to a free function, it is specified like this:
  `free_function()`; that is, it is in code font and its name is followed by `()`   to indicate that it is a free function.
* If a name refers to a class template, it is specified like this:   `class_template<>`; that is, it is in code font and its name is followed by `<>`   to indicate that it is a class template.
* If a name refers to a function-like macro, it is specified like this: `MACRO()`;
  that is, it is uppercase in code font and its name is followed by `()` to   indicate that it is a function-like macro. Object-like macros appear without the   trailing `()`.
* Names that refer to /concepts/ in the generic programming sense are   specified in CamelCase.

[note In addition, notes such as this one specify non-essential information that provides additional background or rationale.]

Finally, you can mentally add the following to any code fragments in this document:

    // Include all of the core Conversion files
    #include <boost/conversion.hpp>

    using namespace boost::conversion;

[/==================]
[section Scope]
[/==================]

[*Boost.Conversion] manages extrinsic conversion between unrelated types. These conversion can be seen as implicit or explicit conversions ([@http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2380.pdf [*N2380 - Explicit Conversion Operator Draft Working Paper (revision 2)]]).

The conversion operator can not be overloaded with a free-standing function on C++. In the past, there were request to be able to overload the `static_cast` operator [@http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2200.pdf [*N2200 - Operator Overloading]]. The author of this library thinks that the language would be more uniform if this extrinsic overload would be possible. The new extrinsic conversion operators could take the following form 

  operator Target(const Source& val);

  explicit operator Target(const Source& val);

The assignment operator could also be overloaded by a free function with some limitations as described in [@http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1676.htm [*N1676 - Non-member overloaded copy assignment operator]].

  Target& operator=(Target&, Source const&);

[*Boost.Conversion] provides a library-based solution for these missing language features, shows its own limitations and propose some library workarounds needed to take care of an equivalent behavior. 

Note that [*Boost.Conversion] is not particularly concerned with cases of: 

* type-to-type conversion via an input/output stream as Boost.LexicalCast does or 
* string-to-type or type-to-string as Vladimir Batov's Boost.Convert proposal or 
* string-to-type or type-to-string as Jeroen Habraken on going Boost.Coerce or 
* numeric conversion as Boost.Numeric can do.

When the users need to configure the conversion between specific value types they will need to use the specific interface these libraries provide.
 
[endsect]


[section Motivation]

When conversion is useful, but not provided by unrelated classes, the recommended approach is to use a named free function. One example of this could be a `date_to_week(date const&)` function. 

This approach works well when the source and destination are known at compile time, but when templates are involved, it becomes problematic. How can one write generic code for user-supplied classes when the source and destination types could be anything? Predicting the name becomes impossible, `operator T()` is the accepted way to express such an intent.

  T t = T(u);

Generic programming demands syntactic regularity. [*Boost.Conversion] propose an all-purpose templated conversion function:

    template< class Target, class Source > 
    Target explicit_convert_to( Source const & u );

[note __convert_to is a short hand for __explicit_convert_to.]

that can be used inside templates as follows:

  T t = explicit_convert_to<T>(u);

When the Source is explicitly convertible to the Target this function calls explicitly the conversion operator

    {
      return Target( u );
    }

This function would have to be specialized for each pair of types which do not themselves define an explicit conversion.
    
    week explicit_convert_to( date const & u ) { ... }

Unfortunately this doesn't works as overload resolution doesn't take care of template type parameters that can not be deduced from the function arguments. [*Boost.Conversion] provides a customization customization point that takes in account the `Source` and the `Target` types (see below).

To manage with extrinsically implicit conversion Boost.Conversion provides another all-purpose function template

    template< class Tatget, class Source > 
    Target implicit_convert_to( Source const & u );

This function alone can not manage with implicit conversion, as `implicit_convert_to` needs the target type to be stated explicitly. 

  f(implicit_convert_to<T>(u));

  
[*Boost.Conversion] provides an `implicitly` (make implicitly convertible from) function that creates a class providing implicit conversion operators for `Target` types for which the `Source` type is convertible using the `implicit_convert_to` function.  

  template < class Source >
  class convertible_from 
  { 
    Source data;
  public:
    convertible_from(Source source) : data(source) {}

    // enabled if class Source is extrinsically implicit convertible to Target  
    template < class Target > 
    operator Target() {
      return implicit_convert_to<Target>(*this);
    }
  };
  template < class Source >
  convertible_from<From> implicitly(Source source) 
  { 
    return convertible_from<Source>(source); 
  } 


Now the user can use the implicitly function to pass parameters that are extrinsically implicit convertibles without stating explicitly the type as follows
  
  T v;
  f(implicitly(v));


[/
I've needed recently to convert from `boost::chrono::time_point<Clock, Duration>` to `boost::posix_time::ptime` and from  `boost::chrono::duration<Rep, Period>` to `boost::posix_time::time_duration`. These kinds of conversions are needed quite often when you use code from two different libraries that have each implemented the same concept using a different representation, and hard-coded the library interface to its own implementation. Well, this is a normal situation we can't avoid. Life is life.

Quite often we need to convert unrelated types `Source` and `Target`. As these classes are unrelated, neither of them offers conversion operators to the other. Usually we get it by defining a specific function such as

    Target ConvertToTarget(Source& v);

In my case I started by defining

    template <typename Rep, typename Period>
    boost::posix_time::time_duration convert_to_posix_time_time_duration(
            const boost::chrono::duration<Rep, Period>& from);

    template <typename Clock, typename Duration>
    posix_time::ptime convert_to_posix_time_ptime(const chrono::time_point<Clock, Duration>& from);

Imagine now that you need to convert a `std::pair<Source, Source>` to a `std::pair<Target, Target>`. The standard defines conversion of two pairs types if the related types are C++ convertible:

    template <typename T1, typename T2>
    struct pair {
        ...
        template<class U, class V>
        //requires Constructible<T1, const U&> && Constructible<T2, const V&>
        std::pair(const pair<U, V>& p);

        template<class U , class V>
        //requires HasAssign<T1, const U&> && HasAssign<T2, const V&>
        std::pair& operator=(const std::pair<U , V>& p);
        ...
    };

As the types `Target` and `Source` are not C++ convertible other than using a specific function, we need to use a workaround.

We can again define a specific function

    std::pair<Target,Target> ConvertToPairOfTarget(std::pair<Source,Source>& v) {
        return std::make_pair(ConvertToTarget(v.fisrt), ConvertToTarget(v.second));
    }

While the `ConvertToTarget` could be specific, it seems clear to me that the `ConvertToPairOfTarget` should be generic

    template <typename Target1, typename Target2, typename Source1, typename Source2)
    std::pair<Target1,Target2> ConvertToPair(std::pair<Source1,Source2>& v);

In order to do that we need that the pair template parameters define a common function, let it call `convert_to`,

    template <typename Target, typename Source)
    Target convert_to(Source& v);

so `ConvertToPair` can be defined as

    template <typename Target1, typename Target2, typename Source1, typename Source2)
    std::pair<Target1,Target2> ConvertToPair(std::pair<Source1,Source2>& v) {
        return std::make_pair(convert_to<Target1>(v.fisrt), convert_to<Target2>(v.second));
    }

We need to specialize the `convert_to` function for the specific classes `Source` and `Target`. We can do it as follows

    Target  convert_to(Source& v) {return ConvertToTarget(v);}

Note that the preceding overloadings don't really work, as C++ doesn't use the result type on overload resolution. The library uses a customization point that takes into account the result type.

In my case I needed

    template <typename Rep, typename Period>
    boost::posix_time::time_duration convert_to(const boost::chrono::duration<Rep, Period>& from)
    {
            return convert_to_posix_time_time_duration(from);
    }

    template <typename Clock, typename Duration>
    boost::posix_time::ptime convert_to(const boost::chrono::time_point<Clock, Duration>& from)
    {
            return convert_to_posix_time_ptime(from);
    }

So now I can convert

    std::pair<chrono::time_point<Clock, Duration>, boost::chrono::duration<Rep, Period> >

to

    std::pair<boost::posix_time::ptime, boost::posix_time::time_duration>

using the `ConvertToPair` function.

What about converting `std::pair<Source,std::pair<Source,Source> >` to `std::pair<Target,std::pair<Target,Target> >`? The issue now is that `convert_to(std::make_pair<to, std::make_pair<to,to> >)` does not compile because the conversion of `std::pair` is named `ConvertToPair`. So we need to specialize the function `convert_to` for pairs.


    template <typename T1, typename T2, typename S1, typename S2)
    static std::pair<T1,T2> convert_to(std::pair<Source1,Source2>& from) {
    {
        return std::pair<T1,T2>(convert_to<T1>(from.first), convert_to<T2>(from.second));
    }

There is still a last point. The preceding design works well with unrelated classes, but what about classes that already define conversion via a constructor or a conversion operator - do we need to specialize these conversions? The answer is no. We need to define the default implementation of the `convert_to` function to just return the explicit conversion.

    template < typename Target, typename Source>
    Target convert_to(const Source& from)
    {
        return Target(from);
    }

As noted above these overloadings don't work, and the library uses a customization point that takes into account the result type.

What have we learned? Classes or algorithms relying on a conversion can be made more generic by relaying in a function that explicitly states this conversion. Thus, instead of requiring

    Target(from)

we could require

    convert_to<Target>(from)

The same can be applied to classes or algorithms relying on the assignment operator. So instead of requiring

    to = from

we could use

    assign_to(to, from);

The default implementation of __assign_to relies on the assignment operator

    template < typename Target, typename Source >
    To& assign_to(Target& to, const Source& from)
    {
        to = from;
        return to;
    }

For classes that are explicitly convertible and having a self assignment operator it is easy to make a specialization of __assign_to as follows.

    to = convert_to<Target>(from);

The rationale is that if there was not a copy constructor from a `Source` seems reasonable to think that there will not be an assignment operator. So in most cases, once we have specialized the __convert_to function we achieve a reasonable implementation for the __assign_to function.

When doing multiple assignments we commonly do

    a = b = c;

With __assign_to we could do

    assign_to(a, assign_to(b, c));

and if we find this less readable we can try with the "make assigner to `lvalue' free function.

    lvalue(a) = lvalue(b) = c;

The behavior of `lvalue` recalls the `tie` function of [*Boost.Tuple], but instead of invoking multiple assignments, it invokes a single `assign_to` call.

So one of the advantages of using this common functions is uniformity. The other is that now we are able to find all the explicit conversions to one type, as we can do with explicit casts.

The library takes in account some of the features suggested by the [*Boost.Convert] library and its review, such as no-throw conversions, conversions with fallback, ...

]
[endsect]


[/==================]
[section Description]
[/==================]


[*Boost.Conversion] provides:

* a generic __implicit_convert_to function which can be customized by the user to make implicit conversion between unrelated types.
* a generic __explicit_convert_to function which can be customized by the user to make explicit conversion between unrelated types.
* a generic __convert_to function which is equivalent __explicit_convert_to or that behaves as a functor factory if its argument is a fusion actor.
* a generic __assign_to function which can be customized by the user to make explicit assignments between unrelated types.
* a generic __try_convert_to function which can be customized by the user to make explicit optional conversion between unrelated types.
* a generic __try_assign_to function which can be customized by the user to make explicit optional assignments between unrelated types.
* a generic __convert_to_or_fallback function which can be customized by the user to make explicit conversion between unrelated types, relying on a fallback when the conversion fails.

* a generic __lvalue function returning a `assignable_to` wrapper which implements assignments by calls to __assign_to. 
* a generic __implicitly function returning a `convertible_from` wrapper which implements the implicit conversion operators by calls to __implicit_convert_to.
* a __convertible_to wrapper that acts as a implicit converter when passing parameters to a function.

[/* a generic `convert_to_via` function which convert a type `From` to another `To` using a temporary one `Via`.]
[/* a generic `pack` function used to pack Source and target constructor arguments.]

[/* conversion between `std::complex` of explicitly convertible types.]
* conversion between `std::pair` of explicitly convertible types.
* conversion between `std::vector` of explicitly convertible types.
* conversion from/to `std::string` for types for which lexical cast works.

* conversion between `boost::array` of explicitly convertible types.
* conversion between `boost::chrono::time_point` and `boost::ptime`.
* conversion between `boost::chrono::duration` and `boost::time_duration`.
* conversion between `boost::numeric::interval` of explicitly convertible types.
* conversion between `boost::optional` of explicitly convertible types.
* conversion between `boost::rational` of explicitly convertible types.
* conversion between Boost.Fusion sequences (tuples) of explicitly convertible types.

[endsect]

[section Caveats]

In order to provide the needed functionality, two type traits are mandatory: `is_constructible` and `is_assignable`. The library provides a first implementation of these type traits that works on compilers providing some specific features. The idea is that these type traits should be added to [*Boost.TypeTraits].

When the compiler doesn't provides with automatic ways to detect these traits, the library provides specializations for some std and boost types. If accepted the library will provide the specializations for all the standard types and optionally for all the Boost types.

Users working with compilers not supporting the definition of these traits, or users that need to make their code portable, will need to specialize these traits by hand.  

[endsect]

[endsect]

[/==============================]
[section:users_guide Users' Guide]
[/==============================]

[/======================================]
[section:getting_started Getting Started]
[/======================================]

[/======================================]
[section:install Installing Conversion]
[/======================================]

[/=================================]
[heading Getting Boost.Conversion]
[/=================================]

You can get the last stable release of Boost.Conversion by downloading [^conversion.zip] from the
[@http://www.boostpro.com/vault/index.php?action=downloadfile&filename=conversion.zip&directory=Utilities& Boost Vault Utilities directory]

You can also access the latest (unstable?) state from the [@https://svn.boost.org/svn/boost/sandbox/conversion Boost Sandbox].

[/=================================]
[heading Building Boost.Conversion]
[/=================================]

There is no need to compile [*Boost.Conversion], since it's a header only library. Just include your Boost header directory in your compiler include path.

[/=========================]
[heading Requirements]
[/=========================]

The generic part of [*Boost.Conversion] depends on *Boost.Config*, *Boost.TypeTraits*, *Boost.Optional* and *Boost.Fusion*. Of course it depends on the specific libraries when specific conversion are used from the directories `boost/conversion/boost`, in particular *Boost.Chrono* and *Boost.DateTime*, which need to link with.

The library works well only on compilers that are able to define the traits `is_constructible` and `is_assignable`, that is compilers supporting `decltype` and SFINAE for expressions. For the other compilers the library has much more limitations. 

[/========================]
[heading Exceptions safety]
[/========================]

All functions in the library are exception-neutral and provide strong guarantee of exception safety as long as the underlying parameters provide it.

[/====================]
[heading Thread safety]
[/====================]

All functions in the library are thread-unsafe except when noted explicitly.

[/=======================]
[heading Tested compilers]
[/=======================]

[*Boost.Conversion] is known to work on the following platforms/compilers (lack of some C++/C++0X language support disables some functionality). The needed C++/C++0X language support is:

* dectype or SFINAE on expressions,
* allow to define function template with default arguments,
*

At present the author is unable to define the type traits `is_constructible` and `is_assignable` if dectype and SFINAE on expressions is not available. 
On compilers that `is_constructible` and `is_assignable` can not be detected by the library, the user will need to specialize these traits explicitly. The library defines two macros `BOOST_CONVERSION_NO_IS_CONSTRUCTIBLE` and `BOOST_CONVERSION_NO_IS_ASSIGNABLE` allowing to make the specialization only when needed.

The `implicitly()` function and the `convertible_from` class are not provided on compilers on which `BOOST_NO_FUNCTION_TEMPLATE_DEFAULT_ARGS` is defined.

Currently, [*Boost.Conversion] has been tested in the following compilers/platforms using the trunk (Boost 1.47):

Windows with

* MSVC 10.0 (needs to specialize `is_constructible` and `is_assignable` can not be defined)

Cygwin 1.7 with

* GCC 4.3.4 (has some problems as `is_constructible` and `is_assignable` can not be defined)

MinGW with

* GCC 4.5.0
* GCC 4.5.0 -std=c++0x
* GCC 4.5.2
* GCC 4.5.2 -std=c++0x
* GCC 4.6.0
* GCC 4.6.0 -std=c++0x

[/
Ubuntu 10.10

* GCC 4.4.5
* GCC 4.4.5 -std=c++0x
* GCC 4.5.1
* GCC 4.5.1 -std=c++0x
* clang 2.8
]

Darwin 10

* GCC 4.1.2 (has some problems as `is_constructible` and `is_assignable` can not be defined)
* clang 1.6 (has some problems as `is_constructible` and `is_assignable` can not be defined)
* clang 2.9
* clang 2.9 -std=c++0x


[note Please let us know how this works on other platforms/compilers.]

[note Please send any questions, comments and bug reports to boost <at> lists <dot> boost <dot> org.]

[endsect]
[/=============================]
[section Hello World! ]
[/=============================]


[endsect]

[endsect]

[/====================================]
[section Tutorial]
[/====================================]

[section Using extrinsic conversions and assignments]
[/====================================]

When you need to make a extrinsic explicit conversion, simply include the file `boost/conversion/convert_to.hpp` and use the __convert_to function.

[EVEN_CPP]

The result of this program will evidently be

  2 is even.

['See the source file [@../../example/even.cpp example/even.cpp]]

The __convert_to function returns the explicit conversion to the target type.

  return Target(source);

When the extrinsic conversion must be stored in a variable you can use __assign_to instead. 
If the trait `is_assignable<Target,Source>` is a `true_type`, __assign_to(target,source) calls to the assignment operator, 

  target = source;

otherwise it does 

  target = convert_to<Target>(source);

when `Source` is extrinsically convertible to `Target`.

For example the user can implement a function that swaps two convertible types as follows:

[SWAP_CPP]

The result of this program will be

  i= 3
  x= 2.5
  i= 2
  x= 3

[note 
The name __convert_to could also be `convert` and __assign_to be `assign`, but I find the current names more coherent with the other names used by the library. If the Boost community agree on better names globally I will adopt them. 
]

['See the source file [@../../example/swap.cpp example/swap.cpp]]


[endsect]

[section Chaining assignments]
[/====================================]

When doing multiple assignments the user use to do

    a = b = c;

With __assign_to the users could do

    assign_to(a, assign_to(b, c));

and if they find this not really readable they can try with the [*m]ake [*a]ssigner [*t]o `lvalue' free function.

    lvalue(a) = lvalue(b) = c;

[note 
The name __lvalue comes from the fact that it builds a lvalue that is able to works with extrinsic conversions.
]

[endsect]

[section Using specific conversions]
[/====================================]

When you need to make a specific conversion you will need to include the specific conversion file. E.g.

    #include <boost/conversion/convert_to.hpp>
    #include <boost/conversion/std/pair.hpp>
    using namespace boost::conversion;

    std::pair<int,int> pint(0,1);
    std::pair<double,double> pdouble=convert_to<std::pair<double,double> >(pint);

Do not forget to include these files when you use a generic class or algorithm using the generic __convert_to or __assign_to, otherwise your program will not compile. E.g. if you want to convert a pair of `chrono::time_point<>` to a pair of `posix_time::ptime` do not forget to include both `boost/conversion/std/pair.hpp` and `boost/conversion/boost/chrono_posix_time.hpp`

[endsect]

[section Handling invalid conversions]
[/====================================]

The expected behavior of __convert_to is to throw an exception when the conversion is not possible. If an action must be taken on failure the user needs to use a try-catch

[NO_THROW_CPP_TRY_CATCH_WAY]

Sometimes the user could prefer no-throw behavior. The library provides a way to get this behavior with the __try_convert_to function, which returns an optional that is initialized only when the conversion succeeds. 

[NO_THROW_CPP_TRY_CONVERT_WAY]

which is equivalent to 

[NO_THROW_CPP_TRY_CONVERT_TO_OPT_WAY]

Last the user can get the same behavior using the __try_assign_to function, which returns if the assignment succeeded or not

[NO_THROW_CPP_TRY_ASSIGN_WAY]


['See the source file [@../../example/no_throw.cpp example/no_throw.cpp]]

[endsect]

[section Handling invalid conversions via a fallback]
[/====================================]

In some cases the conversion failure can be ignored and the result replaced with a fallback value. There are some ways to manage with that

[FALLBACK_CPP_TRY_ASSIGN_WAY]

Note the use __try_assign_to instead of __assign_to, as it avoids an exception if the conversion fails, as there is a fallback value already.

The library provides a specific function __convert_to_or_fallback that does that exactly

[FALLBACK_CPP_CONVERT_TO_OR_FALLBACK]

If the Fallback type is the same as the Target, the template parameter Target can be deduced and then omitted as in

[FALLBACK_CPP_CONVERT_TO_OR_FALLBACK_DEDUCED]

[note 
The name of this function could be also __convert_to as the library can overload it, but I find it more explicit this way. If the Boost community agree on a better name I will adopt it. 
]

['See the source file [@../../example/fallback.cpp example/fallback.cpp]]

[endsect]

[section Can extrinsic conversions be applied implicitly?]
[/====================================]

The advertised reader will be asking himself if the library provide implicit conversions as the language makes the difference between implicit and explicit conversions. The idea is to maintain the extrinsic functions semantics as close as possible to the semantics of intrinsic ones. Implicit conversion are applied whenever the compiler find that this implicit conversion makes the program well formed.

  void f(int);

  T v;
  f(v);

If there is an implicit conversion from `T` to `int`, the preceding program will be well formed.

With extrinsic conversions it is desirable to preserve as much as possible this behavior. The problem is that as extrinsic conversions are not in the language and the compiler could not find them automatically, so the user needs to call explicitly to the extrinsic conversion.

  void f(int);

  T v;
  f(implicit_convert_to<int>(v));

Imagine now that `f` is overloaded 

[OVERLOAD_CPP_FCTS]

and that the user has a function that should work when `T` is either implicitly convertible to int or std::string. 

[OVERLOAD_CPP_IMPL]

If `IntrCvtToInt` is convertible to `int` and `IntrCvtToString` is convertible to `std::string`, then the following program will be well formed.

[OVERLOAD_CPP_IMPL_INTRINSIC]

and will result in

  1 called
  2 called

But if T is *extrinsically* implicit convertible to `int` or `std::string` the user can not write a simple program that works as they doesn't know to which `Target` the type `T` must be converted to.

  T v;
  f(convert_to<???>(v));

So the following fails to compile if `ExtrCvtToInt` is extrinsically convertible to `int` and `ExtrCvtToString` is extrinsically convertible to `std::string`.

[OVERLOAD_CPP_IMPL_EXTRINSIC]

Why ADLIt would be great if the user could state explicitly that the parameter they are passing to `f` can be implicitly convertible to the `f` parameter type. The library provides a function __implicitly that makes a wrapper around a type that implicitly converts to any type that is extrinsically convertible from its argument.

[OVERLOAD_CPP_IMPLICITLY_LIKE]


So the following will be correct and call to the expected `f` overload.

[OVERLOAD_CPP_IMPLICITLY]

and prints

  1 called
  2 called
  1 called
  2 called

Note that extrinsically implicit convertible implies extrinsically explicit convertible but the opposite is not true. That means that if `ExtrExplicitCvtToInt` is extrinsically explicit convertible to `int`, the following program will be ill formed

[OVERLOAD_CPP_IMPLICITLY_EXPLICIT]

having as result, for example

  ../example/overload.cpp:102:18: error: no matching function for call to 'f'
      std::cout << f(implicitly(v)) << " called" << std::endl;
                 ^
  ../example/overload.cpp:134:34: note: in instantiation of member function 'ImplicitTest<ExtrExplicitCvtToInt>::whichOverload' requested here
    ImplicitTest<ExtrExplicitCvtToInt>::whichOverload();
                                 ^
  ../example/overload.cpp:21:5: note: candidate function not viable: no known conversion from 'convertible_from<ExtrExplicitCvtToInt>' to 'int' for 1st argument
  int f(int) { return 1; }

['See the source file [@../../example/overload.cpp example/overload.cpp]]


[endsect]

[section How to write a function that accepts a parameter that is extrinsically convertible to a given type?]
[/====================================]

The use of the helper function __implicitly is a little bit intrusive in some cases. It would be great if the users could define a function accepting a type that is extrinsically convertible, so the they will not be forced to use it. There are two alternatives:

* overload the function using SFINAE
* change the function prototype

If the user had already the function

  void f(int);

She can add an overload that will make explicitly the conversion as follows

  template <typename T>
  typename enable_if<is_extrinsically_convertible<int>,void >::type 
  f(T v) { return convert_to<int>(v); }

This template overload will be taken for overload resolution only if `T` is not `int` (as non template functions are preferred to template ones) and `T` is extrinsically convertible to `int`. `is_extrinsically_convertible` is a trait added by the library that contains a nested value field that is true or false depending on whether the `Source` type is extrinsically implicit convertible to `Target`.

An alternative could be to define the function `f` from the beginning stating explicitly that his parameter one that is extrinsically convertible to `int`.

  void f(convertible_to<int> v);

The `convertible_to<T>` class is a `T` wrapper that is implicitly constructible from any type extrinsically constructible `T`. `convertible_to<T>` is implicitly convertible to `T`. For example, if `T` is extrinsically convertible to `int`, the following program will be well formed

  void f(convertible_to<int> v) 
  {
    std::cout << std::hex << v << std::endl;
  }

  int main()
  {
    T v;
    f(v)
  }

Unfortunately, `convertible_to<T>` is not a smart reference to `T`, so any access to its underlying type must be done using an explicit call to the `get` function.

  void f(convertible_to<std::string> v) 
  {
    std::cout << v.get().c_str() << std::endl;
  }

[note 
While this alternative doesn't seems completely necessary, I wanted to add them to the library for the review discussion. It could be removed from without any problems.
]
 
[endsect]

[section Functors]

The library provide a specific Phoenix functor factory having as result a functor that will call to the __convert_to function lazily.

  #include <boost/conversion/fp/convert_to.hpp>
  #include <boost/array.hpp>
  #include <vector>

  std::vector<int>            integers;
  boost::array<char const*, 5> strings = {{ "15", "16", "17", "18"}};

  // With fallback value provided. No throwing.
  std::transform(
      strings.begin(),
      strings.end(),
      std::back_inserter(integers),
      convert_to<int>(_1)
  );

  BOOST_ASSERT(integers[0] == 15);
  BOOST_ASSERT(integers[1] == 16);
  BOOST_ASSERT(integers[2] == 17);
  BOOST_ASSERT(integers[3] == 18);

[endsect]

[section Usage of __implicit_convert_to, __explicit_convert_to or __assign_to]

The users should use __assign_to whenever they had used operator=(), that is, when there is already a target variable.

The users should use the conversion forms __implicit_convert_to, __explicit_convert_to  whenever they had used the conversion operator Target(), either implicit or explicitly.  


[endsect]

[section How to specialize extrinsic conversions?]
[/====================================]

__Boost_Conversion__ has two customization point for each one of the provided functions:

* specializing the associated customization functor
* overloading a variant of the function to customize

For example, to customize the __implicit_convert_to function you could partially specialize the functor __implicit_converter_cp.
 
  namespace  boost { 
    namespace conversion {
      template < typename Target, typename Source, typename Enable=void >
      struct implicit_converter_cp : true_type {
        Target operator()(const Source& val)
      };
    }
  }

A possible specialization for `std::pair` follows:

        template <typename Target1, typename Target2, typename Source1, typename Source2>
        struct implicit_convert_cp< std::pair<Target1,Target2>, std::pair<Source1,Source2> 
          , typename enable_if_c<
                is_extrinsically_convertible<Source1, Target1>::value
            && is_extrinsically_convertible<Source2, Target2>::value
          >::type
        > : true_type
        {
            std::pair<Target1,Target2> operator()(std::pair<Source1,Source2>& v) 
            {
                return std::pair<T1,T2>(implicit_convert_to<T1>(from.first), implicit_convert_to<T2>(from.second));
            }
        };


Note that the __implicit_converter_cp specialization inherits from `boost::true_type`. This is needed as used by the __is_extrinsically_convertible type trait.

Note also the use of the `Enable` parameter to constraint the specialization to the enable types using the `enable_if` family functions.

An alternative customization point is to overload a variant of the conversion to specialize that adds a dummy parameter that can covey the return type when needed.

For example the __explicit_convert_to function can be specialized by overloading the function

    template <typename Target, typename Source>
    Target explicit_convert_to(Source const& from, dummy::type_tag<Target> const&);

This is particular useful when we want explicit conversion on compilers that don't support explicit conversion operators. For example the Boost.Opaque library define a mixing to add explicit conversion to a specific type as follows:

    template <typename T>
    struct using_explicit_conversion_to {
        template <typename Final, typename Base>
        struct type: Base {
    #     if ! defined BOOST_NO_EXPLICIT_CONVERSION_OPERATORS
            explicit operator T() const
            {
              return T(Final::underlying(this));
            }
    #     endif
            friend T explicit_convert_to(Final const& rhs,
                boost::conversion::dummy::type_tag<T> const&)
            {
              return T(Final::underlying(rhs));
            }
        };
    };

While the `explicit operator T() const;` can be defined only on compilers supporting explicit conversion operators, the `explicit_convert_to` variant can be overloaded on most of the compilers, providing a portable solution.
    
[endsect]

[section What to do when the compiler doesn't supports the definition of the needed type traits?]

When the compiler doesn't supports the definition of some of the type traits, the library doesn't work as the user could expect. For each trait the library provides a macro that states if the library can define correctly the type trait. For example, BOOST_CONVERSION_NO_IS_ASSIGNABLE. In this case the user needs to specialize the type trait explicitly as follows:

  #if defined BOOST_CONVERSION_NO_IS_ASSIGNABLE
  namespace boost
  {
    template <> struct is_assignable< X&, X const& >  : true_type {};
  }
  #endif 

[endsect]



[/
[section How to convert to types needing some constructors arguments?]

Sometimes the user needs the conversion construct the resulting type with some arguments. This could be the case for example of std::vector, for which the user could want to pass an allocator to the constructor. In order to maintain the same signature, the library provides a `pack` function that will wrap the Source and the Target constructor parameters in a single parameter. So the overloading must be done on the result of this `pack` function.

[endsect]
]

[endsect]

[section Examples]
[/
[section chrono::time_point and posix_time::ptime]

[CHRONO_TIME_POINT_TO_POSIX_TIME_PTIME_HPP]

[endsect]
[section boost::optional]
[OPTIONAL_HPP]

[endsect]
[section std::pair]
[PAIR_HPP]
[endsect]

]
[endsect]

[section:ext_references External Resources]
[variablelist
[
    [[@http://www.boostpro.com/vault/index.php?action=downloadfile&filename=boost-string-convert.zip&directory=&
    [*Boost.Convert]]]
    [Vladimir Batov. Not yet reviewed]
]

[
    [[@http://www.boost.org/libs/conversion/lexical_cast.htm [*Boost.Conversion.LexicalCast]]]
    [general literal text conversions, such as an int represented as a string, or vice-versa from Kevlin Henney]
]

[
    [[@http://www.boost.org/libs/numeric/conversion [*Boost.NumericConversion]]]
    [Optimized Policy-based Numeric Conversions from Fernando Cacciola.]
]

[
    [[@http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2380.pdf [*N2380 - Explicit Conversion Operator Draft Working Paper (revision 2)]]]
    [Lois Goldthwaite, Michael Wong, Jens Mauer, Alisdair Meredith.]
]
[
    [[@http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2200.pdf [*N2200 - Operator Overloading]]]
    [Gary Powell, Doug Gregor, Jaakko Jarvi.]
]

[
    [[@http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1671.pdf [*N1671 - Overloading operator.() & operator.*()]]]
    [Gary Powell, Doug Gregor, Jaakko Jarvi.]
]

[
    [[@http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1676.htm [*N1676 - Non-member overloaded copy assignment operator]]]
    [Bronek Kozicki.]
]

[
    [[@http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1694.html [*N1694 - A Proposal to Extend the Function Call Operator]]]
    [Bronek Kozicki.]
]

[
    [[@http://www.open-std.org/jtc1/sc22/wg21/prot/14882fdis/n3291.pdf [*N3291 - Working Draft, Standard for Programming Language C++]]]
    []
]

[
    [[@http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3047.html [*N3047 - Fixing is_constructible and is_explicitly_convertible]]]
    [Daniel Krugler]
]

   

]

[endsect]

[endsect]
[section Reference]

This reference consists of several sections:

* Type Traits Extensions defines some standard type traits that are missing to [*Boost.TypeTraits]. 

[note

The intent is to move this section to the to the [*Boost.TypeTraits] library.
See  [@http://www.open-std.org/jtc1/sc22/wg21/prot/14882fdis/n3291.pdf [*N3291 - Working Draft, Standard for Programming Language C++]] 20.9.4.3	Type properties.

]


* Core: Contains the core features of the library
* C++ Standard classes specializations: Contains specializations for some of the C++ standard types. Files in this section are not included by the  <boost/conversion.hpp> file and must be included explicitly when needed.
* Boost classes specializations: Contains specializations for some of the C++ standard types. Files in this section are not included by the  <boost/conversion.hpp> file and must be included explicitly when needed.




[section Type Traits Extensions]

[xinclude std_type_traits.xml]
[xinclude std_type_traits_std.xml]
[xinclude std_type_traits_boost.xml]
[endsect]
[xinclude core.xml]
[xinclude std.xml]
[xinclude boost.xml]

[endsect]


[/=================]
[section Appendices]
[/=================]

[section:history Appendix: History]

[section [*Version 0.6.0, July 16, 2011] ]

This is a major evolution of the library.

[*New Features:]

* Added `try_convert_to`, `try_assign_to`, `convert_to_or_fallback` functions.
* Added converter factory `make_converter_to`.
* Added type traits `is_extrinsically_convertible` and `is_extrinsically_assignable`.
* Added `convertible_to`, `convertible_from` and `assignable_to` wrappers and the corresponding `implicitly` and `lvalue` free functions.
* Added two levels of customization points `converter`/`converter_cp`, `assigner'/`assigner_cp`, and so on to simplify the customizations for the users.
* On compilers supporting it the interface is now concept-based, for specialization or overloading.
* Added type traits that have a better place in Boost.TypeTraits:

  * `is_assignable`, 
  * `is_copy_assignable`, 
  * `is_move_assignable`, 
  * `is_constructible`, 
  * `is_default_constructible`, 
  * `is_copy_constructible`, 
  * `is_move_constructible`, 
  * `is_explictly_convertible`.


[*Deprecated Features:]

* The customization point using ADL has been disabled as it makes the library more complex.
* `pack` will be removed before review as is not well designed, and a tuple of references should works as well.
* `convert_to_via` will be removed before review as don't really useful.
* `mca` will be removed before review, the news `implicitly` and `lvalue` should be used..

[endsect]

[section [*Version 0.5.1, Fefruary 20, 2011] ]

[*Bug]

* Fix bug on chain mca assignment.

[endsect]

[section [*Version 0.5.0, May 30, 2010] ]

[*New Features:]

* Added a `pack` function able to pack the `Source` and the `Target` constructor arguments in one parameter.
* Added conversion between `std::vector` of explicitly convertible types.
* Added `is_convertible_to` meta-function. Inherits: If an imaginary lvalue of type `From` is convertible to type `To` using `convert_to` then inherits from `true_type`, otherwise inherits from `false_type`.

    template <class From, class To>
    struct is_convertible : public true_type-or-false_type {};

* Added `is_assignable_to` meta-function.

[endsect]

[section [*Version 0.4.0, October 27, 2009] ]

['Applying the same technique that `boost::swap` applies making use of ADL]

[*New Features:]

A `Source` class is convertible to a `Target` class if:

* Either:  A function with the signature `convert_to<Target>(Source const&, boost::dummy::type_tag<To> const&)` is available via argument dependent lookup
* Or: A template specialization of `boost::conversion::convert_to<Target, Source>` exists for `Target` and `Source`
* Or: `Target` is copy constructible from `Source` (default implementation)

[endsect]

[section [*Version 0.3.0, October 22, 2009] ]

['Changing the order of `to` and `from` parameters on __assign_to function + Added `mca` function]

[*Incompatibility:]

* Changing the order of `to` and `from` parameters on __assign_to.
* Now `boost/conversion/convert_to.hpp` and `boost/conversion/assign_to.hpp` files are separated.

[*New Features:]

* Added `<boost/conversion.hpp>` global file.
* Added `mca()` function.
* Added `convert_to_via` function.

[*Test:]

* Added test for the new features


[endsect]
[section [*Version 0.2.0, Mai 16, 2009] ]

['Adding array + fusion::tuples + Adaptation to Boost 1.39]

[*New Features:]

* conversion between `boost::array` of explicitly convertible types.
* conversion between Boost.Fusion sequences of explicitly convertible types.

[endsect]
[section [*Version 0.1.0, April 16, 2009] ]

['Announcement of Conversions]

[*Features:]

* a generic __convert_to function which can be specialized by the user to make explicit conversion between unrelated types.
* a generic __assign_to function which can be specialized by the user to make explicit assignment between unrelated types.
* conversion between C-arrays of explicitly convertible types.

* conversion between `std::complex` of explicitly convertible types.
* conversion between `std::pair` of explicitly convertible types.
* conversion between `std::string` and Streamable types.

* conversion between `boost::optional` of explicitly convertible types.
* conversion between `boost::rational` of explicitly convertible types.
* conversion between `boost::interval` of explicitly convertible types.

* conversion between `boost::chrono::time_point` and `boost::ptime`.
* conversion between `boost::chrono::duration` and `boost::time_duration`.

[endsect]
[endsect]


[section:rationale Appendix: Design Rationale]

[heading Why overloading the conversion functions doesn't works?]


For example, the prototype of __implicit_convert_to is

    template <typename Target, typename Source>
    Target
    implicit_convert_to(Source const& from);

The users could overload this function with a specific source type, as it appears as a parameter of the function, but they can not overload on the source and the target types.

To overcome this limitation the library could opt for two alternatives:

* Add a dummy parameter that can covey the Target type.
* Implements the conversion function forwarding the call to a specific converter functor.


Adding a dummy parameter could look something like


    template <typename Target, typename Source>
    Target implicit_convert_to(Source const& from, dummy::type_tag<Target> const&);

Callers of this function need to pass the additional parameter as for example

    MyTarget t = implicit_convert_to(from, dummy::type_tag<MyTarget>()); 
    
User specializations consists just in overloading this function.

    MyTarget implicit_convert_to(MySource const& from, dummy<MyTarget> const&);
    

The advantages are

* the call doesn't needs to be qualified by the boost::conversion namespace and ADL will choose the correct overload.

The drawbacks are 

* the unreadable syntax,
* the possible default implementation provided by the library would not be accessible as far as the user doesn't includes the boost::conversion namespace.
* we can not add new functions on the std namespace, so we can not overload the behavior for standard classes,
so a different technique is needed.


Implementing the conversion function by forwarding the call to a specific converter functor as follows

    template <typename Target, typename Source>
    Target
    implicit_convert_to(Source const& from)
    {
      return implicit_converter<Target,Source>()(from);
    }

User specializations consists just in specializing the functor implicit_converter.

  namespace boost { 
    namespace conversion {
      struct implicit_converter<MyTarget, MySource> {
        MyTarget operator()(MySource const& from) 
        {
          // return the specific conversion;
        }
      };
    } 
  }

The advantages are

* the technique can be applied to types on the standard namespace
* the library can call to the customization point after providing a default implementation.

The drawbacks are 

* The users need to qualify with boost::conversion every call to implicit_converter or introduce the namespace boost::conversion via the using statement.


The library provides a mixture of the preceding alternatives:

* defines a boost::conversion::convert_to function
* that relies on an internal function which introduces an internal namespace on which the default implementation is found by ADL if no best choice is found.
* this default implementation forwards the call to the customization functor
* which can be partially specialized by the user. 
  

The library implements the conversion function forwarding the call to a specific converter functor as follows

    template <typename Target, typename Source>
    Target
    implicit_convert_to(Source const& from)
    {
      return implicit_converter<Target,Source>()(from);
    }


The converter functor must define the operator() as follows:

    template < typename Target, typename Source, class Enable = void >
    struct implicit_converter
    {
      Target operator()(typename add_reference<const Source>::type val)
      {
        ...
      }
    };

The library provides a specialization of this class for classes Target and Source satisfying Convertible<Source,Target> as follows:

    
    template < typename Target, typename Source >
    struct implicit_converter<Target, Source
        , typename enable_if_c< is_convertible<Source,Target>::value >::type
    > : true_type
    {
      Target operator()(typename add_reference<const Source>::type val)
      {
        return val;
      }
    };


In the same way the library provides a specialization of this class, the users can specialize this converter functor as the class has the source and the target types as parameters.

One of the problems using SFINAE, is that all the conditions must be complementary. So the user needs to know what are the other conditions and ensure that there is no ambiguity.

    template <  >
    struct implicit_converter<MyTarget, MySource
        , typename enable_if_c< ! is_convertible<MySource,MyTarget>::value >::type
    > : true_type
    {
      MyTarget operator()(typename add_reference<const MySource>::type val)
      {
        // return a specific conversion ;
      }
    };

[heading Why the library provides two-level customization point for conversion functions?]

While the preceding technique allows the users to override the default specialization, it is quite dependent on the conditions the library makes a specialization. While the condition for the implicit_converter is simple, other functions can have a much more complex condition for which the library makes a specialization.


To make easier the work of the users the library defines a catch all definition that delegates to a second functor.

    template < typename Target, typename Source, class Enable = void >
    struct implicit_converter_cp : false_type {};
    
    template < typename Target, typename Source, class Enable = void >
    struct implicit_converter : implicit_converter_cp<Target,Source,Enable> {};

Now the users can friendly specialize implicit_converter_cp as the library doesn't provides any specialization of this class by default.

[/
[heading Why the library provides two-level customization point for assignment function?]

The overloading problem found on the conversion functions doesn't appears for the assignment function, as the function parameters determine the source and the target types. 

    template <typename Target, typename Source>
    Target& assign_to(Target& to, const Source& from);

]



[/
[heading Trick to avoid recursion on the convert_to calls]

The implementation of this utility contains various workarounds:

* `conversion_impl` is put outside the boost::conversion namespace, to avoid infinite recursion (causing stack overflow) when converting objects of a primitive type.
* `conversion_impl` has a using-directive `using namespace boost::conversion_2;`, rather than a using-declaration, because some compilers (including MSVC 7.1, Borland 5.9.3, and Intel 8.1) don't do argument-dependent lookup when it has a using-declaration instead.
* `boost::conversion::convert_to` has an additional template argument, a tag, to avoid ambiguity between the `boost::conversion::convert_to`  and `boost::conversion_2::convert_to` and the when converting from objects of a Boost type that does not have its own `boost::conversion::convert_to` overload. This additional argument is a reference to a base tag class `dummy::base_tag<Target> const&` for the `boost::conversion::convert_to` and a reference derived tag class `dummy::type_tag<To> const&` for all others. 

    namespace dummy {
        template <typename T> struct base_tag {};
        template <typename T> struct type_tag : public base_tag<T> {};
    }
    
In this way 

    template <typename Target, typename Source>
    Target boost::conversion::convert_to(Source const& from, dummy::base_tag<Target> const& p=dummy::base_tag<Target>()) {

would be never chosen when called in this context

    using namespace boost::conversion_2;
    return convert_to(from, dummy::type_tag<Target>());

as the library defines

    namespace conversion_2 {
        template < typename To, typename From >
        To boost::conversion::convert_to(const From& val, dummy::type_tag<To> const&);
    }

[heading Trick to avoid the use of the tag on the user side]

The tag type is there to avoid infinite recursion, but it is quite cumbersome at the user side. 

    a = convert_to(b, dummy::type_tag<A>());
    
To avoid to pass it as parameter the tag parameter has a default value boost::dummy::base_tag<Target>(). 

    template <typename Target, typename Source>
    Target boost::conversion::convert_to(Source const& from, boost::dummy::base_tag<Target> const& p=boost::dummy::base_tag<Target>()) {

This default value needs however to give the Target template parameter

    a= convert_to<A>(b);


[heading Loss of precision]

Let be

    A a,a2;
    B b;
    C c;

Conversions can loss precision but not at infinitum

Two convertible types don't loss precision if

    b = convert_to<B>(a);
    a2 = convert_to<A>(b);
    assert(a==a2);

If they can loss precision they satisfy

    b = convert_to<B>(a)
    a2 = convert_to<A>(b)
    assert(a==a2 || ct(a2)==b



[heading Ambiguity of multiple overloadings]

[warning Ambiguity of multiple overloadings]
]

[endsect]

[section:implementation Appendix: Implementation Notes]

[heading Why `implicit_converter_cp< std::vector<T1,A1>, std::vector<T2,A2> >` can not relay on `assign_to< std::vector<T1,A1>, std::vector<T2,A2> >`?]



[heading Why `convert_to` between tuples is not implemented using `boost::fusion::transform`?]

`convert_to<T>` is a kind of transformation, so the natural implementation of `convert_to` for homogeneous containers could be to use the transform function.

This can not be applied to heterogeneous containers as tuples because the function change with the type.

[endsect]
[section:acknowledgements Appendix: Acknowledgements]

Thanks to Vladimir Batov for proposing Boost.StringConversion. The discussions on the Boost ML of his library were the source of inspiration of this generic library. Boost.Conversion has inherited from some of the needs of  Boost.StringConversion.
Thanks to Edward Diener for showing me indirectly that multiple assignments should be taken in account.
Thanks to Jeffrey Lee Hellrung for showing me that Boost.Conversion should use also ADL as customization point, even if I have decided to disable it so simplify the library.
Thanks to Robert Stewart for suggesting the use of a functor as customization point and for all the constructive comments he made on the Boost ML.  
Thanks to Tomas Heller to showing me how to cut the dependency on Boost.Phoenix while introducing the overload of convert_to on Phoenix actors.

And last thanks to Gordon Woodhull for proposing himself as review manager of the library. 

[endsect]
[/
[section  Appendix E: Tests]

[section Builtins]
[table
    [[Name]                             [kind]      [Description]                                   [Result] [Ticket]]
    [[convert_to_with_builtin_types]    [run]       [check `convert_to` works for builting types]     [Pass]   [#]]
    [[assign_to_with_builtin_types]     [run]       [check `assign_to` works for builtin types]      [Pass]   [#]]
    [[assign_to_transitive]             [run]       [Use of `assign_to` transitively]                 [Pass]   [#]]
    [[lvalue_assign_to_with_builtin_types] [run]       [check `mca` `works` for builtin types]      [Pass]   [#]]
    [[lvalue_assign_to_transitive]         [run]       [use of `mca` to multiple assignments]           [Pass]   [#]]
]
[endsect]


[section Intrinsic Conversions]
[table
    [[Name]                                         [kind]          [Description]                                           [Result] [Ticket]]
    [[convert_to_with_implicit_constructor]         [run]       [check `convert_to` works when there is an implicit constructor] [Pass]   [#]]
    [[convert_to_with_explicit_constructor]         [run]       [check `convert_to` works when there is an explicit constructor] [Pass]   [#]]
    [[convert_to_with_conversion_operator]          [run]       [check `assign_to` works when there is an conversion operator]  [Pass]   [#]]
    [[assign_to_with_assignment_operator]           [run]       [check `assign_to` works when there is an assignment operator] [Pass]   [#]]
    [[assign_to_with_assignment_operator_and_implicit_constructor]  [run]   [check `assign_to` works when there is an assignment operator and implicit constructor] [Pass]   [#]]
    [[assign_to_with_assignment_operator_and_conversion_operator]   [run]   [check `convert_to` works when there is an assignment operator and a conversion operator] [Pass]   [#]]
    [[mca_with_assignment_operator]           [run]       [check `mca` works when there is an assignment operator] [Pass]   [#]]
    [[mca_with_assignment_operator_and_implicit_constructor]  [run]   [check `mca` works when there is an assignment operator and implicit constructor] [Pass]   [#]]
    [[mca_with_assignment_operator_and_conversion_operator]   [run]   [check `mca` works when there is an assignment operator and a conversion operator] [Pass]   [#]]
]
[endsect]

[section Extrinsic Conversions]
[table
    [[Name]                 [kind]  [Description]                                           [Result] [Ticket]]
    [[explicit_convert_to]  [run]   [check `convert_to` works when `convert_to` is overloaded]  [Pass]   [#]]
    [[explicit_assign_to]   [run]   [check `assign_to` works when `assign_to` is overloaded]    [Pass]   [#]]
    [[explicit_lvalue]   [run]   [check `lvalue` works when `assign_to` is overloaded]    [Pass]   [#]]
]
[endsect]

[section Std]
[table
    [[Name]                     [kind]      [Description]                                                                   [Result] [Ticket]]
    [[convert_to_pair]          [run]       [check `convert_to` `std::pair` works when the parameters are convertible]               [Pass]   [#]]
    [/[convert_to_complex]       [run]       [check `convert_to` `std::complex` works when the parameters are convertible]            [Pass]   [#]]
    [[convert_to_vector]       [run]       [check `convert_to` `std::vector` works when the parameters are convertible]            [Pass]   [#]]
    [[convert_to_string]        [run]       [check `convert_to` `std::string` works when the parameter defines the `operator<<`]       [Pass]   [#]]
    [[convert_from_string]      [run]       [check `convert_to` from `std::string` works when the parameter defines the `operator>>`]  [Pass]   [#]]
]
[endsect]

[section Boost]
[table
    [[Name]                     [kind]  [Description]                                                           [Result] [Ticket]]
    [[convert_to_rational]      [run]   [check `convert_to` `boost::rational` works when the parameters are convertible]   [Pass]   [#]]
    [[convert_to_interval]      [run]   [check `convert_to` `boost::interval` works when the parameters are convertible]   [Pass]   [#]]
    [[convert_to_optional]      [run]   [check `convert_to` `boost::optional` works when the parameters are convertible]   [Pass]   [#]]
    [[convert_to_time_point]    [run]   [check `convert_to` `boost::chrono::system_clock::time_point` from boost::posix_time::ptime works]                          [Pass]   [#]]
    [[convert_to_ptime]         [run]   [check `convert_to` `boost::posix_time::ptime` from boost::chrono::system_clock::time_point works]                          [Pass]   [#]]
    [[convert_to_duration]      [run]   [check `convert_to` `boost::chrono::duration` from `boost::posix_time::time_duration` works]                    [Pass]   [#]]
    [[convert_to_time_duration] [run]   [check `convert_to` `boost::posix_time::time_duration` from `boost::chrono::duration` works]                    [Pass]   [#]]
    [[convert_to_array]      [run]   [check `convert_to` `boost::array` works when the parameters are convertible]   [Pass]   [#]]
    [[convert_to_tuple]      [run]   [check `convert_to` `boost::tuple` works when the parameters are convertible]   [Pass]   [#]]
]
[endsect]

[endsect]
[section  Appendix F: Tickets]

[endsect]
]
[/=====================================]
[section:todo  Appendix : Future plans]
[/=====================================]

[heading Tasks to do before review]


[heading Tasks to do if the library is accepted]

* Try to remove the constraint that a converter must inherit from true_type to help on the is_extrinsically_convertible prefdicate, and use the same techniques that are use to detect is_assignable, is_destructible, ...

[heading For later releases]

* Analize the impact of move semantics to the extrinsic conversion and assignments.
* Add the type traits specializations for the C++ Standard types.

[endsect]
[endsect]

