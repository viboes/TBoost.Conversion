<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Toward Boost.Conversion 0.6.0</title>
<link rel="stylesheet" href="./boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.76.0">
<link rel="home" href="index.html" title="Toward Boost.Conversion 0.6.0">
<link rel="next" href="boost/is_assignable.html" title="Struct template is_assignable">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../../boost.png"></td>
<td align="center"><a href="../../../../index.html">Home</a></td>
<td align="center"><a href="../../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav"><a accesskey="n" href="boost/is_assignable.html"><img src="../../../../doc/src/images/next.png" alt="Next"></a></div>
<div class="article">
<div class="titlepage">
<div>
<div><h2 class="title">
<a name="boost.conversion"></a>Toward Boost.Conversion 0.6.0</h2></div>
<div><div class="authorgroup"><div class="author"><h3 class="author">
<span class="firstname">Vicente J.</span> <span class="surname">Botet Escriba</span>
</h3></div></div></div>
<div><p class="copyright">Copyright &#169; 2009 -2011 Vicente J. Botet Escriba</p></div>
<div><div class="legalnotice">
<a name="idp13408208"></a><p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></div>
</div>
<hr>
</div>
<div class="toc">
<p><b>Table of Contents</b></p>
<dl>
<dt><span class="section"><a href="index.html#boost.conversion.overview">Overview</a></span></dt>
<dd><dl>
<dt><span class="section"><a href="index.html#boost.conversion.overview.scope">Scope</a></span></dt>
<dt><span class="section"><a href="index.html#boost.conversion.overview.motivation">Motivation</a></span></dt>
<dt><span class="section"><a href="index.html#boost.conversion.overview.description">Description</a></span></dt>
<dt><span class="section"><a href="index.html#boost.conversion.overview.caveats">Caveats</a></span></dt>
</dl></dd>
<dt><span class="section"><a href="index.html#boost.conversion.users_guide">Users' Guide</a></span></dt>
<dd><dl>
<dt><span class="section"><a href="index.html#boost.conversion.users_guide.getting_started">Getting
      Started</a></span></dt>
<dt><span class="section"><a href="index.html#boost.conversion.users_guide.tutorial">Tutorial</a></span></dt>
<dt><span class="section"><a href="index.html#boost.conversion.users_guide.examples">Examples</a></span></dt>
<dt><span class="section"><a href="index.html#boost.conversion.users_guide.ext_references">External
      Resources</a></span></dt>
</dl></dd>
<dt><span class="section"><a href="index.html#boost.conversion.reference">Reference</a></span></dt>
<dd><dl>
<dt><span class="section"><a href="index.html#boost.conversion.reference.type_traits_extensions">Type
      Traits Extensions</a></span></dt>
<dt><span class="section"><a href="index.html#core">Core</a></span></dt>
<dt><span class="section"><a href="index.html#c___standard_classes_specializations">C++ Standard classes specializations</a></span></dt>
<dt><span class="section"><a href="index.html#boost_classes_specializations">Boost classes specializations</a></span></dt>
</dl></dd>
<dt><span class="section"><a href="index.html#boost.conversion.appendices">Appendices</a></span></dt>
<dd><dl>
<dt><span class="section"><a href="index.html#boost.conversion.appendices.history">Appendix: History</a></span></dt>
<dt><span class="section"><a href="index.html#boost.conversion.appendices.rationale">Appendix: Design
      Rationale</a></span></dt>
<dt><span class="section"><a href="index.html#boost.conversion.appendices.implementation">Appendix:
      Implementation Notes</a></span></dt>
<dt><span class="section"><a href="index.html#boost.conversion.appendices.acknowledgements">Appendix:
      Acknowledgements</a></span></dt>
<dt><span class="section"><a href="index.html#boost.conversion.appendices.todo">Appendix : Future plans</a></span></dt>
</dl></dd>
</dl>
</div>
<div class="warning"><table border="0" summary="Warning">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Warning]" src="../../../../doc/src/images/warning.png"></td>
<th align="left">Warning</th>
</tr>
<tr><td align="left" valign="top"><p>
      Conversion is not a part of the Boost libraries.
    </p></td></tr>
</table></div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="boost.conversion.overview"></a><a class="link" href="index.html#boost.conversion.overview" title="Overview">Overview</a>
</h2></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="index.html#boost.conversion.overview.scope">Scope</a></span></dt>
<dt><span class="section"><a href="index.html#boost.conversion.overview.motivation">Motivation</a></span></dt>
<dt><span class="section"><a href="index.html#boost.conversion.overview.description">Description</a></span></dt>
<dt><span class="section"><a href="index.html#boost.conversion.overview.caveats">Caveats</a></span></dt>
</dl></div>
<a name="boost.conversion.overview.how_to_use_this_documentation"></a><h4>
<a name="idp13411920"></a>
      <a class="link" href="index.html#boost.conversion.overview.how_to_use_this_documentation">How
      to Use This Documentation</a>
    </h4>
<p>
      This documentation makes use of the following naming and formatting conventions.
    </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
          Code is in <code class="computeroutput"><span class="identifier">fixed</span> <span class="identifier">width</span>
          <span class="identifier">font</span></code> and is syntax-highlighted.
        </li>
<li class="listitem">
          Replaceable text that you will need to supply is in <em class="replaceable"><code>italics</code></em>.
        </li>
<li class="listitem">
          If a name refers to a free function, it is specified like this: <code class="computeroutput"><span class="identifier">free_function</span><span class="special">()</span></code>;
          that is, it is in code font and its name is followed by <code class="computeroutput"><span class="special">()</span></code>
          to indicate that it is a free function.
        </li>
<li class="listitem">
          If a name refers to a class template, it is specified like this: <code class="computeroutput"><span class="identifier">class_template</span><span class="special">&lt;&gt;</span></code>;
          that is, it is in code font and its name is followed by <code class="computeroutput"><span class="special">&lt;&gt;</span></code>
          to indicate that it is a class template.
        </li>
<li class="listitem">
          If a name refers to a function-like macro, it is specified like this:
          <code class="computeroutput"><span class="identifier">MACRO</span><span class="special">()</span></code>;
          that is, it is uppercase in code font and its name is followed by <code class="computeroutput"><span class="special">()</span></code> to indicate that it is a function-like
          macro. Object-like macros appear without the trailing <code class="computeroutput"><span class="special">()</span></code>.
        </li>
<li class="listitem">
          Names that refer to <span class="emphasis"><em>concepts</em></span> in the generic programming
          sense are specified in CamelCase.
        </li>
</ul></div>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
        In addition, notes such as this one specify non-essential information that
        provides additional background or rationale.
      </p></td></tr>
</table></div>
<p>
      Finally, you can mentally add the following to any code fragments in this document:
    </p>
<pre class="programlisting"><span class="comment">// Include all of the core Conversion files
</span><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">conversion</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">conversion</span><span class="special">;</span>
</pre>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost.conversion.overview.scope"></a><a class="link" href="index.html#boost.conversion.overview.scope" title="Scope">Scope</a>
</h3></div></div></div>
<p>
        <span class="bold"><strong>Boost.Conversion</strong></span> manages extrinsic conversion
        between unrelated types. These conversion can be seen as implicit or explicit
        conversions (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2380.pdf" target="_top"><span class="bold"><strong>N2380 - Explicit Conversion Operator Draft Working Paper (revision
        2)</strong></span></a>).
      </p>
<p>
        The conversion operator can not be overloaded with a free-standing function
        on C++. In the past, there were request to be able to overload the <code class="computeroutput"><span class="keyword">static_cast</span></code> operator <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2200.pdf" target="_top"><span class="bold"><strong>N2200 - Operator Overloading</strong></span></a>. The author of
        this library thinks that the language would be more uniform if this extrinsic
        overload would be possible. The new extrinsic conversion operators could
        take the following form
      </p>
<pre class="programlisting"><span class="keyword">operator</span> <span class="identifier">Target</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">Source</span><span class="special">&amp;</span> <span class="identifier">val</span><span class="special">);</span>

<span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="identifier">Target</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">Source</span><span class="special">&amp;</span> <span class="identifier">val</span><span class="special">);</span>
</pre>
<p>
        The assignment operator could also be overloaded by a free function with
        some limitations as described in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1676.htm" target="_top"><span class="bold"><strong>N1676 - Non-member overloaded copy assignment operator</strong></span></a>.
      </p>
<pre class="programlisting"><span class="identifier">Target</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span><span class="identifier">Target</span><span class="special">&amp;,</span> <span class="identifier">Source</span> <span class="keyword">const</span><span class="special">&amp;);</span>
</pre>
<p>
        <span class="bold"><strong>Boost.Conversion</strong></span> provides a library-based
        solution for these missing language features, shows its own limitations and
        propose some library workarounds needed to take care of an equivalent behavior.
      </p>
<p>
        Note that <span class="bold"><strong>Boost.Conversion</strong></span> is not particularly
        concerned with cases of:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
            type-to-type conversion via an input/output stream as Boost.LexicalCast
            does or
          </li>
<li class="listitem">
            string-to-type or type-to-string as Vladimir Batov's Boost.Convert proposal
            or
          </li>
<li class="listitem">
            string-to-type or type-to-string as Jeroen Habraken on going Boost.Coerce
            or
          </li>
<li class="listitem">
            numeric conversion as Boost.Numeric can do.
          </li>
</ul></div>
<p>
        When the users need to configure the conversion between specific value types
        they will need to use the specific interface these libraries provide.
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost.conversion.overview.motivation"></a><a class="link" href="index.html#boost.conversion.overview.motivation" title="Motivation">Motivation</a>
</h3></div></div></div>
<p>
        When conversion is useful, but not provided by unrelated classes, the recommended
        approach is to use a named free function. One example of this could be a
        <code class="computeroutput"><span class="identifier">date_to_week</span><span class="special">(</span><span class="identifier">date</span> <span class="keyword">const</span><span class="special">&amp;)</span></code> function.
      </p>
<p>
        This approach works well when the source and destination are known at compile
        time, but when templates are involved, it becomes problematic. How can one
        write generic code for user-supplied classes when the source and destination
        types could be anything? Predicting the name becomes impossible, <code class="computeroutput"><span class="keyword">operator</span> <span class="identifier">T</span><span class="special">()</span></code> is the accepted way to express such an
        intent.
      </p>
<pre class="programlisting"><span class="identifier">T</span> <span class="identifier">t</span> <span class="special">=</span> <span class="identifier">T</span><span class="special">(</span><span class="identifier">u</span><span class="special">);</span>
</pre>
<p>
        Generic programming demands syntactic regularity. <span class="bold"><strong>Boost.Conversion</strong></span>
        propose an all-purpose templated conversion function:
      </p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">class</span> <span class="identifier">Target</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Source</span> <span class="special">&gt;</span> 
<span class="identifier">Target</span> <span class="identifier">explicit_convert_to</span><span class="special">(</span> <span class="identifier">Source</span> <span class="keyword">const</span> <span class="special">&amp;</span> <span class="identifier">u</span> <span class="special">);</span>
</pre>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
          <code class="computeroutput"><span class="identifier">convert_to</span></code> is a short hand
          for <code class="computeroutput"><span class="identifier">explicit_convert_to</span></code>.
        </p></td></tr>
</table></div>
<p>
        that can be used inside templates as follows:
      </p>
<pre class="programlisting"><span class="identifier">T</span> <span class="identifier">t</span> <span class="special">=</span> <span class="identifier">explicit_convert_to</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;(</span><span class="identifier">u</span><span class="special">);</span>
</pre>
<p>
        When the Source is explicitly convertible to the Target this function calls
        explicitly the conversion operator
      </p>
<pre class="programlisting"><span class="special">{</span>
  <span class="keyword">return</span> <span class="identifier">Target</span><span class="special">(</span> <span class="identifier">u</span> <span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
        This function would have to be specialized for each pair of types which do
        not themselves define an explicit conversion.
      </p>
<pre class="programlisting"><span class="identifier">week</span> <span class="identifier">explicit_convert_to</span><span class="special">(</span> <span class="identifier">date</span> <span class="keyword">const</span> <span class="special">&amp;</span> <span class="identifier">u</span> <span class="special">)</span> <span class="special">{</span> <span class="special">...</span> <span class="special">}</span>
</pre>
<p>
        Unfortunately this doesn't works as overload resolution doesn't take care
        of template type parameters that can not be deduced from the function arguments.
        <span class="bold"><strong>Boost.Conversion</strong></span> provides a customization
        customization point that takes in account the <code class="computeroutput"><span class="identifier">Source</span></code>
        and the <code class="computeroutput"><span class="identifier">Target</span></code> types (see
        below).
      </p>
<p>
        To manage with extrinsically implicit conversion Boost.Conversion provides
        another all-purpose function template
      </p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">class</span> <span class="identifier">Tatget</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Source</span> <span class="special">&gt;</span> 
<span class="identifier">Target</span> <span class="identifier">implicit_convert_to</span><span class="special">(</span> <span class="identifier">Source</span> <span class="keyword">const</span> <span class="special">&amp;</span> <span class="identifier">u</span> <span class="special">);</span>
</pre>
<p>
        This function alone can not manage with implicit conversion, as <code class="computeroutput"><span class="identifier">implicit_convert_to</span></code> needs the target type
        to be stated explicitly.
      </p>
<pre class="programlisting"><span class="identifier">f</span><span class="special">(</span><span class="identifier">implicit_convert_to</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;(</span><span class="identifier">u</span><span class="special">));</span>
</pre>
<p>
        <span class="bold"><strong>Boost.Conversion</strong></span> provides an <code class="computeroutput"><span class="identifier">implicitly</span></code> (make implicitly convertible
        from) function that creates a class providing implicit conversion operators
        for <code class="computeroutput"><span class="identifier">Target</span></code> types for which
        the <code class="computeroutput"><span class="identifier">Source</span></code> type is convertible
        using the <code class="computeroutput"><span class="identifier">implicit_convert_to</span></code>
        function.
      </p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span> <span class="keyword">class</span> <span class="identifier">Source</span> <span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">convertible_from</span> 
<span class="special">{</span> 
  <span class="identifier">Source</span> <span class="identifier">data</span><span class="special">;</span>
<span class="keyword">public</span><span class="special">:</span>
  <span class="identifier">convertible_from</span><span class="special">(</span><span class="identifier">Source</span> <span class="identifier">source</span><span class="special">)</span> <span class="special">:</span> <span class="identifier">data</span><span class="special">(</span><span class="identifier">source</span><span class="special">)</span> <span class="special">{}</span>

  <span class="comment">// enabled if class Source is extrinsically implicit convertible to Target  
</span>  <span class="keyword">template</span> <span class="special">&lt;</span> <span class="keyword">class</span> <span class="identifier">Target</span> <span class="special">&gt;</span> 
  <span class="keyword">operator</span> <span class="identifier">Target</span><span class="special">()</span> <span class="special">{</span>
    <span class="keyword">return</span> <span class="identifier">implicit_convert_to</span><span class="special">&lt;</span><span class="identifier">Target</span><span class="special">&gt;(*</span><span class="keyword">this</span><span class="special">);</span>
  <span class="special">}</span>
<span class="special">};</span>
<span class="keyword">template</span> <span class="special">&lt;</span> <span class="keyword">class</span> <span class="identifier">Source</span> <span class="special">&gt;</span>
<span class="identifier">convertible_from</span><span class="special">&lt;</span><span class="identifier">From</span><span class="special">&gt;</span> <span class="identifier">implicitly</span><span class="special">(</span><span class="identifier">Source</span> <span class="identifier">source</span><span class="special">)</span> 
<span class="special">{</span> 
  <span class="keyword">return</span> <span class="identifier">convertible_from</span><span class="special">&lt;</span><span class="identifier">Source</span><span class="special">&gt;(</span><span class="identifier">source</span><span class="special">);</span> 
<span class="special">}</span> 
</pre>
<p>
        Now the user can use the implicitly function to pass parameters that are
        extrinsically implicit convertibles without stating explicitly the type as
        follows
      </p>
<pre class="programlisting"><span class="identifier">T</span> <span class="identifier">v</span><span class="special">;</span>
<span class="identifier">f</span><span class="special">(</span><span class="identifier">implicitly</span><span class="special">(</span><span class="identifier">v</span><span class="special">));</span>
</pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost.conversion.overview.description"></a><a class="link" href="index.html#boost.conversion.overview.description" title="Description">Description</a>
</h3></div></div></div>
<p>
        <span class="bold"><strong>Boost.Conversion</strong></span> provides:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
            a generic <code class="computeroutput"><span class="identifier">implicit_convert_to</span></code>
            function which can be customized by the user to make implicit conversion
            between unrelated types.
          </li>
<li class="listitem">
            a generic <code class="computeroutput"><span class="identifier">explicit_convert_to</span></code>
            function which can be customized by the user to make explicit conversion
            between unrelated types.
          </li>
<li class="listitem">
            a generic <code class="computeroutput"><span class="identifier">convert_to</span></code>
            function which is equivalent <code class="computeroutput"><span class="identifier">explicit_convert_to</span></code>
            or that behaves as a functor factory if its argument is a fusion actor.
          </li>
<li class="listitem">
            a generic <code class="computeroutput"><span class="identifier">assign_to</span></code> function
            which can be customized by the user to make explicit assignments between
            unrelated types.
          </li>
<li class="listitem">
            a generic <code class="computeroutput"><span class="identifier">try_convert_to</span></code>
            function which can be customized by the user to make explicit optional
            conversion between unrelated types.
          </li>
<li class="listitem">
            a generic <code class="computeroutput"><span class="identifier">try_assign_to</span></code>
            function which can be customized by the user to make explicit optional
            assignments between unrelated types.
          </li>
<li class="listitem">
            a generic <code class="computeroutput"><span class="identifier">convert_to_or_fallback</span></code>
            function which can be customized by the user to make explicit conversion
            between unrelated types, relying on a fallback when the conversion fails.
          </li>
<li class="listitem">
            a generic <code class="computeroutput"><span class="identifier">lvalue</span></code> function
            returning a <code class="computeroutput"><span class="identifier">assignable_to</span></code>
            wrapper which implements assignments by calls to <code class="computeroutput"><span class="identifier">assign_to</span></code>.
          </li>
<li class="listitem">
            a generic <code class="computeroutput"><span class="identifier">implicitly</span></code>
            function returning a <code class="computeroutput"><span class="identifier">convertible_from</span></code>
            wrapper which implements the implicit conversion operators by calls to
            <code class="computeroutput"><span class="identifier">implicit_convert_to</span></code>.
          </li>
<li class="listitem">
            a <code class="computeroutput"><span class="identifier">convertible_to</span></code> wrapper
            that acts as a implicit converter when passing parameters to a function.
          </li>
<li class="listitem">
            conversion between <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span></code>
            of explicitly convertible types.
          </li>
<li class="listitem">
            conversion between <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span></code>
            of explicitly convertible types.
          </li>
<li class="listitem">
            conversion from/to <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></code>
            for types for which lexical cast works.
          </li>
<li class="listitem">
            conversion between <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">array</span></code>
            of explicitly convertible types.
          </li>
<li class="listitem">
            conversion between <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span></code>
            and <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">ptime</span></code>.
          </li>
<li class="listitem">
            conversion between <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span></code>
            and <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">time_duration</span></code>.
          </li>
<li class="listitem">
            conversion between <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">numeric</span><span class="special">::</span><span class="identifier">interval</span></code>
            of explicitly convertible types.
          </li>
<li class="listitem">
            conversion between <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">optional</span></code>
            of explicitly convertible types.
          </li>
<li class="listitem">
            conversion between <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">rational</span></code>
            of explicitly convertible types.
          </li>
<li class="listitem">
            conversion between Boost.Fusion sequences (tuples) of explicitly convertible
            types.
          </li>
</ul></div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost.conversion.overview.caveats"></a><a class="link" href="index.html#boost.conversion.overview.caveats" title="Caveats">Caveats</a>
</h3></div></div></div>
<p>
        In order to provide the needed functionality, two type traits are mandatory:
        <code class="computeroutput"><span class="identifier">is_constructible</span></code> and <code class="computeroutput"><span class="identifier">is_assignable</span></code>. The library provides a first
        implementation of these type traits that works on compilers providing some
        specific features. The idea is that these type traits should be added to
        <span class="bold"><strong>Boost.TypeTraits</strong></span>.
      </p>
<p>
        When the compiler doesn't provides with automatic ways to detect these traits,
        the library provides specializations for some std and boost types. If accepted
        the library will provide the specializations for all the standard types and
        optionally for all the Boost types.
      </p>
<p>
        Users working with compilers not supporting the definition of these traits,
        or users that need to make their code portable, will need to specialize these
        traits by hand.
      </p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="boost.conversion.users_guide"></a><a class="link" href="index.html#boost.conversion.users_guide" title="Users' Guide">Users' Guide</a>
</h2></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="index.html#boost.conversion.users_guide.getting_started">Getting
      Started</a></span></dt>
<dd><dl>
<dt><span class="section"><a href="index.html#boost.conversion.users_guide.getting_started.install">Installing
        Conversion</a></span></dt>
<dt><span class="section"><a href="index.html#boost.conversion.users_guide.getting_started.hello_world__">Hello
        World! </a></span></dt>
</dl></dd>
<dt><span class="section"><a href="index.html#boost.conversion.users_guide.tutorial">Tutorial</a></span></dt>
<dd><dl>
<dt><span class="section"><a href="index.html#boost.conversion.users_guide.tutorial.using_extrinsic_conversions_and_assignments">Using
        extrinsic conversions and assignments</a></span></dt>
<dt><span class="section"><a href="index.html#boost.conversion.users_guide.tutorial.chaining_assignments">Chaining
        assignments</a></span></dt>
<dt><span class="section"><a href="index.html#boost.conversion.users_guide.tutorial.using_specific_conversions">Using
        specific conversions</a></span></dt>
<dt><span class="section"><a href="index.html#boost.conversion.users_guide.tutorial.handling_invalid_conversions">Handling
        invalid conversions</a></span></dt>
<dt><span class="section"><a href="index.html#boost.conversion.users_guide.tutorial.handling_invalid_conversions_via_a_fallback">Handling
        invalid conversions via a fallback</a></span></dt>
<dt><span class="section"><a href="index.html#boost.conversion.users_guide.tutorial.can_extrinsic_conversions_be_applied_implicitly_">Can
        extrinsic conversions be applied implicitly?</a></span></dt>
<dt><span class="section"><a href="index.html#boost.conversion.users_guide.tutorial.how_to_write_a_function_that_accepts_a_parameter_that_is_extrinsically_convertible_to_a_given_type_">How
        to write a function that accepts a parameter that is extrinsically convertible
        to a given type?</a></span></dt>
<dt><span class="section"><a href="index.html#boost.conversion.users_guide.tutorial.functors">Functors</a></span></dt>
<dt><span class="section"><a href="index.html#boost.conversion.users_guide.tutorial.usage_of___implicit_convert_to____explicit_convert_to_or___assign_to">Usage
        of <code class="computeroutput"><span class="identifier">implicit_convert_to</span></code>,
        <code class="computeroutput"><span class="identifier">explicit_convert_to</span></code> or <code class="computeroutput"><span class="identifier">assign_to</span></code></a></span></dt>
<dt><span class="section"><a href="index.html#boost.conversion.users_guide.tutorial.how_to_specialize_extrinsic_conversions_">How
        to specialize extrinsic conversions?</a></span></dt>
<dt><span class="section"><a href="index.html#boost.conversion.users_guide.tutorial.what_to_do_when_the_compiler_doesn_t_supports_the_definition_of_the_needed_type_traits_">What
        to do when the compiler doesn't supports the definition of the needed type
        traits?</a></span></dt>
</dl></dd>
<dt><span class="section"><a href="index.html#boost.conversion.users_guide.examples">Examples</a></span></dt>
<dt><span class="section"><a href="index.html#boost.conversion.users_guide.ext_references">External
      Resources</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost.conversion.users_guide.getting_started"></a><a class="link" href="index.html#boost.conversion.users_guide.getting_started" title="Getting Started">Getting
      Started</a>
</h3></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="index.html#boost.conversion.users_guide.getting_started.install">Installing
        Conversion</a></span></dt>
<dt><span class="section"><a href="index.html#boost.conversion.users_guide.getting_started.hello_world__">Hello
        World! </a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost.conversion.users_guide.getting_started.install"></a><a class="link" href="index.html#boost.conversion.users_guide.getting_started.install" title="Installing Conversion">Installing
        Conversion</a>
</h4></div></div></div>
<a name="boost.conversion.users_guide.getting_started.install.getting_boost_conversion"></a><h6>
<a name="idp13651184"></a>
          <a class="link" href="index.html#boost.conversion.users_guide.getting_started.install.getting_boost_conversion">Getting
          Boost.Conversion</a>
        </h6>
<p>
          You can get the last stable release of Boost.Conversion by downloading
          <code class="literal">conversion.zip</code> from the <a href="http://www.boostpro.com/vault/index.php?action=downloadfile&amp;filename=conversion.zip&amp;directory=Utilities&amp;" target="_top">Boost
          Vault Utilities directory</a>
        </p>
<p>
          You can also access the latest (unstable?) state from the <a href="https://svn.boost.org/svn/boost/sandbox/conversion" target="_top">Boost
          Sandbox</a>.
        </p>
<a name="boost.conversion.users_guide.getting_started.install.building_boost_conversion"></a><h6>
<a name="idp13656176"></a>
          <a class="link" href="index.html#boost.conversion.users_guide.getting_started.install.building_boost_conversion">Building
          Boost.Conversion</a>
        </h6>
<p>
          There is no need to compile <span class="bold"><strong>Boost.Conversion</strong></span>,
          since it's a header only library. Just include your Boost header directory
          in your compiler include path.
        </p>
<a name="boost.conversion.users_guide.getting_started.install.requirements"></a><h6>
<a name="idp13659232"></a>
          <a class="link" href="index.html#boost.conversion.users_guide.getting_started.install.requirements">Requirements</a>
        </h6>
<p>
          The generic part of <span class="bold"><strong>Boost.Conversion</strong></span> depends
          on <span class="bold"><strong>Boost.Config</strong></span>, <span class="bold"><strong>Boost.TypeTraits</strong></span>,
          <span class="bold"><strong>Boost.Optional</strong></span> and <span class="bold"><strong>Boost.Fusion</strong></span>.
          Of course it depends on the specific libraries when specific conversion
          are used from the directories <code class="computeroutput"><span class="identifier">boost</span><span class="special">/</span><span class="identifier">conversion</span><span class="special">/</span><span class="identifier">boost</span></code>,
          in particular <span class="bold"><strong>Boost.Chrono</strong></span> and <span class="bold"><strong>Boost.DateTime</strong></span>, which need to link with.
        </p>
<p>
          The library works well only on compilers that are able to define the traits
          <code class="computeroutput"><span class="identifier">is_constructible</span></code> and <code class="computeroutput"><span class="identifier">is_assignable</span></code>, that is compilers supporting
          <code class="computeroutput"><span class="identifier">decltype</span></code> and SFINAE for
          expressions. For the other compilers the library has much more limitations.
        </p>
<a name="boost.conversion.users_guide.getting_started.install.exceptions_safety"></a><h6>
<a name="idp13672384"></a>
          <a class="link" href="index.html#boost.conversion.users_guide.getting_started.install.exceptions_safety">Exceptions
          safety</a>
        </h6>
<p>
          All functions in the library are exception-neutral and provide strong guarantee
          of exception safety as long as the underlying parameters provide it.
        </p>
<a name="boost.conversion.users_guide.getting_started.install.thread_safety"></a><h6>
<a name="idp13674976"></a>
          <a class="link" href="index.html#boost.conversion.users_guide.getting_started.install.thread_safety">Thread
          safety</a>
        </h6>
<p>
          All functions in the library are thread-unsafe except when noted explicitly.
        </p>
<a name="boost.conversion.users_guide.getting_started.install.tested_compilers"></a><h6>
<a name="idp13677488"></a>
          <a class="link" href="index.html#boost.conversion.users_guide.getting_started.install.tested_compilers">Tested
          compilers</a>
        </h6>
<p>
          <span class="bold"><strong>Boost.Conversion</strong></span> is known to work on the
          following platforms/compilers (lack of some C++/C++0X language support
          disables some functionality). The needed C++/C++0X language support is:
        </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
              dectype or SFINAE on expressions,
            </li>
<li class="listitem">
              allow to define function template with default arguments,
            </li>
<li class="listitem">
            </li>
</ul></div>
<p>
          At present the author is unable to define the type traits <code class="computeroutput"><span class="identifier">is_constructible</span></code> and <code class="computeroutput"><span class="identifier">is_assignable</span></code>
          if dectype and SFINAE on expressions is not available. On compilers that
          <code class="computeroutput"><span class="identifier">is_constructible</span></code> and <code class="computeroutput"><span class="identifier">is_assignable</span></code> can not be detected by
          the library, the user will need to specialize these traits explicitly.
          The library defines two macros <code class="computeroutput"><span class="identifier">BOOST_CONVERSION_NO_IS_CONSTRUCTIBLE</span></code>
          and <code class="computeroutput"><span class="identifier">BOOST_CONVERSION_NO_IS_ASSIGNABLE</span></code>
          allowing to make the specialization only when needed.
        </p>
<p>
          The <code class="computeroutput"><span class="identifier">implicitly</span><span class="special">()</span></code>
          function and the <code class="computeroutput"><span class="identifier">convertible_from</span></code>
          class are not provided on compilers on which <code class="computeroutput"><span class="identifier">BOOST_NO_FUNCTION_TEMPLATE_DEFAULT_ARGS</span></code>
          is defined.
        </p>
<p>
          Currently, <span class="bold"><strong>Boost.Conversion</strong></span> has been tested
          in the following compilers/platforms using the trunk (Boost 1.47):
        </p>
<p>
          Windows with
        </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
              MSVC 10.0 (needs to specialize <code class="computeroutput"><span class="identifier">is_constructible</span></code>
              and <code class="computeroutput"><span class="identifier">is_assignable</span></code> can
              not be defined)
            </li></ul></div>
<p>
          Cygwin 1.7 with
        </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
              GCC 4.3.4 (has some problems as <code class="computeroutput"><span class="identifier">is_constructible</span></code>
              and <code class="computeroutput"><span class="identifier">is_assignable</span></code> can
              not be defined)
            </li></ul></div>
<p>
          MinGW with
        </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
              GCC 4.5.0
            </li>
<li class="listitem">
              GCC 4.5.0 -std=c++0x
            </li>
<li class="listitem">
              GCC 4.5.2
            </li>
<li class="listitem">
              GCC 4.5.2 -std=c++0x
            </li>
<li class="listitem">
              GCC 4.6.0
            </li>
<li class="listitem">
              GCC 4.6.0 -std=c++0x
            </li>
</ul></div>
<p>
          Darwin 10
        </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
              GCC 4.1.2 (has some problems as <code class="computeroutput"><span class="identifier">is_constructible</span></code>
              and <code class="computeroutput"><span class="identifier">is_assignable</span></code> can
              not be defined)
            </li>
<li class="listitem">
              clang 1.6 (has some problems as <code class="computeroutput"><span class="identifier">is_constructible</span></code>
              and <code class="computeroutput"><span class="identifier">is_assignable</span></code> can
              not be defined)
            </li>
<li class="listitem">
              clang 2.9
            </li>
<li class="listitem">
              clang 2.9 -std=c++0x
            </li>
</ul></div>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
            Please let us know how this works on other platforms/compilers.
          </p></td></tr>
</table></div>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
            Please send any questions, comments and bug reports to boost &lt;at&gt;
            lists &lt;dot&gt; boost &lt;dot&gt; org.
          </p></td></tr>
</table></div>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title">
<a name="boost.conversion.users_guide.getting_started.hello_world__"></a><a class="link" href="index.html#boost.conversion.users_guide.getting_started.hello_world__" title="Hello World!">Hello
        World! </a>
</h4></div></div></div></div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost.conversion.users_guide.tutorial"></a><a class="link" href="index.html#boost.conversion.users_guide.tutorial" title="Tutorial">Tutorial</a>
</h3></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="index.html#boost.conversion.users_guide.tutorial.using_extrinsic_conversions_and_assignments">Using
        extrinsic conversions and assignments</a></span></dt>
<dt><span class="section"><a href="index.html#boost.conversion.users_guide.tutorial.chaining_assignments">Chaining
        assignments</a></span></dt>
<dt><span class="section"><a href="index.html#boost.conversion.users_guide.tutorial.using_specific_conversions">Using
        specific conversions</a></span></dt>
<dt><span class="section"><a href="index.html#boost.conversion.users_guide.tutorial.handling_invalid_conversions">Handling
        invalid conversions</a></span></dt>
<dt><span class="section"><a href="index.html#boost.conversion.users_guide.tutorial.handling_invalid_conversions_via_a_fallback">Handling
        invalid conversions via a fallback</a></span></dt>
<dt><span class="section"><a href="index.html#boost.conversion.users_guide.tutorial.can_extrinsic_conversions_be_applied_implicitly_">Can
        extrinsic conversions be applied implicitly?</a></span></dt>
<dt><span class="section"><a href="index.html#boost.conversion.users_guide.tutorial.how_to_write_a_function_that_accepts_a_parameter_that_is_extrinsically_convertible_to_a_given_type_">How
        to write a function that accepts a parameter that is extrinsically convertible
        to a given type?</a></span></dt>
<dt><span class="section"><a href="index.html#boost.conversion.users_guide.tutorial.functors">Functors</a></span></dt>
<dt><span class="section"><a href="index.html#boost.conversion.users_guide.tutorial.usage_of___implicit_convert_to____explicit_convert_to_or___assign_to">Usage
        of <code class="computeroutput"><span class="identifier">implicit_convert_to</span></code>,
        <code class="computeroutput"><span class="identifier">explicit_convert_to</span></code> or <code class="computeroutput"><span class="identifier">assign_to</span></code></a></span></dt>
<dt><span class="section"><a href="index.html#boost.conversion.users_guide.tutorial.how_to_specialize_extrinsic_conversions_">How
        to specialize extrinsic conversions?</a></span></dt>
<dt><span class="section"><a href="index.html#boost.conversion.users_guide.tutorial.what_to_do_when_the_compiler_doesn_t_supports_the_definition_of_the_needed_type_traits_">What
        to do when the compiler doesn't supports the definition of the needed type
        traits?</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost.conversion.users_guide.tutorial.using_extrinsic_conversions_and_assignments"></a><a class="link" href="index.html#boost.conversion.users_guide.tutorial.using_extrinsic_conversions_and_assignments" title="Using extrinsic conversions and assignments">Using
        extrinsic conversions and assignments</a>
</h4></div></div></div>
<p>
          When you need to make a extrinsic explicit conversion, simply include the
          file <code class="computeroutput"><span class="identifier">boost</span><span class="special">/</span><span class="identifier">conversion</span><span class="special">/</span><span class="identifier">convert_to</span><span class="special">.</span><span class="identifier">hpp</span></code> and use the <code class="computeroutput"><span class="identifier">convert_to</span></code>
          function.
        </p>
<p>
          
</p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">conversion</span><span class="special">/</span><span class="identifier">convert_to</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">conversion</span><span class="special">/</span><span class="identifier">std</span><span class="special">/</span><span class="identifier">string</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">iostream</span><span class="special">&gt;</span>
<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">conversion</span><span class="special">;</span>

<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">bool</span> <span class="identifier">is_even</span><span class="special">(</span><span class="identifier">T</span> <span class="identifier">val</span><span class="special">)</span>
<span class="special">{</span>
  <span class="keyword">return</span> <span class="special">(</span><span class="identifier">convert_to</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;(</span><span class="identifier">val</span><span class="special">)</span> <span class="special">%</span> <span class="number">2</span><span class="special">)==</span><span class="number">0</span><span class="special">;</span>
<span class="special">}</span>
<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span>
<span class="special">{</span>
  <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">str</span> <span class="special">=</span> <span class="string">"2"</span><span class="special">;</span>
  <span class="keyword">if</span> <span class="special">(</span><span class="identifier">is_even</span><span class="special">(</span><span class="identifier">str</span><span class="special">))</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"2 is even"</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
  <span class="keyword">else</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"2 is odd"</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>

  <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
<span class="special">}</span>

</pre>
<p>
        </p>
<p>
          The result of this program will evidently be
        </p>
<pre class="programlisting"><span class="number">2</span> <span class="identifier">is</span> <span class="identifier">even</span><span class="special">.</span>
</pre>
<p>
          <span class="emphasis"><em>See the source file <a href="../../example/even.cpp" target="_top">example/even.cpp</a></em></span>
        </p>
<p>
          The <code class="computeroutput"><span class="identifier">convert_to</span></code> function
          returns the explicit conversion to the target type.
        </p>
<pre class="programlisting"><span class="keyword">return</span> <span class="identifier">Target</span><span class="special">(</span><span class="identifier">source</span><span class="special">);</span>
</pre>
<p>
          When the extrinsic conversion must be stored in a variable you can use
          <code class="computeroutput"><span class="identifier">assign_to</span></code> instead. If the
          trait <code class="computeroutput"><span class="identifier">is_assignable</span><span class="special">&lt;</span><span class="identifier">Target</span><span class="special">,</span><span class="identifier">Source</span><span class="special">&gt;</span></code>
          is a <code class="computeroutput"><span class="identifier">true_type</span></code>, <code class="computeroutput"><span class="identifier">assign_to</span></code>(target,source) calls to the
          assignment operator,
        </p>
<pre class="programlisting"><span class="identifier">target</span> <span class="special">=</span> <span class="identifier">source</span><span class="special">;</span>
</pre>
<p>
          otherwise it does
        </p>
<pre class="programlisting"><span class="identifier">target</span> <span class="special">=</span> <span class="identifier">convert_to</span><span class="special">&lt;</span><span class="identifier">Target</span><span class="special">&gt;(</span><span class="identifier">source</span><span class="special">);</span>
</pre>
<p>
          when <code class="computeroutput"><span class="identifier">Source</span></code> is extrinsically
          convertible to <code class="computeroutput"><span class="identifier">Target</span></code>.
        </p>
<p>
          For example the user can implement a function that swaps two convertible
          types as follows:
        </p>
<p>
          
</p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">conversion</span><span class="special">/</span><span class="identifier">assign_to</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">iostream</span><span class="special">&gt;</span>
<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">conversion</span><span class="special">;</span>

<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">U</span><span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">swap_convertibles</span><span class="special">(</span><span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">t</span><span class="special">,</span> <span class="identifier">U</span><span class="special">&amp;</span> <span class="identifier">u</span><span class="special">)</span>
<span class="special">{</span>
  <span class="identifier">T</span> <span class="identifier">tmp</span><span class="special">(</span><span class="identifier">t</span><span class="special">);</span>
  <span class="identifier">assign_to</span><span class="special">(</span><span class="identifier">t</span><span class="special">,</span><span class="identifier">u</span><span class="special">);</span>
  <span class="identifier">assign_to</span><span class="special">(</span><span class="identifier">u</span><span class="special">,</span><span class="identifier">tmp</span><span class="special">);</span>
<span class="special">}</span>
<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span>
<span class="special">{</span>
  <span class="keyword">int</span> <span class="identifier">i</span> <span class="special">=</span> <span class="number">3</span><span class="special">;</span>
  <span class="keyword">float</span> <span class="identifier">x</span> <span class="special">=</span> <span class="number">2.5</span><span class="special">;</span>

  <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"i= "</span> <span class="special">&lt;&lt;</span> <span class="identifier">i</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
  <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"x= "</span> <span class="special">&lt;&lt;</span> <span class="identifier">x</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>

  <span class="identifier">swap_convertibles</span><span class="special">(</span><span class="identifier">i</span><span class="special">,</span> <span class="identifier">x</span><span class="special">);</span>

  <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"i= "</span> <span class="special">&lt;&lt;</span> <span class="identifier">i</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
  <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"x= "</span> <span class="special">&lt;&lt;</span> <span class="identifier">x</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
  <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
<span class="special">}</span>


</pre>
<p>
        </p>
<p>
          The result of this program will be
        </p>
<pre class="programlisting"><span class="identifier">i</span><span class="special">=</span> <span class="number">3</span>
<span class="identifier">x</span><span class="special">=</span> <span class="number">2.5</span>
<span class="identifier">i</span><span class="special">=</span> <span class="number">2</span>
<span class="identifier">x</span><span class="special">=</span> <span class="number">3</span>
</pre>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
            The name <code class="computeroutput"><span class="identifier">convert_to</span></code> could
            also be <code class="computeroutput"><span class="identifier">convert</span></code> and
            <code class="computeroutput"><span class="identifier">assign_to</span></code> be <code class="computeroutput"><span class="identifier">assign</span></code>, but I find the current names
            more coherent with the other names used by the library. If the Boost
            community agree on better names globally I will adopt them.
          </p></td></tr>
</table></div>
<p>
          <span class="emphasis"><em>See the source file <a href="../../example/swap.cpp" target="_top">example/swap.cpp</a></em></span>
        </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost.conversion.users_guide.tutorial.chaining_assignments"></a><a class="link" href="index.html#boost.conversion.users_guide.tutorial.chaining_assignments" title="Chaining assignments">Chaining
        assignments</a>
</h4></div></div></div>
<p>
          When doing multiple assignments the user use to do
        </p>
<pre class="programlisting"><span class="identifier">a</span> <span class="special">=</span> <span class="identifier">b</span> <span class="special">=</span> <span class="identifier">c</span><span class="special">;</span>
</pre>
<p>
          With <code class="computeroutput"><span class="identifier">assign_to</span></code> the users
          could do
        </p>
<pre class="programlisting"><span class="identifier">assign_to</span><span class="special">(</span><span class="identifier">a</span><span class="special">,</span> <span class="identifier">assign_to</span><span class="special">(</span><span class="identifier">b</span><span class="special">,</span> <span class="identifier">c</span><span class="special">));</span>
</pre>
<p>
          and if they find this not really readable they can try with the <span class="bold"><strong>m</strong></span>ake <span class="bold"><strong>a</strong></span>ssigner
          <span class="bold"><strong>t</strong></span>o `lvalue' free function.
        </p>
<pre class="programlisting"><span class="identifier">lvalue</span><span class="special">(</span><span class="identifier">a</span><span class="special">)</span> <span class="special">=</span> <span class="identifier">lvalue</span><span class="special">(</span><span class="identifier">b</span><span class="special">)</span> <span class="special">=</span> <span class="identifier">c</span><span class="special">;</span>
</pre>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
            The name <code class="computeroutput"><span class="identifier">lvalue</span></code> comes
            from the fact that it builds a lvalue that is able to works with extrinsic
            conversions.
          </p></td></tr>
</table></div>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost.conversion.users_guide.tutorial.using_specific_conversions"></a><a class="link" href="index.html#boost.conversion.users_guide.tutorial.using_specific_conversions" title="Using specific conversions">Using
        specific conversions</a>
</h4></div></div></div>
<p>
          When you need to make a specific conversion you will need to include the
          specific conversion file. E.g.
        </p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">conversion</span><span class="special">/</span><span class="identifier">convert_to</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">conversion</span><span class="special">/</span><span class="identifier">std</span><span class="special">/</span><span class="identifier">pair</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">conversion</span><span class="special">;</span>

<span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">,</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="identifier">pint</span><span class="special">(</span><span class="number">0</span><span class="special">,</span><span class="number">1</span><span class="special">);</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">,</span><span class="keyword">double</span><span class="special">&gt;</span> <span class="identifier">pdouble</span><span class="special">=</span><span class="identifier">convert_to</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">,</span><span class="keyword">double</span><span class="special">&gt;</span> <span class="special">&gt;(</span><span class="identifier">pint</span><span class="special">);</span>
</pre>
<p>
          Do not forget to include these files when you use a generic class or algorithm
          using the generic <code class="computeroutput"><span class="identifier">convert_to</span></code>
          or <code class="computeroutput"><span class="identifier">assign_to</span></code>, otherwise
          your program will not compile. E.g. if you want to convert a pair of <code class="computeroutput"><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;&gt;</span></code>
          to a pair of <code class="computeroutput"><span class="identifier">posix_time</span><span class="special">::</span><span class="identifier">ptime</span></code>
          do not forget to include both <code class="computeroutput"><span class="identifier">boost</span><span class="special">/</span><span class="identifier">conversion</span><span class="special">/</span><span class="identifier">std</span><span class="special">/</span><span class="identifier">pair</span><span class="special">.</span><span class="identifier">hpp</span></code>
          and <code class="computeroutput"><span class="identifier">boost</span><span class="special">/</span><span class="identifier">conversion</span><span class="special">/</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">chrono_posix_time</span><span class="special">.</span><span class="identifier">hpp</span></code>
        </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost.conversion.users_guide.tutorial.handling_invalid_conversions"></a><a class="link" href="index.html#boost.conversion.users_guide.tutorial.handling_invalid_conversions" title="Handling invalid conversions">Handling
        invalid conversions</a>
</h4></div></div></div>
<p>
          The expected behavior of <code class="computeroutput"><span class="identifier">convert_to</span></code>
          is to throw an exception when the conversion is not possible. If an action
          must be taken on failure the user needs to use a try-catch
        </p>
<p>
          
</p>
<pre class="programlisting"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">str</span><span class="special">=</span><span class="string">"not an int"</span><span class="special">;</span>
<span class="keyword">int</span> <span class="identifier">t</span><span class="special">;</span>
<span class="keyword">try</span> <span class="special">{</span>
  <span class="identifier">t</span> <span class="special">=</span> <span class="identifier">convert_to</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;(</span><span class="identifier">str</span><span class="special">);</span>
  <span class="special">(</span><span class="keyword">void</span><span class="special">)</span><span class="identifier">t</span><span class="special">;</span> <span class="comment">// warning removal
</span>  <span class="identifier">BOOST_ASSERT</span><span class="special">(</span><span class="keyword">false</span><span class="special">);</span>
<span class="special">}</span> <span class="keyword">catch</span><span class="special">(...)</span>   <span class="special">{</span>
  <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">" Not an integer"</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
        </p>
<p>
          Sometimes the user could prefer no-throw behavior. The library provides
          a way to get this behavior with the <code class="computeroutput"><span class="identifier">try_convert_to</span></code>
          function, which returns an optional that is initialized only when the conversion
          succeeds.
        </p>
<p>
          
</p>
<pre class="programlisting"><span class="identifier">optional</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="identifier">optt</span> <span class="special">=</span>  <span class="identifier">try_convert_to</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;(</span><span class="identifier">str</span><span class="special">);</span>
<span class="keyword">if</span> <span class="special">(!</span><span class="identifier">optt</span><span class="special">)</span>
<span class="special">{</span>
  <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">" Not an integer"</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
  <span class="identifier">BOOST_ASSERT</span><span class="special">(</span><span class="keyword">true</span><span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
        </p>
<p>
          which is equivalent to
        </p>
<p>
          
</p>
<pre class="programlisting"><span class="identifier">optional</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="identifier">optt</span> <span class="special">=</span>  <span class="identifier">convert_to</span><span class="special">&lt;</span><span class="identifier">optional</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="special">&gt;(</span><span class="identifier">str</span><span class="special">);</span>
<span class="keyword">if</span> <span class="special">(!</span><span class="identifier">optt</span><span class="special">)</span>
<span class="special">{</span>
  <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">" Not an integer"</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
  <span class="identifier">BOOST_ASSERT</span><span class="special">(</span><span class="keyword">true</span><span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
        </p>
<p>
          Last the user can get the same behavior using the <code class="computeroutput"><span class="identifier">try_assign_to</span></code>
          function, which returns if the assignment succeeded or not
        </p>
<p>
          
</p>
<pre class="programlisting"><span class="keyword">if</span> <span class="special">(!</span><span class="identifier">try_assign_to</span><span class="special">(</span><span class="identifier">t</span><span class="special">,</span><span class="identifier">str</span><span class="special">))</span>
<span class="special">{</span>
  <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">" Not an integer"</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
  <span class="identifier">BOOST_ASSERT</span><span class="special">(</span><span class="keyword">true</span><span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
        </p>
<p>
          <span class="emphasis"><em>See the source file <a href="../../example/no_throw.cpp" target="_top">example/no_throw.cpp</a></em></span>
        </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost.conversion.users_guide.tutorial.handling_invalid_conversions_via_a_fallback"></a><a class="link" href="index.html#boost.conversion.users_guide.tutorial.handling_invalid_conversions_via_a_fallback" title="Handling invalid conversions via a fallback">Handling
        invalid conversions via a fallback</a>
</h4></div></div></div>
<p>
          In some cases the conversion failure can be ignored and the result replaced
          with a fallback value. There are some ways to manage with that
        </p>
<p>
          
</p>
<pre class="programlisting"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">str</span><span class="special">=</span><span class="string">"not an int"</span><span class="special">;</span>
<span class="keyword">int</span> <span class="identifier">t</span><span class="special">=-</span><span class="number">1</span><span class="special">;</span>
<span class="identifier">try_assign_to</span><span class="special">(</span><span class="identifier">t</span><span class="special">,</span><span class="identifier">str</span><span class="special">);</span>
<span class="identifier">BOOST_ASSERT</span><span class="special">(</span><span class="identifier">t</span><span class="special">==-</span><span class="number">1</span><span class="special">);</span>
</pre>
<p>
        </p>
<p>
          Note the use <code class="computeroutput"><span class="identifier">try_assign_to</span></code>
          instead of <code class="computeroutput"><span class="identifier">assign_to</span></code>, as
          it avoids an exception if the conversion fails, as there is a fallback
          value already.
        </p>
<p>
          The library provides a specific function <code class="computeroutput"><span class="identifier">convert_to_or_fallback</span></code>
          that does that exactly
        </p>
<p>
          
</p>
<pre class="programlisting"><span class="keyword">short</span> <span class="identifier">f</span><span class="special">=-</span><span class="number">1</span><span class="special">;</span>
<span class="keyword">int</span> <span class="identifier">t</span> <span class="special">=</span> <span class="identifier">convert_to_or_fallback</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;(</span><span class="identifier">str</span><span class="special">,</span><span class="identifier">f</span><span class="special">);</span>
<span class="identifier">BOOST_ASSERT</span><span class="special">(</span><span class="identifier">t</span><span class="special">==-</span><span class="number">1</span><span class="special">);</span>
</pre>
<p>
        </p>
<p>
          If the Fallback type is the same as the Target, the template parameter
          Target can be deduced and then omitted as in
        </p>
<p>
          
</p>
<pre class="programlisting"><span class="keyword">int</span> <span class="identifier">t</span> <span class="special">=</span> <span class="identifier">convert_to_or_fallback</span><span class="special">(</span><span class="identifier">str</span><span class="special">,-</span><span class="number">1</span><span class="special">);</span>
<span class="identifier">BOOST_ASSERT</span><span class="special">(</span><span class="identifier">t</span><span class="special">==-</span><span class="number">1</span><span class="special">);</span>
</pre>
<p>
        </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
            The name of this function could be also <code class="computeroutput"><span class="identifier">convert_to</span></code>
            as the library can overload it, but I find it more explicit this way.
            If the Boost community agree on a better name I will adopt it.
          </p></td></tr>
</table></div>
<p>
          <span class="emphasis"><em>See the source file <a href="../../example/fallback.cpp" target="_top">example/fallback.cpp</a></em></span>
        </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost.conversion.users_guide.tutorial.can_extrinsic_conversions_be_applied_implicitly_"></a><a class="link" href="index.html#boost.conversion.users_guide.tutorial.can_extrinsic_conversions_be_applied_implicitly_" title="Can extrinsic conversions be applied implicitly?">Can
        extrinsic conversions be applied implicitly?</a>
</h4></div></div></div>
<p>
          The advertised reader will be asking himself if the library provide implicit
          conversions as the language makes the difference between implicit and explicit
          conversions. The idea is to maintain the extrinsic functions semantics
          as close as possible to the semantics of intrinsic ones. Implicit conversion
          are applied whenever the compiler find that this implicit conversion makes
          the program well formed.
        </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">f</span><span class="special">(</span><span class="keyword">int</span><span class="special">);</span>

<span class="identifier">T</span> <span class="identifier">v</span><span class="special">;</span>
<span class="identifier">f</span><span class="special">(</span><span class="identifier">v</span><span class="special">);</span>
</pre>
<p>
          If there is an implicit conversion from <code class="computeroutput"><span class="identifier">T</span></code>
          to <code class="computeroutput"><span class="keyword">int</span></code>, the preceding program
          will be well formed.
        </p>
<p>
          With extrinsic conversions it is desirable to preserve as much as possible
          this behavior. The problem is that as extrinsic conversions are not in
          the language and the compiler could not find them automatically, so the
          user needs to call explicitly to the extrinsic conversion.
        </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">f</span><span class="special">(</span><span class="keyword">int</span><span class="special">);</span>

<span class="identifier">T</span> <span class="identifier">v</span><span class="special">;</span>
<span class="identifier">f</span><span class="special">(</span><span class="identifier">implicit_convert_to</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;(</span><span class="identifier">v</span><span class="special">));</span>
</pre>
<p>
          Imagine now that <code class="computeroutput"><span class="identifier">f</span></code> is overloaded
        </p>
<p>
          
</p>
<pre class="programlisting"><span class="keyword">int</span> <span class="identifier">f</span><span class="special">(</span><span class="keyword">int</span><span class="special">)</span> <span class="special">{</span> <span class="keyword">return</span> <span class="number">1</span><span class="special">;</span> <span class="special">}</span>
<span class="keyword">int</span> <span class="identifier">f</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="keyword">const</span><span class="special">&amp;)</span> <span class="special">{</span> <span class="keyword">return</span> <span class="number">2</span><span class="special">;</span> <span class="special">}</span>
</pre>
<p>
        </p>
<p>
          and that the user has a function that should work when <code class="computeroutput"><span class="identifier">T</span></code>
          is either implicitly convertible to int or std::string.
        </p>
<p>
          
</p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">ImplTest</span> <span class="special">{</span>
  <span class="keyword">static</span> <span class="keyword">void</span> <span class="identifier">whichOverload</span><span class="special">()</span>
  <span class="special">{</span>
    <span class="identifier">T</span> <span class="identifier">v</span><span class="special">;</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">f</span><span class="special">(</span><span class="identifier">v</span><span class="special">)</span> <span class="special">&lt;&lt;</span> <span class="string">" called"</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
  <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
        </p>
<p>
          If <code class="computeroutput"><span class="identifier">IntrCvtToInt</span></code> is convertible
          to <code class="computeroutput"><span class="keyword">int</span></code> and <code class="computeroutput"><span class="identifier">IntrCvtToString</span></code>
          is convertible to <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></code>, then the following program will
          be well formed.
        </p>
<p>
          
</p>
<pre class="programlisting"><span class="identifier">ImplTest</span><span class="special">&lt;</span><span class="identifier">IntrCvtToInt</span><span class="special">&gt;::</span><span class="identifier">whichOverload</span><span class="special">();</span>
<span class="identifier">ImplTest</span><span class="special">&lt;</span><span class="identifier">IntrCvtToString</span><span class="special">&gt;::</span><span class="identifier">whichOverload</span><span class="special">();</span>
<span class="comment">//ImplTest&lt;IntrCvtINtAndString&gt;::whichOverload(); // compile fail
</span></pre>
<p>
        </p>
<p>
          and will result in
        </p>
<pre class="programlisting"><span class="number">1</span> <span class="identifier">called</span>
<span class="number">2</span> <span class="identifier">called</span>
</pre>
<p>
          But if T is <span class="bold"><strong>extrinsically</strong></span> implicit convertible
          to <code class="computeroutput"><span class="keyword">int</span></code> or <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></code>
          the user can not write a simple program that works as they doesn't know
          to which <code class="computeroutput"><span class="identifier">Target</span></code> the type
          <code class="computeroutput"><span class="identifier">T</span></code> must be converted to.
        </p>
<pre class="programlisting"><span class="identifier">T</span> <span class="identifier">v</span><span class="special">;</span>
<span class="identifier">f</span><span class="special">(</span><span class="identifier">convert_to</span><span class="special">&lt;???&gt;(</span><span class="identifier">v</span><span class="special">));</span>
</pre>
<p>
          So the following fails to compile if <code class="computeroutput"><span class="identifier">ExtrCvtToInt</span></code>
          is extrinsically convertible to <code class="computeroutput"><span class="keyword">int</span></code>
          and <code class="computeroutput"><span class="identifier">ExtrCvtToString</span></code> is
          extrinsically convertible to <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></code>.
        </p>
<p>
          
</p>
<pre class="programlisting"><span class="identifier">ImplTest</span><span class="special">&lt;</span><span class="identifier">ExtrCvtToInt</span><span class="special">&gt;::</span><span class="identifier">whichOverload</span><span class="special">();</span> <span class="comment">// compile fail
</span><span class="identifier">ImplTest</span><span class="special">&lt;</span><span class="identifier">ExtrCvtToString</span><span class="special">&gt;::</span><span class="identifier">whichOverload</span><span class="special">();</span> <span class="comment">// compile fail
</span><span class="identifier">ImplTest</span><span class="special">&lt;</span><span class="identifier">ExtrCvtINtAndString</span><span class="special">&gt;::</span><span class="identifier">whichOverload</span><span class="special">();</span> <span class="comment">// compile fail
</span></pre>
<p>
        </p>
<p>
          Why ADLIt would be great if the user could state explicitly that the parameter
          they are passing to <code class="computeroutput"><span class="identifier">f</span></code> can
          be implicitly convertible to the <code class="computeroutput"><span class="identifier">f</span></code>
          parameter type. The library provides a function <code class="computeroutput"><span class="identifier">implicitly</span></code>
          that makes a wrapper around a type that implicitly converts to any type
          that is extrinsically convertible from its argument.
        </p>
<p>
          
</p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">ImplicitlyTest</span> <span class="special">{</span>
  <span class="keyword">static</span> <span class="keyword">void</span> <span class="identifier">whichOverload</span><span class="special">()</span>
  <span class="special">{</span>
    <span class="identifier">T</span> <span class="identifier">v</span><span class="special">;</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">f</span><span class="special">(</span><span class="identifier">implicitly</span><span class="special">(</span><span class="identifier">v</span><span class="special">))</span> <span class="special">&lt;&lt;</span> <span class="string">" called"</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
  <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
        </p>
<p>
          So the following will be correct and call to the expected <code class="computeroutput"><span class="identifier">f</span></code> overload.
        </p>
<p>
          
</p>
<pre class="programlisting"><span class="identifier">ImplicitlyTest</span><span class="special">&lt;</span><span class="identifier">IntrCvtToInt</span><span class="special">&gt;::</span><span class="identifier">whichOverload</span><span class="special">();</span>
<span class="identifier">ImplicitlyTest</span><span class="special">&lt;</span><span class="identifier">IntrCvtToString</span><span class="special">&gt;::</span><span class="identifier">whichOverload</span><span class="special">();</span>
<span class="identifier">ImplicitlyTest</span><span class="special">&lt;</span><span class="identifier">ExtrCvtToInt</span><span class="special">&gt;::</span><span class="identifier">whichOverload</span><span class="special">();</span>
<span class="identifier">ImplicitlyTest</span><span class="special">&lt;</span><span class="identifier">ExtrCvtToString</span><span class="special">&gt;::</span><span class="identifier">whichOverload</span><span class="special">();</span>
<span class="comment">//ImplicitlyTest&lt;ExtrCvtINtAndString&gt;::whichOverload(); // compile fail
</span></pre>
<p>
        </p>
<p>
          and prints
        </p>
<pre class="programlisting"><span class="number">1</span> <span class="identifier">called</span>
<span class="number">2</span> <span class="identifier">called</span>
<span class="number">1</span> <span class="identifier">called</span>
<span class="number">2</span> <span class="identifier">called</span>
</pre>
<p>
          Note that extrinsically implicit convertible implies extrinsically explicit
          convertible but the opposite is not true. That means that if <code class="computeroutput"><span class="identifier">ExtrExplicitCvtToInt</span></code> is extrinsically
          explicit convertible to <code class="computeroutput"><span class="keyword">int</span></code>,
          the following program will be ill formed
        </p>
<p>
          
</p>
<pre class="programlisting"><span class="identifier">ImplicitlyTest</span><span class="special">&lt;</span><span class="identifier">ExtrExplicitCvtToInt</span><span class="special">&gt;::</span><span class="identifier">whichOverload</span><span class="special">();</span>
</pre>
<p>
        </p>
<p>
          having as result, for example
        </p>
<pre class="programlisting"><span class="special">../</span><span class="identifier">example</span><span class="special">/</span><span class="identifier">overload</span><span class="special">.</span><span class="identifier">cpp</span><span class="special">:</span><span class="number">102</span><span class="special">:</span><span class="number">18</span><span class="special">:</span> <span class="identifier">error</span><span class="special">:</span> <span class="identifier">no</span> <span class="identifier">matching</span> <span class="identifier">function</span> <span class="keyword">for</span> <span class="identifier">call</span> <span class="identifier">to</span> <span class="char">'f'</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">f</span><span class="special">(</span><span class="identifier">implicitly</span><span class="special">(</span><span class="identifier">v</span><span class="special">))</span> <span class="special">&lt;&lt;</span> <span class="string">" called"</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
               <span class="special">^</span>
<span class="special">../</span><span class="identifier">example</span><span class="special">/</span><span class="identifier">overload</span><span class="special">.</span><span class="identifier">cpp</span><span class="special">:</span><span class="number">134</span><span class="special">:</span><span class="number">34</span><span class="special">:</span> <span class="identifier">note</span><span class="special">:</span> <span class="identifier">in</span> <span class="identifier">instantiation</span> <span class="identifier">of</span> <span class="identifier">member</span> <span class="identifier">function</span> <span class="char">'ImplicitTest&lt;ExtrExplicitCvtToInt&gt;::whichOverload'</span> <span class="identifier">requested</span> <span class="identifier">here</span>
  <span class="identifier">ImplicitTest</span><span class="special">&lt;</span><span class="identifier">ExtrExplicitCvtToInt</span><span class="special">&gt;::</span><span class="identifier">whichOverload</span><span class="special">();</span>
                               <span class="special">^</span>
<span class="special">../</span><span class="identifier">example</span><span class="special">/</span><span class="identifier">overload</span><span class="special">.</span><span class="identifier">cpp</span><span class="special">:</span><span class="number">21</span><span class="special">:</span><span class="number">5</span><span class="special">:</span> <span class="identifier">note</span><span class="special">:</span> <span class="identifier">candidate</span> <span class="identifier">function</span> <span class="keyword">not</span> <span class="identifier">viable</span><span class="special">:</span> <span class="identifier">no</span> <span class="identifier">known</span> <span class="identifier">conversion</span> <span class="identifier">from</span> <span class="char">'convertible_from&lt;ExtrExplicitCvtToInt&gt;'</span> <span class="identifier">to</span> <span class="char">'int'</span> <span class="keyword">for</span> <span class="number">1</span><span class="identifier">st</span> <span class="identifier">argument</span>
<span class="keyword">int</span> <span class="identifier">f</span><span class="special">(</span><span class="keyword">int</span><span class="special">)</span> <span class="special">{</span> <span class="keyword">return</span> <span class="number">1</span><span class="special">;</span> <span class="special">}</span>
</pre>
<p>
          <span class="emphasis"><em>See the source file <a href="../../example/overload.cpp" target="_top">example/overload.cpp</a></em></span>
        </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost.conversion.users_guide.tutorial.how_to_write_a_function_that_accepts_a_parameter_that_is_extrinsically_convertible_to_a_given_type_"></a><a class="link" href="index.html#boost.conversion.users_guide.tutorial.how_to_write_a_function_that_accepts_a_parameter_that_is_extrinsically_convertible_to_a_given_type_" title="How to write a function that accepts a parameter that is extrinsically convertible to a given type?">How
        to write a function that accepts a parameter that is extrinsically convertible
        to a given type?</a>
</h4></div></div></div>
<p>
          The use of the helper function <code class="computeroutput"><span class="identifier">implicitly</span></code>
          is a little bit intrusive in some cases. It would be great if the users
          could define a function accepting a type that is extrinsically convertible,
          so the they will not be forced to use it. There are two alternatives:
        </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
              overload the function using SFINAE
            </li>
<li class="listitem">
              change the function prototype
            </li>
</ul></div>
<p>
          If the user had already the function
        </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">f</span><span class="special">(</span><span class="keyword">int</span><span class="special">);</span>
</pre>
<p>
          She can add an overload that will make explicitly the conversion as follows
        </p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">typename</span> <span class="identifier">enable_if</span><span class="special">&lt;</span><span class="identifier">is_extrinsically_convertible</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;,</span><span class="keyword">void</span> <span class="special">&gt;::</span><span class="identifier">type</span> 
<span class="identifier">f</span><span class="special">(</span><span class="identifier">T</span> <span class="identifier">v</span><span class="special">)</span> <span class="special">{</span> <span class="keyword">return</span> <span class="identifier">convert_to</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;(</span><span class="identifier">v</span><span class="special">);</span> <span class="special">}</span>
</pre>
<p>
          This template overload will be taken for overload resolution only if <code class="computeroutput"><span class="identifier">T</span></code> is not <code class="computeroutput"><span class="keyword">int</span></code>
          (as non template functions are preferred to template ones) and <code class="computeroutput"><span class="identifier">T</span></code> is extrinsically convertible to <code class="computeroutput"><span class="keyword">int</span></code>. <code class="computeroutput"><span class="identifier">is_extrinsically_convertible</span></code>
          is a trait added by the library that contains a nested value field that
          is true or false depending on whether the <code class="computeroutput"><span class="identifier">Source</span></code>
          type is extrinsically implicit convertible to <code class="computeroutput"><span class="identifier">Target</span></code>.
        </p>
<p>
          An alternative could be to define the function <code class="computeroutput"><span class="identifier">f</span></code>
          from the beginning stating explicitly that his parameter one that is extrinsically
          convertible to <code class="computeroutput"><span class="keyword">int</span></code>.
        </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">f</span><span class="special">(</span><span class="identifier">convertible_to</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="identifier">v</span><span class="special">);</span>
</pre>
<p>
          The <code class="computeroutput"><span class="identifier">convertible_to</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span></code>
          class is a <code class="computeroutput"><span class="identifier">T</span></code> wrapper that
          is implicitly constructible from any type extrinsically constructible
          <code class="computeroutput"><span class="identifier">T</span></code>. <code class="computeroutput"><span class="identifier">convertible_to</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span></code> is implicitly convertible to <code class="computeroutput"><span class="identifier">T</span></code>. For example, if <code class="computeroutput"><span class="identifier">T</span></code>
          is extrinsically convertible to <code class="computeroutput"><span class="keyword">int</span></code>,
          the following program will be well formed
        </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">f</span><span class="special">(</span><span class="identifier">convertible_to</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="identifier">v</span><span class="special">)</span> 
<span class="special">{</span>
  <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">hex</span> <span class="special">&lt;&lt;</span> <span class="identifier">v</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
<span class="special">}</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span>
<span class="special">{</span>
  <span class="identifier">T</span> <span class="identifier">v</span><span class="special">;</span>
  <span class="identifier">f</span><span class="special">(</span><span class="identifier">v</span><span class="special">)</span>
<span class="special">}</span>
</pre>
<p>
          Unfortunately, <code class="computeroutput"><span class="identifier">convertible_to</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span></code> is not a smart reference to <code class="computeroutput"><span class="identifier">T</span></code>, so any access to its underlying type
          must be done using an explicit call to the <code class="computeroutput"><span class="identifier">get</span></code>
          function.
        </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">f</span><span class="special">(</span><span class="identifier">convertible_to</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">&gt;</span> <span class="identifier">v</span><span class="special">)</span> 
<span class="special">{</span>
  <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">v</span><span class="special">.</span><span class="identifier">get</span><span class="special">().</span><span class="identifier">c_str</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
            While this alternative doesn't seems completely necessary, I wanted to
            add them to the library for the review discussion. It could be removed
            from without any problems.
          </p></td></tr>
</table></div>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost.conversion.users_guide.tutorial.functors"></a><a class="link" href="index.html#boost.conversion.users_guide.tutorial.functors" title="Functors">Functors</a>
</h4></div></div></div>
<p>
          The library provide a specific Phoenix functor factory having as result
          a functor that will call to the <code class="computeroutput"><span class="identifier">convert_to</span></code>
          function lazily.
        </p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">conversion</span><span class="special">/</span><span class="identifier">fp</span><span class="special">/</span><span class="identifier">convert_to</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">array</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">vector</span><span class="special">&gt;</span>

<span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span>            <span class="identifier">integers</span><span class="special">;</span>
<span class="identifier">boost</span><span class="special">::</span><span class="identifier">array</span><span class="special">&lt;</span><span class="keyword">char</span> <span class="keyword">const</span><span class="special">*,</span> <span class="number">5</span><span class="special">&gt;</span> <span class="identifier">strings</span> <span class="special">=</span> <span class="special">{{</span> <span class="string">"15"</span><span class="special">,</span> <span class="string">"16"</span><span class="special">,</span> <span class="string">"17"</span><span class="special">,</span> <span class="string">"18"</span><span class="special">}};</span>

<span class="comment">// With fallback value provided. No throwing.
</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">transform</span><span class="special">(</span>
    <span class="identifier">strings</span><span class="special">.</span><span class="identifier">begin</span><span class="special">(),</span>
    <span class="identifier">strings</span><span class="special">.</span><span class="identifier">end</span><span class="special">(),</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">back_inserter</span><span class="special">(</span><span class="identifier">integers</span><span class="special">),</span>
    <span class="identifier">convert_to</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;(</span><span class="identifier">_1</span><span class="special">)</span>
<span class="special">);</span>

<span class="identifier">BOOST_ASSERT</span><span class="special">(</span><span class="identifier">integers</span><span class="special">[</span><span class="number">0</span><span class="special">]</span> <span class="special">==</span> <span class="number">15</span><span class="special">);</span>
<span class="identifier">BOOST_ASSERT</span><span class="special">(</span><span class="identifier">integers</span><span class="special">[</span><span class="number">1</span><span class="special">]</span> <span class="special">==</span> <span class="number">16</span><span class="special">);</span>
<span class="identifier">BOOST_ASSERT</span><span class="special">(</span><span class="identifier">integers</span><span class="special">[</span><span class="number">2</span><span class="special">]</span> <span class="special">==</span> <span class="number">17</span><span class="special">);</span>
<span class="identifier">BOOST_ASSERT</span><span class="special">(</span><span class="identifier">integers</span><span class="special">[</span><span class="number">3</span><span class="special">]</span> <span class="special">==</span> <span class="number">18</span><span class="special">);</span>
</pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost.conversion.users_guide.tutorial.usage_of___implicit_convert_to____explicit_convert_to_or___assign_to"></a><a class="link" href="index.html#boost.conversion.users_guide.tutorial.usage_of___implicit_convert_to____explicit_convert_to_or___assign_to" title="Usage of implicit_convert_to, explicit_convert_to or assign_to">Usage
        of <code class="computeroutput"><span class="identifier">implicit_convert_to</span></code>,
        <code class="computeroutput"><span class="identifier">explicit_convert_to</span></code> or <code class="computeroutput"><span class="identifier">assign_to</span></code></a>
</h4></div></div></div>
<p>
          The users should use <code class="computeroutput"><span class="identifier">assign_to</span></code>
          whenever they had used operator=(), that is, when there is already a target
          variable.
        </p>
<p>
          The users should use the conversion forms <code class="computeroutput"><span class="identifier">implicit_convert_to</span></code>,
          <code class="computeroutput"><span class="identifier">explicit_convert_to</span></code> whenever
          they had used the conversion operator Target(), either implicit or explicitly.
        </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost.conversion.users_guide.tutorial.how_to_specialize_extrinsic_conversions_"></a><a class="link" href="index.html#boost.conversion.users_guide.tutorial.how_to_specialize_extrinsic_conversions_" title="How to specialize extrinsic conversions?">How
        to specialize extrinsic conversions?</a>
</h4></div></div></div>
<p>
          <span class="bold"><strong>Boost.Conversion</strong></span> has two customization
          point for each one of the provided functions:
        </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
              specializing the associated customization functor
            </li>
<li class="listitem">
              overloading a variant of the function to customize
            </li>
</ul></div>
<p>
          For example, to customize the <code class="computeroutput"><span class="identifier">implicit_convert_to</span></code>
          function you could partially specialize the functor <code class="computeroutput"><span class="identifier">implicit_converter_cp</span></code>.
        </p>
<pre class="programlisting"><span class="keyword">namespace</span>  <span class="identifier">boost</span> <span class="special">{</span> 
  <span class="keyword">namespace</span> <span class="identifier">conversion</span> <span class="special">{</span>
    <span class="keyword">template</span> <span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Target</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Source</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Enable</span><span class="special">=</span><span class="keyword">void</span> <span class="special">&gt;</span>
    <span class="keyword">struct</span> <span class="identifier">implicit_converter_cp</span> <span class="special">:</span> <span class="identifier">true_type</span> <span class="special">{</span>
      <span class="identifier">Target</span> <span class="keyword">operator</span><span class="special">()(</span><span class="keyword">const</span> <span class="identifier">Source</span><span class="special">&amp;</span> <span class="identifier">val</span><span class="special">)</span>
    <span class="special">};</span>
  <span class="special">}</span>
<span class="special">}</span>
</pre>
<p>
          A possible specialization for <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span></code>
          follows:
        </p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Target1</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Target2</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Source1</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Source2</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">implicit_convert_cp</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&lt;</span><span class="identifier">Target1</span><span class="special">,</span><span class="identifier">Target2</span><span class="special">&gt;,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&lt;</span><span class="identifier">Source1</span><span class="special">,</span><span class="identifier">Source2</span><span class="special">&gt;</span> 
  <span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">enable_if_c</span><span class="special">&lt;</span>
        <span class="identifier">is_extrinsically_convertible</span><span class="special">&lt;</span><span class="identifier">Source1</span><span class="special">,</span> <span class="identifier">Target1</span><span class="special">&gt;::</span><span class="identifier">value</span>
    <span class="special">&amp;&amp;</span> <span class="identifier">is_extrinsically_convertible</span><span class="special">&lt;</span><span class="identifier">Source2</span><span class="special">,</span> <span class="identifier">Target2</span><span class="special">&gt;::</span><span class="identifier">value</span>
  <span class="special">&gt;::</span><span class="identifier">type</span>
<span class="special">&gt;</span> <span class="special">:</span> <span class="identifier">true_type</span>
<span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&lt;</span><span class="identifier">Target1</span><span class="special">,</span><span class="identifier">Target2</span><span class="special">&gt;</span> <span class="keyword">operator</span><span class="special">()(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&lt;</span><span class="identifier">Source1</span><span class="special">,</span><span class="identifier">Source2</span><span class="special">&gt;&amp;</span> <span class="identifier">v</span><span class="special">)</span> 
    <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&lt;</span><span class="identifier">T1</span><span class="special">,</span><span class="identifier">T2</span><span class="special">&gt;(</span><span class="identifier">implicit_convert_to</span><span class="special">&lt;</span><span class="identifier">T1</span><span class="special">&gt;(</span><span class="identifier">from</span><span class="special">.</span><span class="identifier">first</span><span class="special">),</span> <span class="identifier">implicit_convert_to</span><span class="special">&lt;</span><span class="identifier">T2</span><span class="special">&gt;(</span><span class="identifier">from</span><span class="special">.</span><span class="identifier">second</span><span class="special">));</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
          Note that the <code class="computeroutput"><span class="identifier">implicit_converter_cp</span></code>
          specialization inherits from <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">true_type</span></code>.
          This is needed as used by the <code class="computeroutput"><span class="identifier">is_extrinsically_convertible</span></code>
          type trait.
        </p>
<p>
          Note also the use of the <code class="computeroutput"><span class="identifier">Enable</span></code>
          parameter to constraint the specialization to the enable types using the
          <code class="computeroutput"><span class="identifier">enable_if</span></code> family functions.
        </p>
<p>
          An alternative customization point is to overload a variant of the conversion
          to specialize that adds a dummy parameter that can covey the return type
          when needed.
        </p>
<p>
          For example the <code class="computeroutput"><span class="identifier">explicit_convert_to</span></code>
          function can be specialized by overloading the function
        </p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Target</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Source</span><span class="special">&gt;</span>
<span class="identifier">Target</span> <span class="identifier">explicit_convert_to</span><span class="special">(</span><span class="identifier">Source</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">from</span><span class="special">,</span> <span class="identifier">dummy</span><span class="special">::</span><span class="identifier">type_tag</span><span class="special">&lt;</span><span class="identifier">Target</span><span class="special">&gt;</span> <span class="keyword">const</span><span class="special">&amp;);</span>
</pre>
<p>
          This is particular useful when we want explicit conversion on compilers
          that don't support explicit conversion operators. For example the Boost.Opaque
          library define a mixing to add explicit conversion to a specific type as
          follows:
        </p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">using_explicit_conversion_to</span> <span class="special">{</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Final</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Base</span><span class="special">&gt;</span>
    <span class="keyword">struct</span> <span class="identifier">type</span><span class="special">:</span> <span class="identifier">Base</span> <span class="special">{</span>
<span class="preprocessor">#     if</span> <span class="special">!</span> <span class="identifier">defined</span> <span class="identifier">BOOST_NO_EXPLICIT_CONVERSION_OPERATORS</span>
        <span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="identifier">T</span><span class="special">()</span> <span class="keyword">const</span>
        <span class="special">{</span>
          <span class="keyword">return</span> <span class="identifier">T</span><span class="special">(</span><span class="identifier">Final</span><span class="special">::</span><span class="identifier">underlying</span><span class="special">(</span><span class="keyword">this</span><span class="special">));</span>
        <span class="special">}</span>
<span class="preprocessor">#     endif</span>
        <span class="keyword">friend</span> <span class="identifier">T</span> <span class="identifier">explicit_convert_to</span><span class="special">(</span><span class="identifier">Final</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">rhs</span><span class="special">,</span>
            <span class="identifier">boost</span><span class="special">::</span><span class="identifier">conversion</span><span class="special">::</span><span class="identifier">dummy</span><span class="special">::</span><span class="identifier">type_tag</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span> <span class="keyword">const</span><span class="special">&amp;)</span>
        <span class="special">{</span>
          <span class="keyword">return</span> <span class="identifier">T</span><span class="special">(</span><span class="identifier">Final</span><span class="special">::</span><span class="identifier">underlying</span><span class="special">(</span><span class="identifier">rhs</span><span class="special">));</span>
        <span class="special">}</span>
    <span class="special">};</span>
<span class="special">};</span>
</pre>
<p>
          While the <code class="computeroutput"><span class="keyword">explicit</span> <span class="keyword">operator</span>
          <span class="identifier">T</span><span class="special">()</span>
          <span class="keyword">const</span><span class="special">;</span></code>
          can be defined only on compilers supporting explicit conversion operators,
          the <code class="computeroutput"><span class="identifier">explicit_convert_to</span></code>
          variant can be overloaded on most of the compilers, providing a portable
          solution.
        </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost.conversion.users_guide.tutorial.what_to_do_when_the_compiler_doesn_t_supports_the_definition_of_the_needed_type_traits_"></a><a class="link" href="index.html#boost.conversion.users_guide.tutorial.what_to_do_when_the_compiler_doesn_t_supports_the_definition_of_the_needed_type_traits_" title="What to do when the compiler doesn't supports the definition of the needed type traits?">What
        to do when the compiler doesn't supports the definition of the needed type
        traits?</a>
</h4></div></div></div>
<p>
          When the compiler doesn't supports the definition of some of the type traits,
          the library doesn't work as the user could expect. For each trait the library
          provides a macro that states if the library can define correctly the type
          trait. For example, BOOST_CONVERSION_NO_IS_ASSIGNABLE. In this case the
          user needs to specialize the type trait explicitly as follows:
        </p>
<pre class="programlisting"><span class="preprocessor">#if</span> <span class="identifier">defined</span> <span class="identifier">BOOST_CONVERSION_NO_IS_ASSIGNABLE</span>
<span class="keyword">namespace</span> <span class="identifier">boost</span>
<span class="special">{</span>
  <span class="keyword">template</span> <span class="special">&lt;&gt;</span> <span class="keyword">struct</span> <span class="identifier">is_assignable</span><span class="special">&lt;</span> <span class="identifier">X</span><span class="special">&amp;,</span> <span class="identifier">X</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="special">&gt;</span>  <span class="special">:</span> <span class="identifier">true_type</span> <span class="special">{};</span>
<span class="special">}</span>
<span class="preprocessor">#endif</span> 
</pre>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title">
<a name="boost.conversion.users_guide.examples"></a><a class="link" href="index.html#boost.conversion.users_guide.examples" title="Examples">Examples</a>
</h3></div></div></div></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost.conversion.users_guide.ext_references"></a><a class="link" href="index.html#boost.conversion.users_guide.ext_references" title="External Resources">External
      Resources</a>
</h3></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term"><a href="http://www.boostpro.com/vault/index.php?action=downloadfile&amp;filename=boost-string-convert.zip&amp;directory=&amp;" target="_top"><span class="bold"><strong>Boost.Convert</strong></span></a></span></dt>
<dd><p>
              Vladimir Batov. Not yet reviewed
            </p></dd>
<dt><span class="term"><a href="http://www.boost.org/libs/conversion/lexical_cast.htm" target="_top"><span class="bold"><strong>Boost.Conversion.LexicalCast</strong></span></a></span></dt>
<dd><p>
              general literal text conversions, such as an int represented as a string,
              or vice-versa from Kevlin Henney
            </p></dd>
<dt><span class="term"><a href="http://www.boost.org/libs/numeric/conversion" target="_top"><span class="bold"><strong>Boost.NumericConversion</strong></span></a></span></dt>
<dd><p>
              Optimized Policy-based Numeric Conversions from Fernando Cacciola.
            </p></dd>
<dt><span class="term"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2380.pdf" target="_top"><span class="bold"><strong>N2380 - Explicit Conversion Operator Draft Working Paper (revision
          2)</strong></span></a></span></dt>
<dd><p>
              Lois Goldthwaite, Michael Wong, Jens Mauer, Alisdair Meredith.
            </p></dd>
<dt><span class="term"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2200.pdf" target="_top"><span class="bold"><strong>N2200 - Operator Overloading</strong></span></a></span></dt>
<dd><p>
              Gary Powell, Doug Gregor, Jaakko Jarvi.
            </p></dd>
<dt><span class="term"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1671.pdf" target="_top"><span class="bold"><strong>N1671 - Overloading operator.() &amp; operator.*()</strong></span></a></span></dt>
<dd><p>
              Gary Powell, Doug Gregor, Jaakko Jarvi.
            </p></dd>
<dt><span class="term"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1676.htm" target="_top"><span class="bold"><strong>N1676 - Non-member overloaded copy assignment operator</strong></span></a></span></dt>
<dd><p>
              Bronek Kozicki.
            </p></dd>
<dt><span class="term"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1694.html" target="_top"><span class="bold"><strong>N1694 - A Proposal to Extend the Function Call Operator</strong></span></a></span></dt>
<dd><p>
              Bronek Kozicki.
            </p></dd>
<dt><span class="term"><a href="http://www.open-std.org/jtc1/sc22/wg21/prot/14882fdis/n3291.pdf" target="_top"><span class="bold"><strong>N3291 - Working Draft, Standard for Programming Language C++</strong></span></a></span></dt>
<dd></dd>
<dt><span class="term"><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3047.html" target="_top"><span class="bold"><strong>N3047 - Fixing is_constructible and is_explicitly_convertible</strong></span></a></span></dt>
<dd><p>
              Daniel Krugler
            </p></dd>
</dl>
</div>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="boost.conversion.reference"></a><a class="link" href="index.html#boost.conversion.reference" title="Reference">Reference</a>
</h2></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="index.html#boost.conversion.reference.type_traits_extensions">Type
      Traits Extensions</a></span></dt>
<dd><dl>
<dt><span class="section"><a href="index.html#standard_type_traits">Standard Type Traits</a></span></dt>
<dt><span class="section"><a href="index.html#c___standard_specializations_workarounds">C++ Standard specializations workarounds</a></span></dt>
<dt><span class="section"><a href="index.html#boost_specializations_workarounds">Boost specializations workarounds</a></span></dt>
</dl></dd>
<dt><span class="section"><a href="index.html#core">Core</a></span></dt>
<dd><dl>
<dt><span class="section"><a href="index.html#header.boost.conversion_hpp">Header &lt;boost/conversion.hpp&gt;</a></span></dt>
<dt><span class="section"><a href="index.html#header.boost.conversion.assign_to_hpp">Header &lt;boost/conversion/assign_to.hpp&gt;</a></span></dt>
<dt><span class="section"><a href="index.html#header.boost.conversion.assignable_to_hpp">Header &lt;boost/conversion/assignable_to.hpp&gt;</a></span></dt>
<dt><span class="section"><a href="index.html#header.boost.conversion.convert_to_hpp">Header &lt;boost/conversion/convert_to.hpp&gt;</a></span></dt>
<dt><span class="section"><a href="index.html#header.boost.conversion.fp.convert_to_hpp">Header &lt;boost/conversion/fp/convert_to.hpp&gt;</a></span></dt>
<dt><span class="section"><a href="index.html#header.boost.conversion.convert_to_or_fallback_hpp">Header &lt;boost/conversion/convert_to_or_fallback.hpp&gt;</a></span></dt>
<dt><span class="section"><a href="index.html#header.boost.conversion.convertible_from_hpp">Header &lt;boost/conversion/convertible_from.hpp&gt;</a></span></dt>
<dt><span class="section"><a href="index.html#header.boost.conversion.convertible_to_hpp">Header &lt;boost/conversion/convertible_to.hpp&gt;</a></span></dt>
<dt><span class="section"><a href="index.html#header.boost.conversion.explicit_convert_to_hpp">Header &lt;boost/conversion/explicit_convert_to.hpp&gt;</a></span></dt>
<dt><span class="section"><a href="index.html#header.boost.conversion.implicit_convert_to_hpp">Header &lt;boost/conversion/implicit_convert_to.hpp&gt;</a></span></dt>
<dt><span class="section"><a href="index.html#header.boost.conversion.include_hpp">Header &lt;boost/conversion/include.hpp&gt;</a></span></dt>
<dt><span class="section"><a href="index.html#header.boost.conversion.is_extrinsically_assignable_hpp">Header &lt;boost/conversion/is_extrinsically_assignable.hpp&gt;</a></span></dt>
<dt><span class="section"><a href="index.html#header.boost.conversion.is_extrinsically_convertible_hpp">Header &lt;boost/conversion/is_extrinsically_convertible.hpp&gt;</a></span></dt>
<dt><span class="section"><a href="index.html#header.boost.conversion.is_extrinsically_explicit_convertible_hpp">Header &lt;boost/conversion/is_extrinsically_explicit_convertible.hpp&gt;</a></span></dt>
<dt><span class="section"><a href="index.html#header.boost.conversion.try_assign_to_hpp">Header &lt;boost/conversion/try_assign_to.hpp&gt;</a></span></dt>
<dt><span class="section"><a href="index.html#header.boost.conversion.try_convert_to_hpp">Header &lt;boost/conversion/try_convert_to.hpp&gt;</a></span></dt>
</dl></dd>
<dt><span class="section"><a href="index.html#c___standard_classes_specializations">C++ Standard classes specializations</a></span></dt>
<dd><dl>
<dt><span class="section"><a href="index.html#header.boost.conversion.std.pair_hpp">Header &lt;boost/conversion/std/pair.hpp&gt;</a></span></dt>
<dt><span class="section"><a href="index.html#header.boost.conversion.std.string_hpp">Header &lt;boost/conversion/std/string.hpp&gt;</a></span></dt>
<dt><span class="section"><a href="index.html#header.boost.conversion.std.vector_hpp">Header &lt;boost/conversion/std/vector.hpp&gt;</a></span></dt>
</dl></dd>
<dt><span class="section"><a href="index.html#boost_classes_specializations">Boost classes specializations</a></span></dt>
<dd><dl>
<dt><span class="section"><a href="index.html#header.boost.conversion.boost.array_hpp">Header &lt;boost/conversion/boost/array.hpp&gt;</a></span></dt>
<dt><span class="section"><a href="index.html#header.boost.conversion.boost.chrono_duration_to_posix_time_duration_hpp">Header &lt;boost/conversion/boost/chrono_duration_to_posix_time_duration.hpp&gt;</a></span></dt>
<dt><span class="section"><a href="index.html#header.boost.conversion.boost.chrono_posix_time_hpp">Header &lt;boost/conversion/boost/chrono_posix_time.hpp&gt;</a></span></dt>
<dt><span class="section"><a href="index.html#header.boost.conversion.boost.chrono_time_point_to_posix_time_ptime_hpp">Header &lt;boost/conversion/boost/chrono_time_point_to_posix_time_ptime.hpp&gt;</a></span></dt>
<dt><span class="section"><a href="index.html#header.boost.conversion.boost.interval_hpp">Header &lt;boost/conversion/boost/interval.hpp&gt;</a></span></dt>
<dt><span class="section"><a href="index.html#header.boost.conversion.boost.optional_hpp">Header &lt;boost/conversion/boost/optional.hpp&gt;</a></span></dt>
<dt><span class="section"><a href="index.html#header.boost.conversion.boost.rational_hpp">Header &lt;boost/conversion/boost/rational.hpp&gt;</a></span></dt>
<dt><span class="section"><a href="index.html#header.boost.conversion.boost.tuple_hpp">Header &lt;boost/conversion/boost/tuple.hpp&gt;</a></span></dt>
</dl></dd>
</dl></div>
<p>
      This reference consists of several sections:
    </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
          Type Traits Extensions defines some standard type traits that are missing
          to <span class="bold"><strong>Boost.TypeTraits</strong></span>.
        </li></ul></div>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
        The intent is to move this section to the to the <span class="bold"><strong>Boost.TypeTraits</strong></span>
        library. See <a href="http://www.open-std.org/jtc1/sc22/wg21/prot/14882fdis/n3291.pdf" target="_top"><span class="bold"><strong>N3291 - Working Draft, Standard for Programming Language C++</strong></span></a>
        20.9.4.3 Type properties.
      </p></td></tr>
</table></div>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
          Core: Contains the core features of the library
        </li>
<li class="listitem">
          C++ Standard classes specializations: Contains specializations for some
          of the C++ standard types. Files in this section are not included by the
          &lt;boost/conversion.hpp&gt; file and must be included explicitly when
          needed.
        </li>
<li class="listitem">
          Boost classes specializations: Contains specializations for some of the
          C++ standard types. Files in this section are not included by the &lt;boost/conversion.hpp&gt;
          file and must be included explicitly when needed.
        </li>
</ul></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost.conversion.reference.type_traits_extensions"></a><a class="link" href="index.html#boost.conversion.reference.type_traits_extensions" title="Type Traits Extensions">Type
      Traits Extensions</a>
</h3></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="index.html#standard_type_traits">Standard Type Traits</a></span></dt>
<dd><dl>
<dt><span class="section"><a href="index.html#header.boost.conversion.type_traits.is_assignable_hpp">Header &lt;boost/conversion/type_traits/is_assignable.hpp&gt;</a></span></dt>
<dt><span class="section"><a href="index.html#header.boost.conversion.type_traits.is_constructible_hpp">Header &lt;boost/conversion/type_traits/is_constructible.hpp&gt;</a></span></dt>
<dt><span class="section"><a href="index.html#header.boost.conversion.type_traits.is_convertible_hpp">Header &lt;boost/conversion/type_traits/is_convertible.hpp&gt;</a></span></dt>
<dt><span class="section"><a href="index.html#header.boost.conversion.type_traits.is_copy_assignable_hpp">Header &lt;boost/conversion/type_traits/is_copy_assignable.hpp&gt;</a></span></dt>
<dt><span class="section"><a href="index.html#header.boost.conversion.type_traits.is_copy_constructible_hpp">Header &lt;boost/conversion/type_traits/is_copy_constructible.hpp&gt;</a></span></dt>
<dt><span class="section"><a href="index.html#header.boost.conversion.type_traits.is_default_constructible_hpp">Header &lt;boost/conversion/type_traits/is_default_constructible.hpp&gt;</a></span></dt>
<dt><span class="section"><a href="index.html#header.boost.conversion.type_traits.is_destructible_hpp">Header &lt;boost/conversion/type_traits/is_destructible.hpp&gt;</a></span></dt>
<dt><span class="section"><a href="index.html#header.boost.conversion.type_traits.is_explicitly_convertible_hpp">Header &lt;boost/conversion/type_traits/is_explicitly_convertible.hpp&gt;</a></span></dt>
<dt><span class="section"><a href="index.html#header.boost.conversion.type_traits.is_move_assignable_hpp">Header &lt;boost/conversion/type_traits/is_move_assignable.hpp&gt;</a></span></dt>
<dt><span class="section"><a href="index.html#header.boost.conversion.type_traits.is_move_constructible_hpp">Header &lt;boost/conversion/type_traits/is_move_constructible.hpp&gt;</a></span></dt>
</dl></dd>
<dt><span class="section"><a href="index.html#c___standard_specializations_workarounds">C++ Standard specializations workarounds</a></span></dt>
<dd><dl>
<dt><span class="section"><a href="index.html#header.boost.conversion.type_traits.std.complex_hpp">Header &lt;boost/conversion/type_traits/std/complex.hpp&gt;</a></span></dt>
<dt><span class="section"><a href="index.html#header.boost.conversion.type_traits.std.string_hpp">Header &lt;boost/conversion/type_traits/std/string.hpp&gt;</a></span></dt>
<dt><span class="section"><a href="index.html#header.boost.conversion.type_traits.std.utility_hpp">Header &lt;boost/conversion/type_traits/std/utility.hpp&gt;</a></span></dt>
<dt><span class="section"><a href="index.html#header.boost.conversion.type_traits.std.vector_hpp">Header &lt;boost/conversion/type_traits/std/vector.hpp&gt;</a></span></dt>
</dl></dd>
<dt><span class="section"><a href="index.html#boost_specializations_workarounds">Boost specializations workarounds</a></span></dt>
<dd><dl>
<dt><span class="section"><a href="index.html#header.boost.conversion.type_traits.boost.array_hpp">Header &lt;boost/conversion/type_traits/boost/array.hpp&gt;</a></span></dt>
<dt><span class="section"><a href="index.html#header.boost.conversion.type_traits.boost.chrono.duration_hpp">Header &lt;boost/conversion/type_traits/boost/chrono/duration.hpp&gt;</a></span></dt>
<dt><span class="section"><a href="index.html#header.boost.conversion.type_traits.boost.chrono.time_point_hpp">Header &lt;boost/conversion/type_traits/boost/chrono/time_point.hpp&gt;</a></span></dt>
<dt><span class="section"><a href="index.html#header.boost.conversion.type_traits.boost.fusion.tuple_hpp">Header &lt;boost/conversion/type_traits/boost/fusion/tuple.hpp&gt;</a></span></dt>
<dt><span class="section"><a href="index.html#header.boost.conversion.type_traits.boost.numeric.interval_hpp">Header &lt;boost/conversion/type_traits/boost/numeric/interval.hpp&gt;</a></span></dt>
<dt><span class="section"><a href="index.html#header.boost.conversion.type_traits.boost.optional_hpp">Header &lt;boost/conversion/type_traits/boost/optional.hpp&gt;</a></span></dt>
<dt><span class="section"><a href="index.html#header.boost.conversion.type_traits.boost.rational_hpp">Header &lt;boost/conversion/type_traits/boost/rational.hpp&gt;</a></span></dt>
</dl></dd>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="standard_type_traits"></a>Standard Type Traits</h4></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="index.html#header.boost.conversion.type_traits.is_assignable_hpp">Header &lt;boost/conversion/type_traits/is_assignable.hpp&gt;</a></span></dt>
<dt><span class="section"><a href="index.html#header.boost.conversion.type_traits.is_constructible_hpp">Header &lt;boost/conversion/type_traits/is_constructible.hpp&gt;</a></span></dt>
<dt><span class="section"><a href="index.html#header.boost.conversion.type_traits.is_convertible_hpp">Header &lt;boost/conversion/type_traits/is_convertible.hpp&gt;</a></span></dt>
<dt><span class="section"><a href="index.html#header.boost.conversion.type_traits.is_copy_assignable_hpp">Header &lt;boost/conversion/type_traits/is_copy_assignable.hpp&gt;</a></span></dt>
<dt><span class="section"><a href="index.html#header.boost.conversion.type_traits.is_copy_constructible_hpp">Header &lt;boost/conversion/type_traits/is_copy_constructible.hpp&gt;</a></span></dt>
<dt><span class="section"><a href="index.html#header.boost.conversion.type_traits.is_default_constructible_hpp">Header &lt;boost/conversion/type_traits/is_default_constructible.hpp&gt;</a></span></dt>
<dt><span class="section"><a href="index.html#header.boost.conversion.type_traits.is_destructible_hpp">Header &lt;boost/conversion/type_traits/is_destructible.hpp&gt;</a></span></dt>
<dt><span class="section"><a href="index.html#header.boost.conversion.type_traits.is_explicitly_convertible_hpp">Header &lt;boost/conversion/type_traits/is_explicitly_convertible.hpp&gt;</a></span></dt>
<dt><span class="section"><a href="index.html#header.boost.conversion.type_traits.is_move_assignable_hpp">Header &lt;boost/conversion/type_traits/is_move_assignable.hpp&gt;</a></span></dt>
<dt><span class="section"><a href="index.html#header.boost.conversion.type_traits.is_move_constructible_hpp">Header &lt;boost/conversion/type_traits/is_move_constructible.hpp&gt;</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="header.boost.conversion.type_traits.is_assignable_hpp"></a>Header &lt;<a href="../../../../boost/conversion/type_traits/is_assignable.hpp" target="_top">boost/conversion/type_traits/is_assignable.hpp</a>&gt;</h5></div></div></div>
<p>Defines the type trait <code class="computeroutput">is_assignable</code>. </p>
<pre class="synopsis">

<a class="link" href="BOOST_CONVERSION_NO_IS_ASSIGNABLE.html" title="Macro BOOST_CONVERSION_NO_IS_ASSIGNABLE">BOOST_CONVERSION_NO_IS_ASSIGNABLE</a></pre>
<pre class="synopsis"><span class="keyword">namespace</span> <span class="identifier">boost</span> <span class="special">{</span>
  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> Target<span class="special">,</span> <span class="keyword">typename</span> Source<span class="special">&gt;</span> <span class="keyword">struct</span> <a class="link" href="boost/is_assignable.html" title="Struct template is_assignable">is_assignable</a><span class="special">;</span>
<span class="special">}</span></pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="header.boost.conversion.type_traits.is_constructible_hpp"></a>Header &lt;<a href="../../../../boost/conversion/type_traits/is_constructible.hpp" target="_top">boost/conversion/type_traits/is_constructible.hpp</a>&gt;</h5></div></div></div>
<p>Defines the type trait <code class="computeroutput">is_constructible</code>. </p>
<pre class="synopsis">

<a class="link" href="BOOST_CONVERSION_NO_IS_CONSTRUCTIBLE.html" title="Macro BOOST_CONVERSION_NO_IS_CONSTRUCTIBLE">BOOST_CONVERSION_NO_IS_CONSTRUCTIBLE</a>
<a class="link" href="BOOST_CONVERSION_NO_IS_DEFAULT_CONSTRUCTIBLE.html" title="Macro BOOST_CONVERSION_NO_IS_DEFAULT_CONSTRUCTIBLE">BOOST_CONVERSION_NO_IS_DEFAULT_CONSTRUCTIBLE</a>
<a class="link" href="BOOST_CONVERSION_TT_IS_CONSTRUCTIBLE_ARITY_MAX.html" title="Macro BOOST_CONVERSION_TT_IS_CONSTRUCTIBLE_ARITY_MAX">BOOST_CONVERSION_TT_IS_CONSTRUCTIBLE_ARITY_MAX</a></pre>
<pre class="synopsis"><span class="keyword">namespace</span> <span class="identifier">boost</span> <span class="special">{</span>
  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> T<span class="special">,</span> <span class="keyword">typename</span><span class="special">...</span> Args<span class="special">&gt;</span> <span class="keyword">struct</span> <a class="link" href="boost/is_constructible.html" title="Struct template is_constructible">is_constructible</a><span class="special">;</span>
<span class="special">}</span></pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="header.boost.conversion.type_traits.is_convertible_hpp"></a>Header &lt;<a href="../../../../boost/conversion/type_traits/is_convertible.hpp" target="_top">boost/conversion/type_traits/is_convertible.hpp</a>&gt;</h5></div></div></div>
<p>Include this file to workaround some failures on the Boost.TypeTraits <code class="computeroutput">is_convertible</code>. </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="header.boost.conversion.type_traits.is_copy_assignable_hpp"></a>Header &lt;<a href="../../../../boost/conversion/type_traits/is_copy_assignable.hpp" target="_top">boost/conversion/type_traits/is_copy_assignable.hpp</a>&gt;</h5></div></div></div>
<p>Defines the type trait <code class="computeroutput">is_copy_assignable</code>. </p>
<pre class="synopsis"><span class="keyword">namespace</span> <span class="identifier">boost</span> <span class="special">{</span>
  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> T<span class="special">&gt;</span> <span class="keyword">struct</span> <a class="link" href="boost/is_copy_assignable.html" title="Struct template is_copy_assignable">is_copy_assignable</a><span class="special">;</span>
<span class="special">}</span></pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="header.boost.conversion.type_traits.is_copy_constructible_hpp"></a>Header &lt;<a href="../../../../boost/conversion/type_traits/is_copy_constructible.hpp" target="_top">boost/conversion/type_traits/is_copy_constructible.hpp</a>&gt;</h5></div></div></div>
<p>Defines the type trait <code class="computeroutput">is_copy_constructible</code>. </p>
<pre class="synopsis"><span class="keyword">namespace</span> <span class="identifier">boost</span> <span class="special">{</span>
  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> T<span class="special">&gt;</span> <span class="keyword">struct</span> <a class="link" href="boost/is_copy_constructible.html" title="Struct template is_copy_constructible">is_copy_constructible</a><span class="special">;</span>
<span class="special">}</span></pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="header.boost.conversion.type_traits.is_default_constructible_hpp"></a>Header &lt;<a href="../../../../boost/conversion/type_traits/is_default_constructible.hpp" target="_top">boost/conversion/type_traits/is_default_constructible.hpp</a>&gt;</h5></div></div></div>
<p>Defines the type trait <code class="computeroutput">is_default_constructible</code>. </p>
<pre class="synopsis"><span class="keyword">namespace</span> <span class="identifier">boost</span> <span class="special">{</span>
  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> T<span class="special">&gt;</span> <span class="keyword">struct</span> <a class="link" href="boost/is_default_constructible.html" title="Struct template is_default_constructible">is_default_constructible</a><span class="special">;</span>
<span class="special">}</span></pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="header.boost.conversion.type_traits.is_destructible_hpp"></a>Header &lt;<a href="../../../../boost/conversion/type_traits/is_destructible.hpp" target="_top">boost/conversion/type_traits/is_destructible.hpp</a>&gt;</h5></div></div></div>
<p>Defines the type trait <code class="computeroutput">is_destructible</code>. </p>
<pre class="synopsis">

<a class="link" href="BOOST_CONVERSION_NO_IS_DESTRUCTIBLE.html" title="Macro BOOST_CONVERSION_NO_IS_DESTRUCTIBLE">BOOST_CONVERSION_NO_IS_DESTRUCTIBLE</a></pre>
<pre class="synopsis"><span class="keyword">namespace</span> <span class="identifier">boost</span> <span class="special">{</span>
  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> T<span class="special">&gt;</span> <span class="keyword">struct</span> <a class="link" href="boost/is_destructible.html" title="Struct template is_destructible">is_destructible</a><span class="special">;</span>
<span class="special">}</span></pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="header.boost.conversion.type_traits.is_explicitly_convertible_hpp"></a>Header &lt;<a href="../../../../boost/conversion/type_traits/is_explicitly_convertible.hpp" target="_top">boost/conversion/type_traits/is_explicitly_convertible.hpp</a>&gt;</h5></div></div></div>
<p>Defines the type trait <code class="computeroutput">is_explicitly_convertible</code>. </p>
<pre class="synopsis">

<a class="link" href="BOOST_CONVERSION_NO_IS_EXPLICIT_CONVERTIBLE.html" title="Macro BOOST_CONVERSION_NO_IS_EXPLICIT_CONVERTIBLE">BOOST_CONVERSION_NO_IS_EXPLICIT_CONVERTIBLE</a></pre>
<pre class="synopsis"><span class="keyword">namespace</span> <span class="identifier">boost</span> <span class="special">{</span>
  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> Source<span class="special">,</span> <span class="keyword">typename</span> Target<span class="special">&gt;</span> <span class="keyword">struct</span> <a class="link" href="boost/is_explicitly_convertible.html" title="Struct template is_explicitly_convertible">is_explicitly_convertible</a><span class="special">;</span>
<span class="special">}</span></pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="header.boost.conversion.type_traits.is_move_assignable_hpp"></a>Header &lt;<a href="../../../../boost/conversion/type_traits/is_move_assignable.hpp" target="_top">boost/conversion/type_traits/is_move_assignable.hpp</a>&gt;</h5></div></div></div>
<p>Defines the type trait <code class="computeroutput">is_move_assignable</code>. </p>
<pre class="synopsis"><span class="keyword">namespace</span> <span class="identifier">boost</span> <span class="special">{</span>
  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> T<span class="special">&gt;</span> <span class="keyword">struct</span> <a class="link" href="boost/is_move_assignable.html" title="Struct template is_move_assignable">is_move_assignable</a><span class="special">;</span>
<span class="special">}</span></pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="header.boost.conversion.type_traits.is_move_constructible_hpp"></a>Header &lt;<a href="../../../../boost/conversion/type_traits/is_move_constructible.hpp" target="_top">boost/conversion/type_traits/is_move_constructible.hpp</a>&gt;</h5></div></div></div>
<p>Defines the type trait <code class="computeroutput">is_move_constructible</code>. </p>
<pre class="synopsis"><span class="keyword">namespace</span> <span class="identifier">boost</span> <span class="special">{</span>
  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> T<span class="special">&gt;</span> <span class="keyword">struct</span> <a class="link" href="boost/is_move_constructible.html" title="Struct template is_move_constructible">is_move_constructible</a><span class="special">;</span>
<span class="special">}</span></pre>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="c___standard_specializations_workarounds"></a>C++ Standard specializations workarounds</h4></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="index.html#header.boost.conversion.type_traits.std.complex_hpp">Header &lt;boost/conversion/type_traits/std/complex.hpp&gt;</a></span></dt>
<dt><span class="section"><a href="index.html#header.boost.conversion.type_traits.std.string_hpp">Header &lt;boost/conversion/type_traits/std/string.hpp&gt;</a></span></dt>
<dt><span class="section"><a href="index.html#header.boost.conversion.type_traits.std.utility_hpp">Header &lt;boost/conversion/type_traits/std/utility.hpp&gt;</a></span></dt>
<dt><span class="section"><a href="index.html#header.boost.conversion.type_traits.std.vector_hpp">Header &lt;boost/conversion/type_traits/std/vector.hpp&gt;</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="header.boost.conversion.type_traits.std.complex_hpp"></a>Header &lt;<a href="../../../../boost/conversion/type_traits/std/complex.hpp" target="_top">boost/conversion/type_traits/std/complex.hpp</a>&gt;</h5></div></div></div>
<p>Type traits specializations for &lt;complex&gt; types. </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="header.boost.conversion.type_traits.std.string_hpp"></a>Header &lt;<a href="../../../../boost/conversion/type_traits/std/string.hpp" target="_top">boost/conversion/type_traits/std/string.hpp</a>&gt;</h5></div></div></div>
<p>Type traits specializations for &lt;string&gt; types. </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="header.boost.conversion.type_traits.std.utility_hpp"></a>Header &lt;<a href="../../../../boost/conversion/type_traits/std/utility.hpp" target="_top">boost/conversion/type_traits/std/utility.hpp</a>&gt;</h5></div></div></div>
<p>Type traits specializations for &lt;utility&gt; classes. </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="header.boost.conversion.type_traits.std.vector_hpp"></a>Header &lt;<a href="../../../../boost/conversion/type_traits/std/vector.hpp" target="_top">boost/conversion/type_traits/std/vector.hpp</a>&gt;</h5></div></div></div>
<p>Type traits specializations for &lt;vector&gt; types. </p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_specializations_workarounds"></a>Boost specializations workarounds</h4></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="index.html#header.boost.conversion.type_traits.boost.array_hpp">Header &lt;boost/conversion/type_traits/boost/array.hpp&gt;</a></span></dt>
<dt><span class="section"><a href="index.html#header.boost.conversion.type_traits.boost.chrono.duration_hpp">Header &lt;boost/conversion/type_traits/boost/chrono/duration.hpp&gt;</a></span></dt>
<dt><span class="section"><a href="index.html#header.boost.conversion.type_traits.boost.chrono.time_point_hpp">Header &lt;boost/conversion/type_traits/boost/chrono/time_point.hpp&gt;</a></span></dt>
<dt><span class="section"><a href="index.html#header.boost.conversion.type_traits.boost.fusion.tuple_hpp">Header &lt;boost/conversion/type_traits/boost/fusion/tuple.hpp&gt;</a></span></dt>
<dt><span class="section"><a href="index.html#header.boost.conversion.type_traits.boost.numeric.interval_hpp">Header &lt;boost/conversion/type_traits/boost/numeric/interval.hpp&gt;</a></span></dt>
<dt><span class="section"><a href="index.html#header.boost.conversion.type_traits.boost.optional_hpp">Header &lt;boost/conversion/type_traits/boost/optional.hpp&gt;</a></span></dt>
<dt><span class="section"><a href="index.html#header.boost.conversion.type_traits.boost.rational_hpp">Header &lt;boost/conversion/type_traits/boost/rational.hpp&gt;</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="header.boost.conversion.type_traits.boost.array_hpp"></a>Header &lt;<a href="../../../../boost/conversion/type_traits/boost/array.hpp" target="_top">boost/conversion/type_traits/boost/array.hpp</a>&gt;</h5></div></div></div>
<p>Type traits specializations for &lt;boost/array.hpp&gt; types. </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="header.boost.conversion.type_traits.boost.chrono.duration_hpp"></a>Header &lt;<a href="../../../../boost/conversion/type_traits/boost/chrono/duration.hpp" target="_top">boost/conversion/type_traits/boost/chrono/duration.hpp</a>&gt;</h5></div></div></div>
<p>Type traits specializations for &lt;boost/chrono/duration.hpp&gt; types. </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="header.boost.conversion.type_traits.boost.chrono.time_point_hpp"></a>Header &lt;<a href="../../../../boost/conversion/type_traits/boost/chrono/time_point.hpp" target="_top">boost/conversion/type_traits/boost/chrono/time_point.hpp</a>&gt;</h5></div></div></div>
<p>Type traits specializations for &lt;boost/chrono/time_point.hpp&gt; types. </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="header.boost.conversion.type_traits.boost.fusion.tuple_hpp"></a>Header &lt;<a href="../../../../boost/conversion/type_traits/boost/fusion/tuple.hpp" target="_top">boost/conversion/type_traits/boost/fusion/tuple.hpp</a>&gt;</h5></div></div></div>
<p>Type traits specializations for &lt;boost/fusion/tuple.hpp&gt; types. </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="header.boost.conversion.type_traits.boost.numeric.interval_hpp"></a>Header &lt;<a href="../../../../boost/conversion/type_traits/boost/numeric/interval.hpp" target="_top">boost/conversion/type_traits/boost/numeric/interval.hpp</a>&gt;</h5></div></div></div>
<p>Type traits specializations for &lt;boost/array.hpp&gt; types. </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="header.boost.conversion.type_traits.boost.optional_hpp"></a>Header &lt;<a href="../../../../boost/conversion/type_traits/boost/optional.hpp" target="_top">boost/conversion/type_traits/boost/optional.hpp</a>&gt;</h5></div></div></div>
<p>Type traits specializations for &lt;boost/optional.hpp&gt; types. </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="header.boost.conversion.type_traits.boost.rational_hpp"></a>Header &lt;<a href="../../../../boost/conversion/type_traits/boost/rational.hpp" target="_top">boost/conversion/type_traits/boost/rational.hpp</a>&gt;</h5></div></div></div>
<p>Type traits specializations for &lt;boost/rational.hpp&gt; types. </p>
</div>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="core"></a>Core</h3></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="index.html#header.boost.conversion_hpp">Header &lt;boost/conversion.hpp&gt;</a></span></dt>
<dt><span class="section"><a href="index.html#header.boost.conversion.assign_to_hpp">Header &lt;boost/conversion/assign_to.hpp&gt;</a></span></dt>
<dd><dl></dl></dd>
<dt><span class="section"><a href="index.html#header.boost.conversion.assignable_to_hpp">Header &lt;boost/conversion/assignable_to.hpp&gt;</a></span></dt>
<dd><dl></dl></dd>
<dt><span class="section"><a href="index.html#header.boost.conversion.convert_to_hpp">Header &lt;boost/conversion/convert_to.hpp&gt;</a></span></dt>
<dd><dl></dl></dd>
<dt><span class="section"><a href="index.html#header.boost.conversion.fp.convert_to_hpp">Header &lt;boost/conversion/fp/convert_to.hpp&gt;</a></span></dt>
<dd><dl></dl></dd>
<dt><span class="section"><a href="index.html#header.boost.conversion.convert_to_or_fallback_hpp">Header &lt;boost/conversion/convert_to_or_fallback.hpp&gt;</a></span></dt>
<dd><dl></dl></dd>
<dt><span class="section"><a href="index.html#header.boost.conversion.convertible_from_hpp">Header &lt;boost/conversion/convertible_from.hpp&gt;</a></span></dt>
<dd><dl></dl></dd>
<dt><span class="section"><a href="index.html#header.boost.conversion.convertible_to_hpp">Header &lt;boost/conversion/convertible_to.hpp&gt;</a></span></dt>
<dd><dl></dl></dd>
<dt><span class="section"><a href="index.html#header.boost.conversion.explicit_convert_to_hpp">Header &lt;boost/conversion/explicit_convert_to.hpp&gt;</a></span></dt>
<dd><dl></dl></dd>
<dt><span class="section"><a href="index.html#header.boost.conversion.implicit_convert_to_hpp">Header &lt;boost/conversion/implicit_convert_to.hpp&gt;</a></span></dt>
<dd><dl></dl></dd>
<dt><span class="section"><a href="index.html#header.boost.conversion.include_hpp">Header &lt;boost/conversion/include.hpp&gt;</a></span></dt>
<dt><span class="section"><a href="index.html#header.boost.conversion.is_extrinsically_assignable_hpp">Header &lt;boost/conversion/is_extrinsically_assignable.hpp&gt;</a></span></dt>
<dd><dl></dl></dd>
<dt><span class="section"><a href="index.html#header.boost.conversion.is_extrinsically_convertible_hpp">Header &lt;boost/conversion/is_extrinsically_convertible.hpp&gt;</a></span></dt>
<dd><dl></dl></dd>
<dt><span class="section"><a href="index.html#header.boost.conversion.is_extrinsically_explicit_convertible_hpp">Header &lt;boost/conversion/is_extrinsically_explicit_convertible.hpp&gt;</a></span></dt>
<dd><dl></dl></dd>
<dt><span class="section"><a href="index.html#header.boost.conversion.try_assign_to_hpp">Header &lt;boost/conversion/try_assign_to.hpp&gt;</a></span></dt>
<dd><dl></dl></dd>
<dt><span class="section"><a href="index.html#header.boost.conversion.try_convert_to_hpp">Header &lt;boost/conversion/try_convert_to.hpp&gt;</a></span></dt>
<dd><dl></dl></dd>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="header.boost.conversion_hpp"></a>Header &lt;<a href="../../../../boost/conversion.hpp" target="_top">boost/conversion.hpp</a>&gt;</h4></div></div></div>
<p>Include all the core conversion public header files. Note that you will need to include explicitly the C++ standard or Boost specific files when using specific classes. </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="header.boost.conversion.assign_to_hpp"></a>Header &lt;<a href="../../../../boost/conversion/assign_to.hpp" target="_top">boost/conversion/assign_to.hpp</a>&gt;</h4></div></div></div>
<p>Defines the free function <code class="computeroutput">assign_to</code> and its customization point <code class="computeroutput">assigner</code>. </p>
<p>The function <code class="computeroutput">assign_to</code> assigns the <code class="computeroutput">from</code> parameter to the <code class="computeroutput">to</code> parameter.</p>
<p>The default behavior uses the assignment operator when the <code class="computeroutput">Target</code> is assignable from the <code class="computeroutput">Source</code>, or makes an implicit conversion of the @ Source before assignment when the <code class="computeroutput">Source</code> is implicitly convertible to <code class="computeroutput">Target</code>.</p>
<p>When the default behavior is not satisfactory or doesn't takes care of specific types, the user could customize the behavior of <code class="computeroutput">assign_to</code> in two ways:</p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem"><p>overload the <code class="computeroutput">assign_to</code> on any namespace found by ADL from the <code class="computeroutput">Source</code> or the <code class="computeroutput">Target</code>.</p></li>
<li class="listitem"><p>partially specialize the <code class="computeroutput"><a class="link" href="boost/conversion/assigner_cp.html" title="Struct template assigner_cp">boost::conversion::assigner_cp</a></code> struct.</p></li>
</ul></div>
<p>
</p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>As we can not add new functions on the <code class="computeroutput">std</code> namespace, partial specialization is the only option in these cases. </p></td></tr>
</table></div>
<p>
</p>
<pre class="synopsis"><span class="keyword">namespace</span> <span class="identifier">boost</span> <span class="special">{</span>
  <span class="keyword">namespace</span> <span class="identifier">conversion</span> <span class="special">{</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> Target<span class="special">,</span> <span class="keyword">typename</span> Source<span class="special">,</span> <span class="keyword">typename</span> Enable <span class="special">=</span> <span class="keyword">void</span><span class="special">&gt;</span> 
      <span class="keyword">struct</span> <a class="link" href="boost/conversion/assigner_cp.html" title="Struct template assigner_cp">assigner_cp</a><span class="special">;</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> Target<span class="special">,</span> <span class="keyword">typename</span> Source<span class="special">,</span> <span class="keyword">typename</span> Enable <span class="special">=</span> <span class="keyword">void</span><span class="special">&gt;</span> 
      <span class="keyword">struct</span> <a class="link" href="boost/conversion/assigner.html" title="Struct template assigner">assigner</a><span class="special">;</span>

    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> Target<span class="special">,</span> <span class="keyword">typename</span> Source<span class="special">&gt;</span> 
      <span class="keyword">struct</span> <a class="link" href="boost/conversion/assigner_Target__Source_idp15908384.html" title="Struct template assigner&lt;Target, Source, requires(CopyAssignable&lt; Target &gt; &amp;&amp;ExtrinsicallyExplicitConvertible&lt; Source, Target &gt; &amp;&amp;!Assignable&lt; Target, Source &gt;)&gt;">assigner</a><span class="special">&lt;</span><span class="identifier">Target</span><span class="special">,</span> <span class="identifier">Source</span><span class="special">,</span> <span class="identifier">requires</span><span class="special">(</span><span class="identifier">CopyAssignable</span><span class="special">&lt;</span> <span class="identifier">Target</span> <span class="special">&gt;</span> <span class="special">&amp;&amp;</span><span class="identifier">ExtrinsicallyExplicitConvertible</span><span class="special">&lt;</span> <span class="identifier">Source</span><span class="special">,</span> <span class="identifier">Target</span> <span class="special">&gt;</span> <span class="special">&amp;&amp;</span><span class="special">!</span><span class="identifier">Assignable</span><span class="special">&lt;</span> <span class="identifier">Target</span><span class="special">,</span> <span class="identifier">Source</span> <span class="special">&gt;</span><span class="special">)</span><span class="special">&gt;</span><span class="special">;</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> Target<span class="special">,</span> <span class="keyword">typename</span> Source<span class="special">&gt;</span> 
      <span class="keyword">struct</span> <a class="link" href="boost/conversion/assigner_Target__Source_idp15923200.html" title="Struct template assigner&lt;Target, Source, requires(Assignable&lt; Target, Source &gt;)&gt;">assigner</a><span class="special">&lt;</span><span class="identifier">Target</span><span class="special">,</span> <span class="identifier">Source</span><span class="special">,</span> <span class="identifier">requires</span><span class="special">(</span><span class="identifier">Assignable</span><span class="special">&lt;</span> <span class="identifier">Target</span><span class="special">,</span> <span class="identifier">Source</span> <span class="special">&gt;</span><span class="special">)</span><span class="special">&gt;</span><span class="special">;</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> Target<span class="special">,</span> <span class="keyword">typename</span> Source<span class="special">&gt;</span> 
      <span class="identifier">enable_if_c</span><span class="special">&lt;</span> <span class="identifier">is_extrinsically_assignable_tagged</span><span class="special">&lt;</span> <span class="identifier">Target</span><span class="special">,</span> <span class="identifier">Source</span> <span class="special">&gt;</span><span class="special">::</span><span class="identifier">value</span><span class="special">,</span> <span class="identifier">Target</span> <span class="special">&amp;</span> <span class="special">&gt;</span><span class="special">::</span><span class="identifier">type</span> 
      <a class="link" href="boost/conversion/assign_to.html" title="Function template assign_to"><span class="identifier">assign_to</span></a><span class="special">(</span><span class="identifier">Target</span> <span class="special">&amp;</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">Source</span> <span class="special">&amp;</span><span class="special">)</span><span class="special">;</span>
  <span class="special">}</span>
<span class="special">}</span></pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="header.boost.conversion.assignable_to_hpp"></a>Header &lt;<a href="../../../../boost/conversion/assignable_to.hpp" target="_top">boost/conversion/assignable_to.hpp</a>&gt;</h4></div></div></div>
<p>Defines the free function <code class="computeroutput">assignable_to</code> class and the factory <code class="computeroutput">lvalue</code>. </p>
<pre class="synopsis"><span class="keyword">namespace</span> <span class="identifier">boost</span> <span class="special">{</span>
  <span class="keyword">namespace</span> <span class="identifier">conversion</span> <span class="special">{</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> Target<span class="special">&gt;</span> <span class="keyword">class</span> <a class="link" href="boost/conversion/assignable_to.html" title="Class template assignable_to">assignable_to</a><span class="special">;</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> Target<span class="special">&gt;</span> <a class="link" href="boost/conversion/assignable_to.html" title="Class template assignable_to">assignable_to</a><span class="special">&lt;</span> <span class="identifier">Target</span> <span class="special">&gt;</span> <a class="link" href="boost/conversion/lvalue.html" title="Function template lvalue"><span class="identifier">lvalue</span></a><span class="special">(</span><span class="identifier">Target</span> <span class="special">&amp;</span><span class="special">)</span><span class="special">;</span>
  <span class="special">}</span>
<span class="special">}</span></pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="header.boost.conversion.convert_to_hpp"></a>Header &lt;<a href="../../../../boost/conversion/convert_to.hpp" target="_top">boost/conversion/convert_to.hpp</a>&gt;</h4></div></div></div>
<p>Defines the free function <code class="computeroutput">convert_to</code>. </p>
<p>The <code class="computeroutput">convert_to</code> function converts the <code class="computeroutput">from</code> parameter to a <code class="computeroutput">Target</code> type. </p>
<pre class="synopsis"><span class="keyword">namespace</span> <span class="identifier">boost</span> <span class="special">{</span>
  <span class="keyword">namespace</span> <span class="identifier">conversion</span> <span class="special">{</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> Target<span class="special">,</span> <span class="keyword">typename</span> Source<span class="special">&gt;</span> 
      <span class="identifier">Target</span> <a class="link" href="boost/conversion/convert_to.html" title="Function template convert_to"><span class="identifier">convert_to</span></a><span class="special">(</span><span class="identifier">Source</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="special">)</span><span class="special">;</span>
  <span class="special">}</span>
<span class="special">}</span></pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="header.boost.conversion.fp.convert_to_hpp"></a>Header &lt;<a href="../../../../boost/conversion/fp/convert_to.hpp" target="_top">boost/conversion/fp/convert_to.hpp</a>&gt;</h4></div></div></div>
<p>Defines a converter factory: <code class="computeroutput">make_converter_to</code>. </p>
<pre class="synopsis"><span class="keyword">namespace</span> <span class="identifier">boost</span> <span class="special">{</span>
  <span class="keyword">namespace</span> <span class="identifier">conversion</span> <span class="special">{</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> Target<span class="special">,</span> <span class="keyword">typename</span> Source<span class="special">&gt;</span> 
      <span class="identifier">unspecified_converter_type</span> <a class="link" href="boost/conversion/make_converter_to.html" title="Function template make_converter_to"><span class="identifier">make_converter_to</span></a><span class="special">(</span><span class="identifier">Source</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="special">)</span><span class="special">;</span>
  <span class="special">}</span>
<span class="special">}</span></pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="header.boost.conversion.convert_to_or_fallback_hpp"></a>Header &lt;<a href="../../../../boost/conversion/convert_to_or_fallback.hpp" target="_top">boost/conversion/convert_to_or_fallback.hpp</a>&gt;</h4></div></div></div>
<p>Defines the free function <code class="computeroutput">convert_to_or_fallback</code> and its customization point <code class="computeroutput">converter_or_fallbacker_cp</code>. </p>
<p>The <code class="computeroutput">convert_to_or_fallback</code> function converts the <code class="computeroutput">from</code> parameter to a <code class="computeroutput">Target</code> type. If the conversion fails the fallback value is used to construct a Target <code class="computeroutput">instance</code>.</p>
<p>The default implementation applies the conversion <code class="computeroutput">Target</code> operator of the <code class="computeroutput">Source</code> class or the copy constructor of the <code class="computeroutput">Target</code> class. When an exception is thrown the fallback is returned. Of course if both exist the conversion is ambiguous.</p>
<p>When the default behavior is not satisfactory or doesn't takes care of specific types, the user could customize the behavior of <code class="computeroutput">convert_to_or_fallback</code> in two ways:</p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem"><p>overload the <code class="computeroutput">convert_to_or_fallback</code> on any namespace found by ADL from the <code class="computeroutput">Source</code> or the <code class="computeroutput">Target</code>. A trick is used to overload on the return type by adding a dummy parameter depending on the <code class="computeroutput">Target</code>.</p></li>
<li class="listitem"><p>partially specialize the <code class="computeroutput"><a class="link" href="boost/conversion/converter_or_fallbacker_cp.html" title="Struct template converter_or_fallbacker_cp">boost::conversion::converter_or_fallbacker_cp</a></code> struct.</p></li>
</ul></div>
<p>
</p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>As we can not add new functions on the <code class="computeroutput">std</code> namespace, partial specialization is the only option in these cases. </p></td></tr>
</table></div>
<p>
</p>
<pre class="synopsis"><span class="keyword">namespace</span> <span class="identifier">boost</span> <span class="special">{</span>
  <span class="keyword">namespace</span> <span class="identifier">conversion</span> <span class="special">{</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> Target<span class="special">,</span> <span class="keyword">typename</span> Source<span class="special">,</span> <span class="keyword">typename</span> Fallback <span class="special">=</span> <span class="identifier">Target</span><span class="special">,</span> 
             <span class="keyword">typename</span> Enable <span class="special">=</span> <span class="keyword">void</span><span class="special">&gt;</span> 
      <span class="keyword">struct</span> <a class="link" href="boost/conversion/converter_or_fallbacker_cp.html" title="Struct template converter_or_fallbacker_cp">converter_or_fallbacker_cp</a><span class="special">;</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> Target<span class="special">,</span> <span class="keyword">typename</span> Source<span class="special">,</span> <span class="keyword">typename</span> Fallback <span class="special">=</span> <span class="identifier">Target</span><span class="special">,</span> 
             <span class="keyword">typename</span> Enable <span class="special">=</span> <span class="keyword">void</span><span class="special">&gt;</span> 
      <span class="keyword">struct</span> <a class="link" href="boost/conversion/converter_or_fallbacker.html" title="Struct template converter_or_fallbacker">converter_or_fallbacker</a><span class="special">;</span>

    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> Target<span class="special">,</span> <span class="keyword">typename</span> Source<span class="special">,</span> <span class="keyword">typename</span> Fallback<span class="special">&gt;</span> 
      <span class="keyword">struct</span> <a class="link" href="boost/conversion/converter_or_fallbacker_idp16036640.html" title="Struct template converter_or_fallbacker&lt;Target, Source, Fallback, requires(ExtrinsicallyExplicitConvertible&lt; Source, Target &gt; &amp;&amp;ExtrinsicallyExplicitConvertible&lt; Fallback, Target &gt;)&gt;">converter_or_fallbacker</a><span class="special">&lt;</span><span class="identifier">Target</span><span class="special">,</span> <span class="identifier">Source</span><span class="special">,</span> <span class="identifier">Fallback</span><span class="special">,</span> <span class="identifier">requires</span><span class="special">(</span><span class="identifier">ExtrinsicallyExplicitConvertible</span><span class="special">&lt;</span> <span class="identifier">Source</span><span class="special">,</span> <span class="identifier">Target</span> <span class="special">&gt;</span> <span class="special">&amp;&amp;</span><span class="identifier">ExtrinsicallyExplicitConvertible</span><span class="special">&lt;</span> <span class="identifier">Fallback</span><span class="special">,</span> <span class="identifier">Target</span> <span class="special">&gt;</span><span class="special">)</span><span class="special">&gt;</span><span class="special">;</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> Target<span class="special">,</span> <span class="keyword">typename</span> Source<span class="special">,</span> <span class="keyword">typename</span> Fallback<span class="special">&gt;</span> 
      <span class="identifier">enable_if_c</span><span class="special">&lt;</span> <span class="special">!</span><span class="identifier">is_same</span><span class="special">&lt;</span> <span class="identifier">Target</span><span class="special">,</span> <span class="identifier">Fallback</span> <span class="special">&gt;</span><span class="special">::</span><span class="identifier">value</span> <span class="special">&amp;&amp;</span><span class="identifier">is_extrinsically_explicit_convertible_or_fallback_tagged</span><span class="special">&lt;</span> <span class="identifier">Source</span><span class="special">,</span> <span class="identifier">Target</span><span class="special">,</span> <span class="identifier">Fallback</span> <span class="special">&gt;</span><span class="special">::</span><span class="identifier">value</span><span class="special">,</span> <span class="identifier">Target</span> <span class="special">&gt;</span><span class="special">::</span><span class="identifier">type</span> 
      <a class="link" href="boost/conversion/convert_to_or_fallback_idp16051776.html" title="Function template convert_to_or_fallback"><span class="identifier">convert_to_or_fallback</span></a><span class="special">(</span><span class="identifier">Source</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="special">,</span> <span class="identifier">Fallback</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="special">)</span><span class="special">;</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> Target<span class="special">,</span> <span class="keyword">typename</span> Source<span class="special">&gt;</span> 
      <span class="identifier">enable_if_c</span><span class="special">&lt;</span> <span class="identifier">is_extrinsically_explicit_convertible_or_fallback_tagged</span><span class="special">&lt;</span> <span class="identifier">Source</span><span class="special">,</span> <span class="identifier">Target</span><span class="special">,</span> <span class="identifier">Target</span> <span class="special">&gt;</span><span class="special">::</span><span class="identifier">value</span><span class="special">,</span> <span class="identifier">Target</span> <span class="special">&gt;</span><span class="special">::</span><span class="identifier">type</span> 
      <a class="link" href="boost/conversion/convert_to_or_fallback_idp16064944.html" title="Function template convert_to_or_fallback"><span class="identifier">convert_to_or_fallback</span></a><span class="special">(</span><span class="identifier">Source</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="special">,</span> <span class="identifier">Target</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="special">)</span><span class="special">;</span>
  <span class="special">}</span>
<span class="special">}</span></pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="header.boost.conversion.convertible_from_hpp"></a>Header &lt;<a href="../../../../boost/conversion/convertible_from.hpp" target="_top">boost/conversion/convertible_from.hpp</a>&gt;</h4></div></div></div>
<p>Defines the free function <code class="computeroutput">implicitly</code>. </p>
<pre class="synopsis"><span class="keyword">namespace</span> <span class="identifier">boost</span> <span class="special">{</span>
  <span class="keyword">namespace</span> <span class="identifier">conversion</span> <span class="special">{</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> Source<span class="special">,</span> 
             <span class="keyword">typename</span> Enable <span class="special">=</span> <span class="identifier">requires</span><span class="special">(</span>            <span class="identifier">CopyConstructible</span><span class="special">&lt;</span><span class="identifier">Source</span><span class="special">&gt;</span>        <span class="special">)</span><span class="special">&gt;</span> 
      <span class="keyword">class</span> <a class="link" href="boost/conversion/convertible_from.html" title="Class template convertible_from">convertible_from</a><span class="special">;</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> Source<span class="special">&gt;</span> 
      <span class="identifier">enable_if_c</span><span class="special">&lt;</span> <span class="identifier">is_copy_constructible</span><span class="special">&lt;</span> <span class="identifier">Source</span> <span class="special">&gt;</span><span class="special">::</span><span class="identifier">value</span><span class="special">,</span> <a class="link" href="boost/conversion/convertible_from.html" title="Class template convertible_from">convertible_from</a><span class="special">&lt;</span> <span class="identifier">Source</span> <span class="special">&gt;</span> <span class="special">&gt;</span><span class="special">::</span><span class="identifier">type</span> 
      <a class="link" href="boost/conversion/implicitly.html" title="Function template implicitly"><span class="identifier">implicitly</span></a><span class="special">(</span><span class="identifier">Source</span><span class="special">)</span><span class="special">;</span>
  <span class="special">}</span>
<span class="special">}</span></pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="header.boost.conversion.convertible_to_hpp"></a>Header &lt;<a href="../../../../boost/conversion/convertible_to.hpp" target="_top">boost/conversion/convertible_to.hpp</a>&gt;</h4></div></div></div>
<p>Defines the <code class="computeroutput">convertible_to</code> wrapper. </p>
<pre class="synopsis"><span class="keyword">namespace</span> <span class="identifier">boost</span> <span class="special">{</span>
  <span class="keyword">namespace</span> <span class="identifier">conversion</span> <span class="special">{</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> Target<span class="special">&gt;</span> <span class="keyword">class</span> <a class="link" href="boost/conversion/convertible_to.html" title="Class template convertible_to">convertible_to</a><span class="special">;</span>
  <span class="special">}</span>
<span class="special">}</span></pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="header.boost.conversion.explicit_convert_to_hpp"></a>Header &lt;<a href="../../../../boost/conversion/explicit_convert_to.hpp" target="_top">boost/conversion/explicit_convert_to.hpp</a>&gt;</h4></div></div></div>
<p>Defines the free function <code class="computeroutput">explicit_convert_to</code> and its customization point <code class="computeroutput">explicit_converter</code>. </p>
<p>The <code class="computeroutput">explicit_convert_to</code> function explicit converts the <code class="computeroutput">from</code> parameter to a <code class="computeroutput">Target</code> type.</p>
<p>The default behavior returns the explicit conversion operator when <code class="computeroutput">Source</code> is implicitly convertible to <code class="computeroutput">Target</code> and the extrinsic implicit conversion when <code class="computeroutput">Source</code> is extrinsically implicitly convertible to <code class="computeroutput">Target</code>.</p>
<p>When the default behavior is not satisfactory or doesn't takes care of specific types, the user could customize the behavior of <code class="computeroutput">explicit_convert_to</code> in two ways:</p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem"><p>overload the <code class="computeroutput">explicit_convert_to</code> on any namespace found by ADL from the <code class="computeroutput">Source</code> or the <code class="computeroutput">Target</code>. A trick is used to overload on the return type by adding a dummy parameter depending on the <code class="computeroutput">Target</code>.</p></li>
<li class="listitem"><p>partially specialize the <code class="computeroutput"><a class="link" href="boost/conversion/explicit_converter_cp.html" title="Struct template explicit_converter_cp">boost::conversion::explicit_converter_cp</a></code> struct.</p></li>
</ul></div>
<p>
</p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>As we can not add new functions on the <code class="computeroutput">std</code> namespace, partial specialization is the only option in these cases. </p></td></tr>
</table></div>
<p>
</p>
<pre class="synopsis"><span class="keyword">namespace</span> <span class="identifier">boost</span> <span class="special">{</span>
  <span class="keyword">namespace</span> <span class="identifier">conversion</span> <span class="special">{</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> Target<span class="special">,</span> <span class="keyword">typename</span> Source<span class="special">,</span> <span class="keyword">typename</span> Enable <span class="special">=</span> <span class="keyword">void</span><span class="special">&gt;</span> 
      <span class="keyword">struct</span> <a class="link" href="boost/conversion/explicit_converter_cp.html" title="Struct template explicit_converter_cp">explicit_converter_cp</a><span class="special">;</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> Target<span class="special">,</span> <span class="keyword">typename</span> Source<span class="special">,</span> <span class="keyword">typename</span> Enable <span class="special">=</span> <span class="keyword">void</span><span class="special">&gt;</span> 
      <span class="keyword">struct</span> <a class="link" href="boost/conversion/explicit_converter.html" title="Struct template explicit_converter">explicit_converter</a><span class="special">;</span>

    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> Target<span class="special">,</span> <span class="keyword">typename</span> Source<span class="special">&gt;</span> 
      <span class="keyword">struct</span> <a class="link" href="boost/conversion/explicit_converter_Targ_idp16146992.html" title="Struct template explicit_converter&lt;Target, Source, requires(ExplicitConvertible&lt; Source, Target &gt;)&gt;">explicit_converter</a><span class="special">&lt;</span><span class="identifier">Target</span><span class="special">,</span> <span class="identifier">Source</span><span class="special">,</span> <span class="identifier">requires</span><span class="special">(</span><span class="identifier">ExplicitConvertible</span><span class="special">&lt;</span> <span class="identifier">Source</span><span class="special">,</span> <span class="identifier">Target</span> <span class="special">&gt;</span><span class="special">)</span><span class="special">&gt;</span><span class="special">;</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> Target<span class="special">,</span> <span class="keyword">typename</span> Source<span class="special">&gt;</span> 
      <span class="keyword">struct</span> <a class="link" href="boost/conversion/explicit_converter_Targ_idp16159344.html" title="Struct template explicit_converter&lt;Target, Source, requires(ExtrinsicallyConvertible&lt; Source, Target &gt;)&gt;">explicit_converter</a><span class="special">&lt;</span><span class="identifier">Target</span><span class="special">,</span> <span class="identifier">Source</span><span class="special">,</span> <span class="identifier">requires</span><span class="special">(</span><span class="identifier">ExtrinsicallyConvertible</span><span class="special">&lt;</span> <span class="identifier">Source</span><span class="special">,</span> <span class="identifier">Target</span> <span class="special">&gt;</span><span class="special">)</span><span class="special">&gt;</span><span class="special">;</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> Target<span class="special">,</span> <span class="keyword">typename</span> Source<span class="special">&gt;</span> 
      <span class="keyword">struct</span> <a class="link" href="boost/conversion/explicit_converter_opti_idp16171280.html" title="Struct template explicit_converter&lt;optional&lt; Target &gt;, Source, requires(ExtrinsicallyExplicitConvertible&lt; Source, Target &gt;)&gt;">explicit_converter</a><span class="special">&lt;</span><span class="identifier">optional</span><span class="special">&lt;</span> <span class="identifier">Target</span> <span class="special">&gt;</span><span class="special">,</span> <span class="identifier">Source</span><span class="special">,</span> <span class="identifier">requires</span><span class="special">(</span><span class="identifier">ExtrinsicallyExplicitConvertible</span><span class="special">&lt;</span> <span class="identifier">Source</span><span class="special">,</span> <span class="identifier">Target</span> <span class="special">&gt;</span><span class="special">)</span><span class="special">&gt;</span><span class="special">;</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> Target<span class="special">,</span> <span class="keyword">typename</span> Source<span class="special">&gt;</span> 
      <span class="identifier">enable_if_c</span><span class="special">&lt;</span> <span class="identifier">is_extrinsically_explicit_convertible_tagged</span><span class="special">&lt;</span> <span class="identifier">Source</span><span class="special">,</span> <span class="identifier">Target</span> <span class="special">&gt;</span><span class="special">::</span><span class="identifier">value</span><span class="special">,</span> <span class="identifier">Target</span> <span class="special">&gt;</span><span class="special">::</span><span class="identifier">type</span> 
      <a class="link" href="boost/conversion/explicit_convert_to.html" title="Function template explicit_convert_to"><span class="identifier">explicit_convert_to</span></a><span class="special">(</span><span class="identifier">Source</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="special">)</span><span class="special">;</span>
  <span class="special">}</span>
<span class="special">}</span></pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="header.boost.conversion.implicit_convert_to_hpp"></a>Header &lt;<a href="../../../../boost/conversion/implicit_convert_to.hpp" target="_top">boost/conversion/implicit_convert_to.hpp</a>&gt;</h4></div></div></div>
<p>Defines the free function <code class="computeroutput">implicit_convert_to</code> and its customization point <code class="computeroutput">implicit_converter</code>. </p>
<p>The <code class="computeroutput">implicit_convert_to</code> function converts the <code class="computeroutput">from</code> parameter to a <code class="computeroutput">Target</code> type and is intended to be used in a implicit context.</p>
<p>The default behavior returns the implicit conversion when <code class="computeroutput">Source</code> is implicitly convertible to <code class="computeroutput">Target</code> </p>
<p>When the default behavior is not satisfactory or it doesn't takes care of specific types, the user could customize the behavior of <code class="computeroutput">implicit_convert_to</code> in two ways:</p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem"><p>overload the <code class="computeroutput">implicit_convert_to</code> on any namespace found by ADL from the <code class="computeroutput">Source</code> or the <code class="computeroutput">Target</code>. A trick is used to overload on the return type by adding a dummy parameter depending on the <code class="computeroutput">Target</code>.</p></li>
<li class="listitem"><p>partially specialize the <code class="computeroutput"><a class="link" href="boost/conversion/implicit_converter_cp.html" title="Struct template implicit_converter_cp">boost::conversion::implicit_converter_cp</a></code> struct.</p></li>
</ul></div>
<p>
</p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>As we can not add new functions on the <code class="computeroutput">std</code> namespace, partial specialization is the only option in these cases. </p></td></tr>
</table></div>
<p>
</p>
<pre class="synopsis"><span class="keyword">namespace</span> <span class="identifier">boost</span> <span class="special">{</span>
  <span class="keyword">namespace</span> <span class="identifier">conversion</span> <span class="special">{</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> Target<span class="special">,</span> <span class="keyword">typename</span> Source<span class="special">,</span> <span class="keyword">typename</span> Enable <span class="special">=</span> <span class="keyword">void</span><span class="special">&gt;</span> 
      <span class="keyword">struct</span> <a class="link" href="boost/conversion/implicit_converter_cp.html" title="Struct template implicit_converter_cp">implicit_converter_cp</a><span class="special">;</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> Target<span class="special">,</span> <span class="keyword">typename</span> Source<span class="special">,</span> <span class="keyword">typename</span> Enable <span class="special">=</span> <span class="keyword">void</span><span class="special">&gt;</span> 
      <span class="keyword">struct</span> <a class="link" href="boost/conversion/implicit_converter.html" title="Struct template implicit_converter">implicit_converter</a><span class="special">;</span>

    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> Target<span class="special">,</span> <span class="keyword">typename</span> Source<span class="special">&gt;</span> 
      <span class="keyword">struct</span> <a class="link" href="boost/conversion/implicit_converter_Targ_idp16216464.html" title="Struct template implicit_converter&lt;Target, Source, requires(Convertible&lt; Source, Target &gt;)&gt;">implicit_converter</a><span class="special">&lt;</span><span class="identifier">Target</span><span class="special">,</span> <span class="identifier">Source</span><span class="special">,</span> <span class="identifier">requires</span><span class="special">(</span><span class="identifier">Convertible</span><span class="special">&lt;</span> <span class="identifier">Source</span><span class="special">,</span> <span class="identifier">Target</span> <span class="special">&gt;</span><span class="special">)</span><span class="special">&gt;</span><span class="special">;</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> Target<span class="special">,</span> <span class="keyword">typename</span> Source<span class="special">&gt;</span> 
      <span class="identifier">enable_if_c</span><span class="special">&lt;</span> <span class="identifier">is_extrinsically_convertible_tagged</span><span class="special">&lt;</span> <span class="identifier">Source</span><span class="special">,</span> <span class="identifier">Target</span> <span class="special">&gt;</span><span class="special">::</span><span class="identifier">value</span><span class="special">,</span> <span class="identifier">Target</span> <span class="special">&gt;</span><span class="special">::</span><span class="identifier">type</span> 
      <a class="link" href="boost/conversion/implicit_convert_to.html" title="Function template implicit_convert_to"><span class="identifier">implicit_convert_to</span></a><span class="special">(</span><span class="keyword">const</span> <span class="identifier">Source</span> <span class="special">&amp;</span><span class="special">)</span><span class="special">;</span>
    <span class="keyword">namespace</span> <span class="identifier">dummy</span> <span class="special">{</span>
      <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> T<span class="special">&gt;</span> <span class="keyword">struct</span> <a class="link" href="boost/conversion/dummy/type_tag.html" title="Struct template type_tag">type_tag</a><span class="special">;</span>
    <span class="special">}</span>
  <span class="special">}</span>
<span class="special">}</span></pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="header.boost.conversion.include_hpp"></a>Header &lt;<a href="../../../../boost/conversion/include.hpp" target="_top">boost/conversion/include.hpp</a>&gt;</h4></div></div></div>
<p>Includes all the core conversion public header files. Note that you will need to include explicitly the C++ standard or Boost specific files when using specific classes. </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="header.boost.conversion.is_extrinsically_assignable_hpp"></a>Header &lt;<a href="../../../../boost/conversion/is_extrinsically_assignable.hpp" target="_top">boost/conversion/is_extrinsically_assignable.hpp</a>&gt;</h4></div></div></div>
<p>Defines the type trait <code class="computeroutput">is_extrinsically_assignable</code>. </p>
<pre class="synopsis">

<a class="link" href="BOOST_CONVERSION_NO_IS_EXTRINSIC_ASSIGNABLE.html" title="Macro BOOST_CONVERSION_NO_IS_EXTRINSIC_ASSIGNABLE">BOOST_CONVERSION_NO_IS_EXTRINSIC_ASSIGNABLE</a></pre>
<pre class="synopsis"><span class="keyword">namespace</span> <span class="identifier">boost</span> <span class="special">{</span>
  <span class="keyword">namespace</span> <span class="identifier">conversion</span> <span class="special">{</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> Target<span class="special">,</span> <span class="keyword">typename</span> Source<span class="special">&gt;</span> 
      <span class="keyword">struct</span> <a class="link" href="boost/conversion/is_extrinsically_assign_idp16264176.html" title="Struct template is_extrinsically_assignable">is_extrinsically_assignable</a><span class="special">;</span>
  <span class="special">}</span>
<span class="special">}</span></pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="header.boost.conversion.is_extrinsically_convertible_hpp"></a>Header &lt;<a href="../../../../boost/conversion/is_extrinsically_convertible.hpp" target="_top">boost/conversion/is_extrinsically_convertible.hpp</a>&gt;</h4></div></div></div>
<p>Defines the type trait <code class="computeroutput">is_extrinsically_convertible</code>. </p>
<pre class="synopsis">

<a class="link" href="BOOST_CONVERSION_NO_IS_EXTRINSIC_CONVERTIBLE.html" title="Macro BOOST_CONVERSION_NO_IS_EXTRINSIC_CONVERTIBLE">BOOST_CONVERSION_NO_IS_EXTRINSIC_CONVERTIBLE</a></pre>
<pre class="synopsis"><span class="keyword">namespace</span> <span class="identifier">boost</span> <span class="special">{</span>
  <span class="keyword">namespace</span> <span class="identifier">conversion</span> <span class="special">{</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> Source<span class="special">,</span> <span class="keyword">typename</span> Target<span class="special">&gt;</span> 
      <span class="keyword">struct</span> <a class="link" href="boost/conversion/is_extrinsically_conver_idp16276016.html" title="Struct template is_extrinsically_convertible">is_extrinsically_convertible</a><span class="special">;</span>
  <span class="special">}</span>
<span class="special">}</span></pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="header.boost.conversion.is_extrinsically_explicit_convertible_hpp"></a>Header &lt;<a href="../../../../boost/conversion/is_extrinsically_explicit_convertible.hpp" target="_top">boost/conversion/is_extrinsically_explicit_convertible.hpp</a>&gt;</h4></div></div></div>
<p>Defines the type trait <code class="computeroutput">is_extrinsically_explicit_convertible</code>. </p>
<pre class="synopsis">

<a class="link" href="BOOST_CONVERSION_NO_IS_EXTRINSIC_EXPLICIT_CONVERTIBLE.html" title="Macro BOOST_CONVERSION_NO_IS_EXTRINSIC_EXPLICIT_CONVERTIBLE">BOOST_CONVERSION_NO_IS_EXTRINSIC_EXPLICIT_CONVERTIBLE</a></pre>
<pre class="synopsis"><span class="keyword">namespace</span> <span class="identifier">boost</span> <span class="special">{</span>
  <span class="keyword">namespace</span> <span class="identifier">conversion</span> <span class="special">{</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> Source<span class="special">,</span> <span class="keyword">typename</span> Target<span class="special">&gt;</span> 
      <span class="keyword">struct</span> <a class="link" href="boost/conversion/is_extrinsically_explic_idp16287920.html" title="Struct template is_extrinsically_explicit_convertible">is_extrinsically_explicit_convertible</a><span class="special">;</span>
  <span class="special">}</span>
<span class="special">}</span></pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="header.boost.conversion.try_assign_to_hpp"></a>Header &lt;<a href="../../../../boost/conversion/try_assign_to.hpp" target="_top">boost/conversion/try_assign_to.hpp</a>&gt;</h4></div></div></div>
<p>Defines the free function <code class="computeroutput">try_assign_to</code> and its customization point <code class="computeroutput">try_assigner</code>. </p>
<p>The function <code class="computeroutput">try_assign_to</code> assigns the <code class="computeroutput">from</code> parameter to the <code class="computeroutput">to</code> parameter. Return <code class="computeroutput">true</code> if assignment done and <code class="computeroutput">false</code> otherwise.</p>
<p>The default behavior stores a roll-back value before doing the assignment so the value can be rolled-back if assignment fails when the <code class="computeroutput">Source</code> is extrinsically assignable to the <code class="computeroutput">Target</code>.</p>
<p>When the default behavior is not satisfactory or doesn't takes care of specific types, the user could customize the behavior of <code class="computeroutput">try_assign_to</code> in two ways:</p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem"><p>overload the <code class="computeroutput">try_assign_to</code> on any namespace found by ADL from the <code class="computeroutput">Source</code> or the <code class="computeroutput">Target</code>.</p></li>
<li class="listitem"><p>partially specialize the <code class="computeroutput"><a class="link" href="boost/conversion/try_assigner_cp.html" title="Struct template try_assigner_cp">boost::conversion::try_assigner_cp</a></code> struct.</p></li>
</ul></div>
<p>
</p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>As we can not add new functions on the <code class="computeroutput">std</code> namespace, partial specialization is the only option in these cases. </p></td></tr>
</table></div>
<p>
</p>
<pre class="synopsis"><span class="keyword">namespace</span> <span class="identifier">boost</span> <span class="special">{</span>
  <span class="keyword">namespace</span> <span class="identifier">conversion</span> <span class="special">{</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> Target<span class="special">,</span> <span class="keyword">typename</span> Source<span class="special">,</span> <span class="keyword">typename</span> Enable <span class="special">=</span> <span class="keyword">void</span><span class="special">&gt;</span> 
      <span class="keyword">struct</span> <a class="link" href="boost/conversion/try_assigner_cp.html" title="Struct template try_assigner_cp">try_assigner_cp</a><span class="special">;</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> Target<span class="special">,</span> <span class="keyword">typename</span> Source<span class="special">,</span> <span class="keyword">typename</span> Enable <span class="special">=</span> <span class="keyword">void</span><span class="special">&gt;</span> 
      <span class="keyword">struct</span> <a class="link" href="boost/conversion/try_assigner.html" title="Struct template try_assigner">try_assigner</a><span class="special">;</span>

    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> Target<span class="special">,</span> <span class="keyword">typename</span> Source<span class="special">&gt;</span> 
      <span class="keyword">struct</span> <a class="link" href="boost/conversion/try_assigner_Target__So_idp16321120.html" title="Struct template try_assigner&lt;Target, Source, requires(CopyConstructible&lt; Target &gt; &amp;&amp;CopyAssignable&lt; Target &gt; &amp;&amp;ExtrinsicallyAssignable&lt; Target, Source &gt;)&gt;">try_assigner</a><span class="special">&lt;</span><span class="identifier">Target</span><span class="special">,</span> <span class="identifier">Source</span><span class="special">,</span> <span class="identifier">requires</span><span class="special">(</span><span class="identifier">CopyConstructible</span><span class="special">&lt;</span> <span class="identifier">Target</span> <span class="special">&gt;</span> <span class="special">&amp;&amp;</span><span class="identifier">CopyAssignable</span><span class="special">&lt;</span> <span class="identifier">Target</span> <span class="special">&gt;</span> <span class="special">&amp;&amp;</span><span class="identifier">ExtrinsicallyAssignable</span><span class="special">&lt;</span> <span class="identifier">Target</span><span class="special">,</span> <span class="identifier">Source</span> <span class="special">&gt;</span><span class="special">)</span><span class="special">&gt;</span><span class="special">;</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> Target<span class="special">,</span> <span class="keyword">typename</span> Source<span class="special">&gt;</span> 
      <span class="identifier">enable_if_c</span><span class="special">&lt;</span> <span class="identifier">is_extrinsically_try_assignable_tagged</span><span class="special">&lt;</span> <span class="identifier">Target</span><span class="special">,</span> <span class="identifier">Source</span> <span class="special">&gt;</span><span class="special">::</span><span class="identifier">value</span><span class="special">,</span> <span class="keyword">bool</span> <span class="special">&gt;</span><span class="special">::</span><span class="identifier">type</span> 
      <a class="link" href="boost/conversion/try_assign_to.html" title="Function template try_assign_to"><span class="identifier">try_assign_to</span></a><span class="special">(</span><span class="identifier">Target</span> <span class="special">&amp;</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">Source</span> <span class="special">&amp;</span><span class="special">)</span><span class="special">;</span>
  <span class="special">}</span>
<span class="special">}</span></pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="header.boost.conversion.try_convert_to_hpp"></a>Header &lt;<a href="../../../../boost/conversion/try_convert_to.hpp" target="_top">boost/conversion/try_convert_to.hpp</a>&gt;</h4></div></div></div>
<p>Defines the free function <code class="computeroutput">try_convert_to</code> and its customization point <code class="computeroutput">try_converter</code>. </p>
<p>The <code class="computeroutput">try_convert_to</code> function converts the <code class="computeroutput">from</code> parameter to a <code class="computeroutput">Target</code> type and returns an optional&lt;Target&gt;, uninitialized if conversion fails.</p>
<p>The default behavior return a make_optional of the conversion when the <code class="computeroutput">Source</code> is extrinsically explicit convertible to the <code class="computeroutput">Target</code>. A try_catch is used to protect from exceptions, and return an uninitialized optional if conversion fails.</p>
<p>When the default behavior is not satisfactory or doesn't takes care of specific types, the user could customize the behavior of <code class="computeroutput">try_convert_to</code> in two ways:</p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem"><p>overload the <code class="computeroutput">try_assign_to</code> on any namespace found by ADL from the <code class="computeroutput">Source</code> or the <code class="computeroutput">Target</code>. A trick is used to overload on the return type by adding a dummy parameter depending on the <code class="computeroutput">Target</code>.</p></li>
<li class="listitem"><p>partially specialize the <code class="computeroutput"><a class="link" href="boost/conversion/try_converter_cp.html" title="Struct template try_converter_cp">boost::conversion::try_converter_cp</a></code> struct.</p></li>
</ul></div>
<p>
</p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>As we can not add new functions on the <code class="computeroutput">std</code> namespace, partial specialization is the only option in these cases. </p></td></tr>
</table></div>
<p>
</p>
<pre class="synopsis"><span class="keyword">namespace</span> <span class="identifier">boost</span> <span class="special">{</span>
  <span class="keyword">namespace</span> <span class="identifier">conversion</span> <span class="special">{</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> Target<span class="special">,</span> <span class="keyword">typename</span> Source<span class="special">,</span> <span class="keyword">typename</span> Enable <span class="special">=</span> <span class="keyword">void</span><span class="special">&gt;</span> 
      <span class="keyword">struct</span> <a class="link" href="boost/conversion/try_converter_cp.html" title="Struct template try_converter_cp">try_converter_cp</a><span class="special">;</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> Target<span class="special">,</span> <span class="keyword">typename</span> Source<span class="special">,</span> <span class="keyword">typename</span> Enable <span class="special">=</span> <span class="keyword">void</span><span class="special">&gt;</span> 
      <span class="keyword">struct</span> <a class="link" href="boost/conversion/try_converter.html" title="Struct template try_converter">try_converter</a><span class="special">;</span>

    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> Target<span class="special">,</span> <span class="keyword">typename</span> Source<span class="special">&gt;</span> 
      <span class="keyword">struct</span> <a class="link" href="boost/conversion/try_converter_Target__S_idp16369472.html" title="Struct template try_converter&lt;Target, Source, requires(ExtrinsicallyExplicitConvertible&lt; Source, Target &gt;)&gt;">try_converter</a><span class="special">&lt;</span><span class="identifier">Target</span><span class="special">,</span> <span class="identifier">Source</span><span class="special">,</span> <span class="identifier">requires</span><span class="special">(</span><span class="identifier">ExtrinsicallyExplicitConvertible</span><span class="special">&lt;</span> <span class="identifier">Source</span><span class="special">,</span> <span class="identifier">Target</span> <span class="special">&gt;</span><span class="special">)</span><span class="special">&gt;</span><span class="special">;</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> Target<span class="special">,</span> <span class="keyword">typename</span> Source<span class="special">&gt;</span> 
      <span class="identifier">enable_if_c</span><span class="special">&lt;</span> <span class="identifier">is_extrinsically_try_convertible_tagged</span><span class="special">&lt;</span> <span class="identifier">Source</span><span class="special">,</span> <span class="identifier">Target</span> <span class="special">&gt;</span><span class="special">::</span><span class="identifier">value</span><span class="special">,</span> <span class="identifier">optional</span><span class="special">&lt;</span> <span class="identifier">Target</span> <span class="special">&gt;</span> <span class="special">&gt;</span><span class="special">::</span><span class="identifier">type</span> 
      <a class="link" href="boost/conversion/try_convert_to.html" title="Function template try_convert_to"><span class="identifier">try_convert_to</span></a><span class="special">(</span><span class="identifier">Source</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="special">)</span><span class="special">;</span>
  <span class="special">}</span>
<span class="special">}</span></pre>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="c___standard_classes_specializations"></a>C++ Standard classes specializations</h3></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="index.html#header.boost.conversion.std.pair_hpp">Header &lt;boost/conversion/std/pair.hpp&gt;</a></span></dt>
<dd><dl></dl></dd>
<dt><span class="section"><a href="index.html#header.boost.conversion.std.string_hpp">Header &lt;boost/conversion/std/string.hpp&gt;</a></span></dt>
<dd><dl></dl></dd>
<dt><span class="section"><a href="index.html#header.boost.conversion.std.vector_hpp">Header &lt;boost/conversion/std/vector.hpp&gt;</a></span></dt>
<dd><dl></dl></dd>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="header.boost.conversion.std.pair_hpp"></a>Header &lt;<a href="../../../../boost/conversion/std/pair.hpp" target="_top">boost/conversion/std/pair.hpp</a>&gt;</h4></div></div></div>
<p>Include this file when using conversions between <code class="computeroutput">std::pair&lt;&gt;</code> of convertible types. </p>
<pre class="synopsis"><span class="keyword">namespace</span> <span class="identifier">boost</span> <span class="special">{</span>
  <span class="keyword">struct</span> <a class="link" href="boost/trick_pair.html" title="Struct trick_pair">trick_pair</a><span class="special">;</span>
  <span class="keyword">namespace</span> <span class="identifier">conversion</span> <span class="special">{</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> T1<span class="special">,</span> <span class="keyword">typename</span> T2<span class="special">,</span> <span class="keyword">typename</span> S1<span class="special">,</span> <span class="keyword">typename</span> S2<span class="special">&gt;</span> 
      <span class="keyword">struct</span> <a class="link" href="boost/conversion/implicit_converter_cp_s_idp15793936.html" title="Struct template implicit_converter_cp&lt;std::pair&lt; T1, T2 &gt;, std::pair&lt; S1, S2 &gt;, requires(ExtrinsicallyConvertible&lt; S1, T1 &gt; &amp;&amp;ExtrinsicallyConvertible&lt; S2, T2 &gt;)&gt;">implicit_converter_cp</a><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&lt;</span> <span class="identifier">T1</span><span class="special">,</span> <span class="identifier">T2</span> <span class="special">&gt;</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&lt;</span> <span class="identifier">S1</span><span class="special">,</span> <span class="identifier">S2</span> <span class="special">&gt;</span><span class="special">,</span> <span class="identifier">requires</span><span class="special">(</span><span class="identifier">ExtrinsicallyConvertible</span><span class="special">&lt;</span> <span class="identifier">S1</span><span class="special">,</span> <span class="identifier">T1</span> <span class="special">&gt;</span> <span class="special">&amp;&amp;</span><span class="identifier">ExtrinsicallyConvertible</span><span class="special">&lt;</span> <span class="identifier">S2</span><span class="special">,</span> <span class="identifier">T2</span> <span class="special">&gt;</span><span class="special">)</span><span class="special">&gt;</span><span class="special">;</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> T1<span class="special">,</span> <span class="keyword">typename</span> T2<span class="special">,</span> <span class="keyword">typename</span> S1<span class="special">,</span> <span class="keyword">typename</span> S2<span class="special">&gt;</span> 
      <span class="keyword">struct</span> <a class="link" href="boost/conversion/assigner_cp_std_pair_T1_idp15801328.html" title="Struct template assigner_cp&lt;std::pair&lt; T1, T2 &gt;, std::pair&lt; S1, S2 &gt;, requires(ExtrinsicallyConvertible&lt; S1, T1 &gt; &amp;&amp;ExtrinsicallyConvertible&lt; S2, T2 &gt;)&gt;">assigner_cp</a><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&lt;</span> <span class="identifier">T1</span><span class="special">,</span> <span class="identifier">T2</span> <span class="special">&gt;</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&lt;</span> <span class="identifier">S1</span><span class="special">,</span> <span class="identifier">S2</span> <span class="special">&gt;</span><span class="special">,</span> <span class="identifier">requires</span><span class="special">(</span><span class="identifier">ExtrinsicallyConvertible</span><span class="special">&lt;</span> <span class="identifier">S1</span><span class="special">,</span> <span class="identifier">T1</span> <span class="special">&gt;</span> <span class="special">&amp;&amp;</span><span class="identifier">ExtrinsicallyConvertible</span><span class="special">&lt;</span> <span class="identifier">S2</span><span class="special">,</span> <span class="identifier">T2</span> <span class="special">&gt;</span><span class="special">)</span><span class="special">&gt;</span><span class="special">;</span>
  <span class="special">}</span>
<span class="special">}</span></pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="header.boost.conversion.std.string_hpp"></a>Header &lt;<a href="../../../../boost/conversion/std/string.hpp" target="_top">boost/conversion/std/string.hpp</a>&gt;</h4></div></div></div>
<p>Include this file when using conversions from/to <code class="computeroutput">std::string</code>. </p>
<pre class="synopsis"><span class="keyword">namespace</span> <span class="identifier">boost</span> <span class="special">{</span>
  <span class="keyword">struct</span> <a class="link" href="boost/trick_string.html" title="Struct trick_string">trick_string</a><span class="special">;</span>
  <span class="keyword">namespace</span> <span class="identifier">conversion</span> <span class="special">{</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> T<span class="special">,</span> <span class="keyword">typename</span> CharT<span class="special">,</span> <span class="keyword">typename</span> Traits<span class="special">,</span> <span class="keyword">typename</span> Alloc<span class="special">&gt;</span> 
      <span class="keyword">struct</span> <a class="link" href="boost/conversion/explicit_converter_cp_s_idp15811632.html" title="Struct template explicit_converter_cp&lt;std::basic_string&lt; CharT, Traits, Alloc &gt;, T&gt;">explicit_converter_cp</a><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">basic_string</span><span class="special">&lt;</span> <span class="identifier">CharT</span><span class="special">,</span> <span class="identifier">Traits</span><span class="special">,</span> <span class="identifier">Alloc</span> <span class="special">&gt;</span><span class="special">,</span> <span class="identifier">T</span><span class="special">&gt;</span><span class="special">;</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> T<span class="special">,</span> <span class="keyword">typename</span> CharT<span class="special">,</span> <span class="keyword">typename</span> Traits<span class="special">,</span> <span class="keyword">typename</span> Alloc<span class="special">&gt;</span> 
      <span class="keyword">struct</span> <a class="link" href="boost/conversion/explicit_converter_cp_T_idp15817872.html" title="Struct template explicit_converter_cp&lt;T, std::basic_string&lt; CharT, Traits, Alloc &gt;&gt;">explicit_converter_cp</a><span class="special">&lt;</span><span class="identifier">T</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">basic_string</span><span class="special">&lt;</span> <span class="identifier">CharT</span><span class="special">,</span> <span class="identifier">Traits</span><span class="special">,</span> <span class="identifier">Alloc</span> <span class="special">&gt;</span><span class="special">&gt;</span><span class="special">;</span>
  <span class="special">}</span>
<span class="special">}</span></pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="header.boost.conversion.std.vector_hpp"></a>Header &lt;<a href="../../../../boost/conversion/std/vector.hpp" target="_top">boost/conversion/std/vector.hpp</a>&gt;</h4></div></div></div>
<p>Include this file when using conversions between <code class="computeroutput">std::vector&lt;&gt;</code> of convertible types. </p>
<pre class="synopsis"><span class="keyword">namespace</span> <span class="identifier">boost</span> <span class="special">{</span>
  <span class="keyword">struct</span> <a class="link" href="boost/trick_vector.html" title="Struct trick_vector">trick_vector</a><span class="special">;</span>
  <span class="keyword">namespace</span> <span class="identifier">conversion</span> <span class="special">{</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> T1<span class="special">,</span> <span class="keyword">typename</span> A1<span class="special">,</span> <span class="keyword">typename</span> T2<span class="special">,</span> <span class="keyword">typename</span> A2<span class="special">&gt;</span> 
      <span class="keyword">struct</span> <a class="link" href="boost/conversion/implicit_converter_cp_s_idp15826608.html" title="Struct template implicit_converter_cp&lt;std::vector&lt; T1, A1 &gt;, std::vector&lt; T2, A2 &gt;, requiresExtrinsicallyAssignable&lt; T1, T2 &gt;)&gt;">implicit_converter_cp</a><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span> <span class="identifier">T1</span><span class="special">,</span> <span class="identifier">A1</span> <span class="special">&gt;</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span> <span class="identifier">T2</span><span class="special">,</span> <span class="identifier">A2</span> <span class="special">&gt;</span><span class="special">,</span> <span class="identifier">requiresExtrinsicallyAssignable</span><span class="special">&lt;</span> <span class="identifier">T1</span><span class="special">,</span> <span class="identifier">T2</span> <span class="special">&gt;</span><span class="special">)</span><span class="special">&gt;</span><span class="special">;</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> T1<span class="special">,</span> <span class="keyword">typename</span> A1<span class="special">,</span> <span class="keyword">typename</span> T2<span class="special">,</span> <span class="keyword">typename</span> A2<span class="special">&gt;</span> 
      <span class="keyword">struct</span> <a class="link" href="boost/conversion/assigner_cp_std_vector__idp15833744.html" title="Struct template assigner_cp&lt;std::vector&lt; T1, A1 &gt;, std::vector&lt; T2, A2 &gt;, requiresExtrinsicallyAssignable&lt; T1, T2 &gt;)&gt;">assigner_cp</a><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span> <span class="identifier">T1</span><span class="special">,</span> <span class="identifier">A1</span> <span class="special">&gt;</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span> <span class="identifier">T2</span><span class="special">,</span> <span class="identifier">A2</span> <span class="special">&gt;</span><span class="special">,</span> <span class="identifier">requiresExtrinsicallyAssignable</span><span class="special">&lt;</span> <span class="identifier">T1</span><span class="special">,</span> <span class="identifier">T2</span> <span class="special">&gt;</span><span class="special">)</span><span class="special">&gt;</span><span class="special">;</span>
  <span class="special">}</span>
<span class="special">}</span></pre>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_classes_specializations"></a>Boost classes specializations</h3></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="index.html#header.boost.conversion.boost.array_hpp">Header &lt;boost/conversion/boost/array.hpp&gt;</a></span></dt>
<dd><dl></dl></dd>
<dt><span class="section"><a href="index.html#header.boost.conversion.boost.chrono_duration_to_posix_time_duration_hpp">Header &lt;boost/conversion/boost/chrono_duration_to_posix_time_duration.hpp&gt;</a></span></dt>
<dd><dl></dl></dd>
<dt><span class="section"><a href="index.html#header.boost.conversion.boost.chrono_posix_time_hpp">Header &lt;boost/conversion/boost/chrono_posix_time.hpp&gt;</a></span></dt>
<dt><span class="section"><a href="index.html#header.boost.conversion.boost.chrono_time_point_to_posix_time_ptime_hpp">Header &lt;boost/conversion/boost/chrono_time_point_to_posix_time_ptime.hpp&gt;</a></span></dt>
<dd><dl></dl></dd>
<dt><span class="section"><a href="index.html#header.boost.conversion.boost.interval_hpp">Header &lt;boost/conversion/boost/interval.hpp&gt;</a></span></dt>
<dd><dl></dl></dd>
<dt><span class="section"><a href="index.html#header.boost.conversion.boost.optional_hpp">Header &lt;boost/conversion/boost/optional.hpp&gt;</a></span></dt>
<dd><dl></dl></dd>
<dt><span class="section"><a href="index.html#header.boost.conversion.boost.rational_hpp">Header &lt;boost/conversion/boost/rational.hpp&gt;</a></span></dt>
<dd><dl></dl></dd>
<dt><span class="section"><a href="index.html#header.boost.conversion.boost.tuple_hpp">Header &lt;boost/conversion/boost/tuple.hpp&gt;</a></span></dt>
<dd><dl></dl></dd>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="header.boost.conversion.boost.array_hpp"></a>Header &lt;<a href="../../../../boost/conversion/boost/array.hpp" target="_top">boost/conversion/boost/array.hpp</a>&gt;</h4></div></div></div>
<p>Include this file when using conversions between <code class="computeroutput">boost::array&lt;&gt;</code> of convertible types. </p>
<pre class="synopsis"><span class="keyword">namespace</span> <span class="identifier">boost</span> <span class="special">{</span>
  <span class="keyword">struct</span> <a class="link" href="boost/trick_array.html" title="Struct trick_array">trick_array</a><span class="special">;</span>
  <span class="keyword">namespace</span> <span class="identifier">conversion</span> <span class="special">{</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> Target<span class="special">,</span> <span class="keyword">typename</span> Source<span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> N<span class="special">&gt;</span> 
      <span class="keyword">struct</span> <a class="link" href="boost/conversion/implicit_converter_cp_a_idp15507168.html" title="Struct template implicit_converter_cp&lt;array&lt; Target, N &gt;, array&lt; Source, N &gt;, requires(ExtrinsicallyAssignable&lt; Target, Source &gt;)&gt;">implicit_converter_cp</a><span class="special">&lt;</span><span class="identifier">array</span><span class="special">&lt;</span> <span class="identifier">Target</span><span class="special">,</span> <span class="identifier">N</span> <span class="special">&gt;</span><span class="special">,</span> <span class="identifier">array</span><span class="special">&lt;</span> <span class="identifier">Source</span><span class="special">,</span> <span class="identifier">N</span> <span class="special">&gt;</span><span class="special">,</span> <span class="identifier">requires</span><span class="special">(</span><span class="identifier">ExtrinsicallyAssignable</span><span class="special">&lt;</span> <span class="identifier">Target</span><span class="special">,</span> <span class="identifier">Source</span> <span class="special">&gt;</span><span class="special">)</span><span class="special">&gt;</span><span class="special">;</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> Target<span class="special">,</span> <span class="keyword">typename</span> Source<span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> N<span class="special">&gt;</span> 
      <span class="keyword">struct</span> <a class="link" href="boost/conversion/assigner_cp_array_Targe_idp15515328.html" title="Struct template assigner_cp&lt;array&lt; Target, N &gt;, array&lt; Source, N &gt;, requires(ExtrinsicallyAssignable&lt; Target, Source &gt; &amp;&amp;!Assignable&lt; Target, Source &gt;)&gt;">assigner_cp</a><span class="special">&lt;</span><span class="identifier">array</span><span class="special">&lt;</span> <span class="identifier">Target</span><span class="special">,</span> <span class="identifier">N</span> <span class="special">&gt;</span><span class="special">,</span> <span class="identifier">array</span><span class="special">&lt;</span> <span class="identifier">Source</span><span class="special">,</span> <span class="identifier">N</span> <span class="special">&gt;</span><span class="special">,</span> <span class="identifier">requires</span><span class="special">(</span><span class="identifier">ExtrinsicallyAssignable</span><span class="special">&lt;</span> <span class="identifier">Target</span><span class="special">,</span> <span class="identifier">Source</span> <span class="special">&gt;</span> <span class="special">&amp;&amp;</span><span class="special">!</span><span class="identifier">Assignable</span><span class="special">&lt;</span> <span class="identifier">Target</span><span class="special">,</span> <span class="identifier">Source</span> <span class="special">&gt;</span><span class="special">)</span><span class="special">&gt;</span><span class="special">;</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> Target<span class="special">,</span> <span class="keyword">typename</span> Source<span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> N<span class="special">&gt;</span> 
      <span class="keyword">struct</span> <a class="link" href="boost/conversion/assigner_cp_array_Targe_idp15524064.html" title="Struct template assigner_cp&lt;array&lt; Target, N &gt;, array&lt; Source, N &gt;, requites(ExtrinsicallyAssignable&lt; Target, Source &gt; &amp;&amp;Assignable&lt; Target, Source &gt;)&gt;">assigner_cp</a><span class="special">&lt;</span><span class="identifier">array</span><span class="special">&lt;</span> <span class="identifier">Target</span><span class="special">,</span> <span class="identifier">N</span> <span class="special">&gt;</span><span class="special">,</span> <span class="identifier">array</span><span class="special">&lt;</span> <span class="identifier">Source</span><span class="special">,</span> <span class="identifier">N</span> <span class="special">&gt;</span><span class="special">,</span> <span class="identifier">requites</span><span class="special">(</span><span class="identifier">ExtrinsicallyAssignable</span><span class="special">&lt;</span> <span class="identifier">Target</span><span class="special">,</span> <span class="identifier">Source</span> <span class="special">&gt;</span> <span class="special">&amp;&amp;</span><span class="identifier">Assignable</span><span class="special">&lt;</span> <span class="identifier">Target</span><span class="special">,</span> <span class="identifier">Source</span> <span class="special">&gt;</span><span class="special">)</span><span class="special">&gt;</span><span class="special">;</span>
  <span class="special">}</span>
<span class="special">}</span></pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="header.boost.conversion.boost.chrono_duration_to_posix_time_duration_hpp"></a>Header &lt;<a href="../../../../boost/conversion/boost/chrono_duration_to_posix_time_duration.hpp" target="_top">boost/conversion/boost/chrono_duration_to_posix_time_duration.hpp</a>&gt;</h4></div></div></div>
<p>Include this file when using conversions between <code class="computeroutput">boost::posix_time::time_duration</code> and <code class="computeroutput">boost::chrono::duration&lt;&gt;</code>. </p>
<pre class="synopsis"><span class="keyword">namespace</span> <span class="identifier">boost</span> <span class="special">{</span>
  <span class="keyword">struct</span> <a class="link" href="boost/trick_chrono_duration.html" title="Struct trick_chrono_duration">trick_chrono_duration</a><span class="special">;</span>
  <span class="keyword">namespace</span> <span class="identifier">conversion</span> <span class="special">{</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> Rep<span class="special">,</span> <span class="keyword">typename</span> Period<span class="special">&gt;</span> 
      <span class="keyword">struct</span> <a class="link" href="boost/conversion/implicit_converter_cp_p_idp15535696.html" title="Struct template implicit_converter_cp&lt;posix_time::time_duration, chrono::duration&lt; Rep, Period &gt;&gt;">implicit_converter_cp</a><span class="special">&lt;</span><span class="identifier">posix_time</span><span class="special">::</span><span class="identifier">time_duration</span><span class="special">,</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span> <span class="special">&gt;</span><span class="special">&gt;</span><span class="special">;</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> Rep<span class="special">,</span> <span class="keyword">typename</span> Period<span class="special">&gt;</span> 
      <span class="keyword">struct</span> <a class="link" href="boost/conversion/implicit_converter_cp_c_idp15542208.html" title="Struct template implicit_converter_cp&lt;chrono::duration&lt; Rep, Period &gt;, posix_time::time_duration&gt;">implicit_converter_cp</a><span class="special">&lt;</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span> <span class="special">&gt;</span><span class="special">,</span> <span class="identifier">posix_time</span><span class="special">::</span><span class="identifier">time_duration</span><span class="special">&gt;</span><span class="special">;</span>
  <span class="special">}</span>
<span class="special">}</span></pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="header.boost.conversion.boost.chrono_posix_time_hpp"></a>Header &lt;<a href="../../../../boost/conversion/boost/chrono_posix_time.hpp" target="_top">boost/conversion/boost/chrono_posix_time.hpp</a>&gt;</h4></div></div></div>
<p>Include this file when using conversions between <code class="computeroutput">boost::posix_time</code> ptime and time_duration and <code class="computeroutput">boost::chrono</code> time_point and duration respectively. </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="header.boost.conversion.boost.chrono_time_point_to_posix_time_ptime_hpp"></a>Header &lt;<a href="../../../../boost/conversion/boost/chrono_time_point_to_posix_time_ptime.hpp" target="_top">boost/conversion/boost/chrono_time_point_to_posix_time_ptime.hpp</a>&gt;</h4></div></div></div>
<p>Include this file when using conversions between <code class="computeroutput">boost::ptime</code> and <code class="computeroutput">boost::chrono::time_point&lt;&gt;</code>. </p>
<pre class="synopsis"><span class="keyword">namespace</span> <span class="identifier">boost</span> <span class="special">{</span>
  <span class="keyword">struct</span> <a class="link" href="boost/trick_chrono_time_point.html" title="Struct trick_chrono_time_point">trick_chrono_time_point</a><span class="special">;</span>
  <span class="keyword">namespace</span> <span class="identifier">conversion</span> <span class="special">{</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> Clock<span class="special">,</span> <span class="keyword">typename</span> Duration<span class="special">&gt;</span> 
      <span class="keyword">struct</span> <a class="link" href="boost/conversion/implicit_converter_cp_p_idp15553440.html" title="Struct template implicit_converter_cp&lt;posix_time::ptime, chrono::time_point&lt; Clock, Duration &gt;&gt;">implicit_converter_cp</a><span class="special">&lt;</span><span class="identifier">posix_time</span><span class="special">::</span><span class="identifier">ptime</span><span class="special">,</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span> <span class="special">&gt;</span><span class="special">&gt;</span><span class="special">;</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> Clock<span class="special">,</span> <span class="keyword">typename</span> Duration<span class="special">&gt;</span> 
      <span class="keyword">struct</span> <a class="link" href="boost/conversion/implicit_converter_cp_c_idp15557696.html" title="Struct template implicit_converter_cp&lt;chrono::time_point&lt; Clock, Duration &gt;, posix_time::ptime&gt;">implicit_converter_cp</a><span class="special">&lt;</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span> <span class="special">&gt;</span><span class="special">,</span> <span class="identifier">posix_time</span><span class="special">::</span><span class="identifier">ptime</span><span class="special">&gt;</span><span class="special">;</span>
  <span class="special">}</span>
<span class="special">}</span></pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="header.boost.conversion.boost.interval_hpp"></a>Header &lt;<a href="../../../../boost/conversion/boost/interval.hpp" target="_top">boost/conversion/boost/interval.hpp</a>&gt;</h4></div></div></div>
<p>Include this file when using conversions between <code class="computeroutput">boost::numeric::interval&lt;&gt;</code> of convertible types. </p>
<pre class="synopsis"><span class="keyword">namespace</span> <span class="identifier">boost</span> <span class="special">{</span>
  <span class="keyword">struct</span> <a class="link" href="boost/trick_numeric_interval.html" title="Struct trick_numeric_interval">trick_numeric_interval</a><span class="special">;</span>
  <span class="keyword">namespace</span> <span class="identifier">conversion</span> <span class="special">{</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> Target<span class="special">,</span> <span class="keyword">typename</span> PTarget<span class="special">,</span> <span class="keyword">typename</span> Source<span class="special">,</span> 
             <span class="keyword">typename</span> PSource<span class="special">&gt;</span> 
      <span class="keyword">struct</span> <a class="link" href="boost/conversion/implicit_converter_cp_n_idp15564384.html" title="Struct template implicit_converter_cp&lt;numeric::interval&lt; Target, PTarget &gt;, numeric::interval&lt; Source, PSource &gt;, requires(ExtrinsicallyConvertible&lt; Source, Target &gt;)&gt;">implicit_converter_cp</a><span class="special">&lt;</span><span class="identifier">numeric</span><span class="special">::</span><span class="identifier">interval</span><span class="special">&lt;</span> <span class="identifier">Target</span><span class="special">,</span> <span class="identifier">PTarget</span> <span class="special">&gt;</span><span class="special">,</span> <span class="identifier">numeric</span><span class="special">::</span><span class="identifier">interval</span><span class="special">&lt;</span> <span class="identifier">Source</span><span class="special">,</span> <span class="identifier">PSource</span> <span class="special">&gt;</span><span class="special">,</span> <span class="identifier">requires</span><span class="special">(</span><span class="identifier">ExtrinsicallyConvertible</span><span class="special">&lt;</span> <span class="identifier">Source</span><span class="special">,</span> <span class="identifier">Target</span> <span class="special">&gt;</span><span class="special">)</span><span class="special">&gt;</span><span class="special">;</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> Target<span class="special">,</span> <span class="keyword">typename</span> PTarget<span class="special">,</span> <span class="keyword">typename</span> Source<span class="special">,</span> 
             <span class="keyword">typename</span> PSource<span class="special">&gt;</span> 
      <span class="keyword">struct</span> <a class="link" href="boost/conversion/assigner_cp_numeric_int_idp15572224.html" title="Struct template assigner_cp&lt;numeric::interval&lt; Target, PTarget &gt;, numeric::interval&lt; Source, PSource &gt;, requires(ExtrinsicallyConvertible&lt; Source, Target &gt;)&gt;">assigner_cp</a><span class="special">&lt;</span><span class="identifier">numeric</span><span class="special">::</span><span class="identifier">interval</span><span class="special">&lt;</span> <span class="identifier">Target</span><span class="special">,</span> <span class="identifier">PTarget</span> <span class="special">&gt;</span><span class="special">,</span> <span class="identifier">numeric</span><span class="special">::</span><span class="identifier">interval</span><span class="special">&lt;</span> <span class="identifier">Source</span><span class="special">,</span> <span class="identifier">PSource</span> <span class="special">&gt;</span><span class="special">,</span> <span class="identifier">requires</span><span class="special">(</span><span class="identifier">ExtrinsicallyConvertible</span><span class="special">&lt;</span> <span class="identifier">Source</span><span class="special">,</span> <span class="identifier">Target</span> <span class="special">&gt;</span><span class="special">)</span><span class="special">&gt;</span><span class="special">;</span>
  <span class="special">}</span>
<span class="special">}</span></pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="header.boost.conversion.boost.optional_hpp"></a>Header &lt;<a href="../../../../boost/conversion/boost/optional.hpp" target="_top">boost/conversion/boost/optional.hpp</a>&gt;</h4></div></div></div>
<p>Include this file when using conversions between <code class="computeroutput">boost::optional&lt;&gt;</code> of convertible types. </p>
<pre class="synopsis"><span class="keyword">namespace</span> <span class="identifier">boost</span> <span class="special">{</span>
  <span class="keyword">struct</span> <a class="link" href="boost/trick_optional.html" title="Struct trick_optional">trick_optional</a><span class="special">;</span>
  <span class="keyword">namespace</span> <span class="identifier">conversion</span> <span class="special">{</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> Target<span class="special">,</span> <span class="keyword">typename</span> Source<span class="special">&gt;</span> 
      <span class="keyword">struct</span> <a class="link" href="boost/conversion/implicit_converter_cp_o_idp15581248.html" title="Struct template implicit_converter_cp&lt;optional&lt; Target &gt;, optional&lt; Source &gt;, requires(ExtrinsicallyConvertible&lt; Source, Target &gt;)&gt;">implicit_converter_cp</a><span class="special">&lt;</span><span class="identifier">optional</span><span class="special">&lt;</span> <span class="identifier">Target</span> <span class="special">&gt;</span><span class="special">,</span> <span class="identifier">optional</span><span class="special">&lt;</span> <span class="identifier">Source</span> <span class="special">&gt;</span><span class="special">,</span> <span class="identifier">requires</span><span class="special">(</span><span class="identifier">ExtrinsicallyConvertible</span><span class="special">&lt;</span> <span class="identifier">Source</span><span class="special">,</span> <span class="identifier">Target</span> <span class="special">&gt;</span><span class="special">)</span><span class="special">&gt;</span><span class="special">;</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> Target<span class="special">,</span> <span class="keyword">typename</span> Source<span class="special">&gt;</span> 
      <span class="keyword">struct</span> <a class="link" href="boost/conversion/implicit_converter_cp_o_idp15588240.html" title="Struct template implicit_converter_cp&lt;optional&lt; Target &gt;, Source, requires(ExtrinsicallyConvertible&lt; Source, Target &gt; &amp;&amp;!Optional&lt; Source &gt;)&gt;">implicit_converter_cp</a><span class="special">&lt;</span><span class="identifier">optional</span><span class="special">&lt;</span> <span class="identifier">Target</span> <span class="special">&gt;</span><span class="special">,</span> <span class="identifier">Source</span><span class="special">,</span> <span class="identifier">requires</span><span class="special">(</span><span class="identifier">ExtrinsicallyConvertible</span><span class="special">&lt;</span> <span class="identifier">Source</span><span class="special">,</span> <span class="identifier">Target</span> <span class="special">&gt;</span> <span class="special">&amp;&amp;</span><span class="special">!</span><span class="identifier">Optional</span><span class="special">&lt;</span> <span class="identifier">Source</span> <span class="special">&gt;</span><span class="special">)</span><span class="special">&gt;</span><span class="special">;</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> Target<span class="special">,</span> <span class="keyword">typename</span> Source<span class="special">&gt;</span> 
      <span class="keyword">struct</span> <a class="link" href="boost/conversion/explicit_converter_cp_o_idp15596624.html" title="Struct template explicit_converter_cp&lt;optional&lt; Target &gt;, Source, requires(ExtrinsicallyExplicit_convertible&lt; Source, Target &gt; &amp;&amp;!Optional&lt; Source &gt;)&gt;">explicit_converter_cp</a><span class="special">&lt;</span><span class="identifier">optional</span><span class="special">&lt;</span> <span class="identifier">Target</span> <span class="special">&gt;</span><span class="special">,</span> <span class="identifier">Source</span><span class="special">,</span> <span class="identifier">requires</span><span class="special">(</span><span class="identifier">ExtrinsicallyExplicit_convertible</span><span class="special">&lt;</span> <span class="identifier">Source</span><span class="special">,</span> <span class="identifier">Target</span> <span class="special">&gt;</span> <span class="special">&amp;&amp;</span><span class="special">!</span><span class="identifier">Optional</span><span class="special">&lt;</span> <span class="identifier">Source</span> <span class="special">&gt;</span><span class="special">)</span><span class="special">&gt;</span><span class="special">;</span>
  <span class="special">}</span>
<span class="special">}</span></pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="header.boost.conversion.boost.rational_hpp"></a>Header &lt;<a href="../../../../boost/conversion/boost/rational.hpp" target="_top">boost/conversion/boost/rational.hpp</a>&gt;</h4></div></div></div>
<p>Include this file when using conversions between <code class="computeroutput">boost::rational&lt;&gt;</code> of convertible types. </p>
<pre class="synopsis"><span class="keyword">namespace</span> <span class="identifier">boost</span> <span class="special">{</span>
  <span class="keyword">struct</span> <a class="link" href="boost/trick_rational.html" title="Struct trick_rational">trick_rational</a><span class="special">;</span>
  <span class="keyword">namespace</span> <span class="identifier">conversion</span> <span class="special">{</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> Target<span class="special">,</span> <span class="keyword">typename</span> Source<span class="special">&gt;</span> 
      <span class="keyword">struct</span> <a class="link" href="boost/conversion/implicit_converter_cp_r_idp15607504.html" title="Struct template implicit_converter_cp&lt;rational&lt; Target &gt;, rational&lt; Source &gt;, requires(ExtrinsicallyConvertible&lt; Source, Target &gt;)&gt;">implicit_converter_cp</a><span class="special">&lt;</span><span class="identifier">rational</span><span class="special">&lt;</span> <span class="identifier">Target</span> <span class="special">&gt;</span><span class="special">,</span> <span class="identifier">rational</span><span class="special">&lt;</span> <span class="identifier">Source</span> <span class="special">&gt;</span><span class="special">,</span> <span class="identifier">requires</span><span class="special">(</span><span class="identifier">ExtrinsicallyConvertible</span><span class="special">&lt;</span> <span class="identifier">Source</span><span class="special">,</span> <span class="identifier">Target</span> <span class="special">&gt;</span><span class="special">)</span><span class="special">&gt;</span><span class="special">;</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> Target<span class="special">,</span> <span class="keyword">typename</span> Source<span class="special">&gt;</span> 
      <span class="keyword">struct</span> <a class="link" href="boost/conversion/assigner_cp_rational_Ta_idp15613920.html" title="Struct template assigner_cp&lt;rational&lt; Target &gt;, rational&lt; Source &gt;, requires(ExtrinsicallyConvertible&lt; Source, Target &gt;)&gt;">assigner_cp</a><span class="special">&lt;</span><span class="identifier">rational</span><span class="special">&lt;</span> <span class="identifier">Target</span> <span class="special">&gt;</span><span class="special">,</span> <span class="identifier">rational</span><span class="special">&lt;</span> <span class="identifier">Source</span> <span class="special">&gt;</span><span class="special">,</span> <span class="identifier">requires</span><span class="special">(</span><span class="identifier">ExtrinsicallyConvertible</span><span class="special">&lt;</span> <span class="identifier">Source</span><span class="special">,</span> <span class="identifier">Target</span> <span class="special">&gt;</span><span class="special">)</span><span class="special">&gt;</span><span class="special">;</span>
  <span class="special">}</span>
<span class="special">}</span></pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="header.boost.conversion.boost.tuple_hpp"></a>Header &lt;<a href="../../../../boost/conversion/boost/tuple.hpp" target="_top">boost/conversion/boost/tuple.hpp</a>&gt;</h4></div></div></div>
<p>Include this file when using conversions between <code class="computeroutput">boost::fusion::tuple&lt;&gt;</code> of convertible types. </p>
<pre class="synopsis"><span class="keyword">namespace</span> <span class="identifier">boost</span> <span class="special">{</span>
  <span class="keyword">struct</span> <a class="link" href="boost/trick_fusion_tuple.html" title="Struct trick_fusion_tuple">trick_fusion_tuple</a><span class="special">;</span>
  <span class="keyword">namespace</span> <span class="identifier">conversion</span> <span class="special">{</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> T1<span class="special">,</span> <span class="keyword">typename</span> T2<span class="special">,</span> <span class="keyword">typename</span> S1<span class="special">,</span> <span class="keyword">typename</span> S2<span class="special">&gt;</span> 
      <span class="keyword">struct</span> <a class="link" href="boost/conversion/explicit_converter_cp_f_idp15621472.html" title="Struct template explicit_converter_cp&lt;fusion::tuple&lt; T1, T2 &gt;, fusion::tuple&lt; S1, S2 &gt;, requires(ExtrinsicallyConvertible&lt; S1, T1 &gt; &amp;&amp;ExtrinsicallyConvertible&lt; S2, T2 &gt;)&gt;">explicit_converter_cp</a><span class="special">&lt;</span><span class="identifier">fusion</span><span class="special">::</span><span class="identifier">tuple</span><span class="special">&lt;</span> <span class="identifier">T1</span><span class="special">,</span> <span class="identifier">T2</span> <span class="special">&gt;</span><span class="special">,</span> <span class="identifier">fusion</span><span class="special">::</span><span class="identifier">tuple</span><span class="special">&lt;</span> <span class="identifier">S1</span><span class="special">,</span> <span class="identifier">S2</span> <span class="special">&gt;</span><span class="special">,</span> <span class="identifier">requires</span><span class="special">(</span><span class="identifier">ExtrinsicallyConvertible</span><span class="special">&lt;</span> <span class="identifier">S1</span><span class="special">,</span> <span class="identifier">T1</span> <span class="special">&gt;</span> <span class="special">&amp;&amp;</span><span class="identifier">ExtrinsicallyConvertible</span><span class="special">&lt;</span> <span class="identifier">S2</span><span class="special">,</span> <span class="identifier">T2</span> <span class="special">&gt;</span><span class="special">)</span><span class="special">&gt;</span><span class="special">;</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> T1<span class="special">,</span> <span class="keyword">typename</span> T2<span class="special">,</span> <span class="keyword">typename</span> T3<span class="special">,</span> <span class="keyword">typename</span> S1<span class="special">,</span> <span class="keyword">typename</span> S2<span class="special">,</span> 
             <span class="keyword">typename</span> S3<span class="special">&gt;</span> 
      <span class="keyword">struct</span> <a class="link" href="boost/conversion/explicit_converter_cp_f_idp15627712.html" title="Struct template explicit_converter_cp&lt;fusion::tuple&lt; T1, T2, T3 &gt;, fusion::tuple&lt; S1, S2, S3 &gt;, requires(ExtrinsicallyConvertible&lt; S1, T1 &gt; &amp;&amp;ExtrinsicallyConvertible&lt; S2, T2 &gt; &amp;&amp;ExtrinsicallyConvertible&lt; S3, T3 &gt;)&gt;">explicit_converter_cp</a><span class="special">&lt;</span><span class="identifier">fusion</span><span class="special">::</span><span class="identifier">tuple</span><span class="special">&lt;</span> <span class="identifier">T1</span><span class="special">,</span> <span class="identifier">T2</span><span class="special">,</span> <span class="identifier">T3</span> <span class="special">&gt;</span><span class="special">,</span> <span class="identifier">fusion</span><span class="special">::</span><span class="identifier">tuple</span><span class="special">&lt;</span> <span class="identifier">S1</span><span class="special">,</span> <span class="identifier">S2</span><span class="special">,</span> <span class="identifier">S3</span> <span class="special">&gt;</span><span class="special">,</span> <span class="identifier">requires</span><span class="special">(</span><span class="identifier">ExtrinsicallyConvertible</span><span class="special">&lt;</span> <span class="identifier">S1</span><span class="special">,</span> <span class="identifier">T1</span> <span class="special">&gt;</span> <span class="special">&amp;&amp;</span><span class="identifier">ExtrinsicallyConvertible</span><span class="special">&lt;</span> <span class="identifier">S2</span><span class="special">,</span> <span class="identifier">T2</span> <span class="special">&gt;</span> <span class="special">&amp;&amp;</span><span class="identifier">ExtrinsicallyConvertible</span><span class="special">&lt;</span> <span class="identifier">S3</span><span class="special">,</span> <span class="identifier">T3</span> <span class="special">&gt;</span><span class="special">)</span><span class="special">&gt;</span><span class="special">;</span>
  <span class="special">}</span>
<span class="special">}</span></pre>
</div>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="boost.conversion.appendices"></a><a class="link" href="index.html#boost.conversion.appendices" title="Appendices">Appendices</a>
</h2></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="index.html#boost.conversion.appendices.history">Appendix: History</a></span></dt>
<dd><dl>
<dt><span class="section"><a href="index.html#boost.conversion.appendices.history.__version_0_6_0__july_16__2011__"><span class="bold"><strong>Version 0.6.0, July 16, 2011</strong></span> </a></span></dt>
<dt><span class="section"><a href="index.html#boost.conversion.appendices.history.__version_0_5_1__fefruary_20__2011__"><span class="bold"><strong>Version 0.5.1, Fefruary 20, 2011</strong></span> </a></span></dt>
<dt><span class="section"><a href="index.html#boost.conversion.appendices.history.__version_0_5_0__may_30__2010__"><span class="bold"><strong>Version 0.5.0, May 30, 2010</strong></span> </a></span></dt>
<dt><span class="section"><a href="index.html#boost.conversion.appendices.history.__version_0_4_0__october_27__2009__"><span class="bold"><strong>Version 0.4.0, October 27, 2009</strong></span> </a></span></dt>
<dt><span class="section"><a href="index.html#boost.conversion.appendices.history.__version_0_3_0__october_22__2009__"><span class="bold"><strong>Version 0.3.0, October 22, 2009</strong></span> </a></span></dt>
<dt><span class="section"><a href="index.html#boost.conversion.appendices.history.__version_0_2_0__mai_16__2009__"><span class="bold"><strong>Version 0.2.0, Mai 16, 2009</strong></span> </a></span></dt>
<dt><span class="section"><a href="index.html#boost.conversion.appendices.history.__version_0_1_0__april_16__2009__"><span class="bold"><strong>Version 0.1.0, April 16, 2009</strong></span> </a></span></dt>
</dl></dd>
<dt><span class="section"><a href="index.html#boost.conversion.appendices.rationale">Appendix: Design
      Rationale</a></span></dt>
<dt><span class="section"><a href="index.html#boost.conversion.appendices.implementation">Appendix:
      Implementation Notes</a></span></dt>
<dt><span class="section"><a href="index.html#boost.conversion.appendices.acknowledgements">Appendix:
      Acknowledgements</a></span></dt>
<dt><span class="section"><a href="index.html#boost.conversion.appendices.todo">Appendix : Future plans</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost.conversion.appendices.history"></a><a class="link" href="index.html#boost.conversion.appendices.history" title="Appendix: History">Appendix: History</a>
</h3></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="index.html#boost.conversion.appendices.history.__version_0_6_0__july_16__2011__"><span class="bold"><strong>Version 0.6.0, July 16, 2011</strong></span> </a></span></dt>
<dt><span class="section"><a href="index.html#boost.conversion.appendices.history.__version_0_5_1__fefruary_20__2011__"><span class="bold"><strong>Version 0.5.1, Fefruary 20, 2011</strong></span> </a></span></dt>
<dt><span class="section"><a href="index.html#boost.conversion.appendices.history.__version_0_5_0__may_30__2010__"><span class="bold"><strong>Version 0.5.0, May 30, 2010</strong></span> </a></span></dt>
<dt><span class="section"><a href="index.html#boost.conversion.appendices.history.__version_0_4_0__october_27__2009__"><span class="bold"><strong>Version 0.4.0, October 27, 2009</strong></span> </a></span></dt>
<dt><span class="section"><a href="index.html#boost.conversion.appendices.history.__version_0_3_0__october_22__2009__"><span class="bold"><strong>Version 0.3.0, October 22, 2009</strong></span> </a></span></dt>
<dt><span class="section"><a href="index.html#boost.conversion.appendices.history.__version_0_2_0__mai_16__2009__"><span class="bold"><strong>Version 0.2.0, Mai 16, 2009</strong></span> </a></span></dt>
<dt><span class="section"><a href="index.html#boost.conversion.appendices.history.__version_0_1_0__april_16__2009__"><span class="bold"><strong>Version 0.1.0, April 16, 2009</strong></span> </a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost.conversion.appendices.history.__version_0_6_0__july_16__2011__"></a><a class="link" href="index.html#boost.conversion.appendices.history.__version_0_6_0__july_16__2011__" title="Version 0.6.0, July 16, 2011"><span class="bold"><strong>Version 0.6.0, July 16, 2011</strong></span> </a>
</h4></div></div></div>
<p>
          This is a major evolution of the library.
        </p>
<p>
          <span class="bold"><strong>New Features:</strong></span>
        </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
              Added <code class="computeroutput"><span class="identifier">try_convert_to</span></code>,
              <code class="computeroutput"><span class="identifier">try_assign_to</span></code>, <code class="computeroutput"><span class="identifier">convert_to_or_fallback</span></code> functions.
            </li>
<li class="listitem">
              Added converter factory <code class="computeroutput"><span class="identifier">make_converter_to</span></code>.
            </li>
<li class="listitem">
              Added type traits <code class="computeroutput"><span class="identifier">is_extrinsically_convertible</span></code>
              and <code class="computeroutput"><span class="identifier">is_extrinsically_assignable</span></code>.
            </li>
<li class="listitem">
              Added <code class="computeroutput"><span class="identifier">convertible_to</span></code>,
              <code class="computeroutput"><span class="identifier">convertible_from</span></code> and
              <code class="computeroutput"><span class="identifier">assignable_to</span></code> wrappers
              and the corresponding <code class="computeroutput"><span class="identifier">implicitly</span></code>
              and <code class="computeroutput"><span class="identifier">lvalue</span></code> free functions.
            </li>
<li class="listitem">
              Added two levels of customization points <code class="computeroutput"><span class="identifier">converter</span></code><span class="emphasis"><em>`converter_cp`,
              `assigner'</em></span><code class="computeroutput"><span class="identifier">assigner_cp</span></code>,
              and so on to simplify the customizations for the users.
            </li>
<li class="listitem">
              On compilers supporting it the interface is now concept-based, for
              specialization or overloading.
            </li>
<li class="listitem">
<p class="simpara">
              Added type traits that have a better place in Boost.TypeTraits:
            </p>
<div class="itemizedlist"><ul class="itemizedlist" type="circle">
<li class="listitem">
                  <code class="computeroutput"><span class="identifier">is_assignable</span></code>,
                </li>
<li class="listitem">
                  <code class="computeroutput"><span class="identifier">is_copy_assignable</span></code>,
                </li>
<li class="listitem">
                  <code class="computeroutput"><span class="identifier">is_move_assignable</span></code>,
                </li>
<li class="listitem">
                  <code class="computeroutput"><span class="identifier">is_constructible</span></code>,
                </li>
<li class="listitem">
                  <code class="computeroutput"><span class="identifier">is_default_constructible</span></code>,
                </li>
<li class="listitem">
                  <code class="computeroutput"><span class="identifier">is_copy_constructible</span></code>,
                </li>
<li class="listitem">
                  <code class="computeroutput"><span class="identifier">is_move_constructible</span></code>,
                </li>
<li class="listitem">
                  <code class="computeroutput"><span class="identifier">is_explictly_convertible</span></code>.
                </li>
</ul></div>
</li>
</ul></div>
<p>
          <span class="bold"><strong>Deprecated Features:</strong></span>
        </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
              The customization point using ADL has been disabled as it makes the
              library more complex.
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">pack</span></code> will be removed
              before review as is not well designed, and a tuple of references should
              works as well.
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">convert_to_via</span></code> will
              be removed before review as don't really useful.
            </li>
<li class="listitem">
              <code class="computeroutput"><span class="identifier">mca</span></code> will be removed
              before review, the news <code class="computeroutput"><span class="identifier">implicitly</span></code>
              and <code class="computeroutput"><span class="identifier">lvalue</span></code> should be
              used..
            </li>
</ul></div>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost.conversion.appendices.history.__version_0_5_1__fefruary_20__2011__"></a><a class="link" href="index.html#boost.conversion.appendices.history.__version_0_5_1__fefruary_20__2011__" title="Version 0.5.1, Fefruary 20, 2011"><span class="bold"><strong>Version 0.5.1, Fefruary 20, 2011</strong></span> </a>
</h4></div></div></div>
<p>
          <span class="bold"><strong>Bug</strong></span>
        </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
              Fix bug on chain mca assignment.
            </li></ul></div>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost.conversion.appendices.history.__version_0_5_0__may_30__2010__"></a><a class="link" href="index.html#boost.conversion.appendices.history.__version_0_5_0__may_30__2010__" title="Version 0.5.0, May 30, 2010"><span class="bold"><strong>Version 0.5.0, May 30, 2010</strong></span> </a>
</h4></div></div></div>
<p>
          <span class="bold"><strong>New Features:</strong></span>
        </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
              Added a <code class="computeroutput"><span class="identifier">pack</span></code> function
              able to pack the <code class="computeroutput"><span class="identifier">Source</span></code>
              and the <code class="computeroutput"><span class="identifier">Target</span></code> constructor
              arguments in one parameter.
            </li>
<li class="listitem">
              Added conversion between <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span></code>
              of explicitly convertible types.
            </li>
<li class="listitem">
              Added <code class="computeroutput"><span class="identifier">is_convertible_to</span></code>
              meta-function. Inherits: If an imaginary lvalue of type <code class="computeroutput"><span class="identifier">From</span></code> is convertible to type <code class="computeroutput"><span class="identifier">To</span></code> using <code class="computeroutput"><span class="identifier">convert_to</span></code>
              then inherits from <code class="computeroutput"><span class="identifier">true_type</span></code>,
              otherwise inherits from <code class="computeroutput"><span class="identifier">false_type</span></code>.
            </li>
</ul></div>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">From</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">To</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">is_convertible</span> <span class="special">:</span> <span class="keyword">public</span> <span class="identifier">true_type</span><span class="special">-</span><span class="keyword">or</span><span class="special">-</span><span class="identifier">false_type</span> <span class="special">{};</span>
</pre>
<div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
              Added <code class="computeroutput"><span class="identifier">is_assignable_to</span></code>
              meta-function.
            </li></ul></div>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost.conversion.appendices.history.__version_0_4_0__october_27__2009__"></a><a class="link" href="index.html#boost.conversion.appendices.history.__version_0_4_0__october_27__2009__" title="Version 0.4.0, October 27, 2009"><span class="bold"><strong>Version 0.4.0, October 27, 2009</strong></span> </a>
</h4></div></div></div>
<p>
          <span class="emphasis"><em>Applying the same technique that <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">swap</span></code>
          applies making use of ADL</em></span>
        </p>
<p>
          <span class="bold"><strong>New Features:</strong></span>
        </p>
<p>
          A <code class="computeroutput"><span class="identifier">Source</span></code> class is convertible
          to a <code class="computeroutput"><span class="identifier">Target</span></code> class if:
        </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
              Either: A function with the signature <code class="computeroutput"><span class="identifier">convert_to</span><span class="special">&lt;</span><span class="identifier">Target</span><span class="special">&gt;(</span><span class="identifier">Source</span>
              <span class="keyword">const</span><span class="special">&amp;,</span>
              <span class="identifier">boost</span><span class="special">::</span><span class="identifier">dummy</span><span class="special">::</span><span class="identifier">type_tag</span><span class="special">&lt;</span><span class="identifier">To</span><span class="special">&gt;</span>
              <span class="keyword">const</span><span class="special">&amp;)</span></code>
              is available via argument dependent lookup
            </li>
<li class="listitem">
              Or: A template specialization of <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">conversion</span><span class="special">::</span><span class="identifier">convert_to</span><span class="special">&lt;</span><span class="identifier">Target</span><span class="special">,</span> <span class="identifier">Source</span><span class="special">&gt;</span></code> exists for <code class="computeroutput"><span class="identifier">Target</span></code>
              and <code class="computeroutput"><span class="identifier">Source</span></code>
            </li>
<li class="listitem">
              Or: <code class="computeroutput"><span class="identifier">Target</span></code> is copy
              constructible from <code class="computeroutput"><span class="identifier">Source</span></code>
              (default implementation)
            </li>
</ul></div>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost.conversion.appendices.history.__version_0_3_0__october_22__2009__"></a><a class="link" href="index.html#boost.conversion.appendices.history.__version_0_3_0__october_22__2009__" title="Version 0.3.0, October 22, 2009"><span class="bold"><strong>Version 0.3.0, October 22, 2009</strong></span> </a>
</h4></div></div></div>
<p>
          <span class="emphasis"><em>Changing the order of <code class="computeroutput"><span class="identifier">to</span></code>
          and <code class="computeroutput"><span class="identifier">from</span></code> parameters on
          <code class="computeroutput"><span class="identifier">assign_to</span></code> function + Added
          <code class="computeroutput"><span class="identifier">mca</span></code> function</em></span>
        </p>
<p>
          <span class="bold"><strong>Incompatibility:</strong></span>
        </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
              Changing the order of <code class="computeroutput"><span class="identifier">to</span></code>
              and <code class="computeroutput"><span class="identifier">from</span></code> parameters
              on <code class="computeroutput"><span class="identifier">assign_to</span></code>.
            </li>
<li class="listitem">
              Now <code class="computeroutput"><span class="identifier">boost</span><span class="special">/</span><span class="identifier">conversion</span><span class="special">/</span><span class="identifier">convert_to</span><span class="special">.</span><span class="identifier">hpp</span></code> and <code class="computeroutput"><span class="identifier">boost</span><span class="special">/</span><span class="identifier">conversion</span><span class="special">/</span><span class="identifier">assign_to</span><span class="special">.</span><span class="identifier">hpp</span></code>
              files are separated.
            </li>
</ul></div>
<p>
          <span class="bold"><strong>New Features:</strong></span>
        </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
              Added <code class="computeroutput"><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">conversion</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></code> global file.
            </li>
<li class="listitem">
              Added <code class="computeroutput"><span class="identifier">mca</span><span class="special">()</span></code>
              function.
            </li>
<li class="listitem">
              Added <code class="computeroutput"><span class="identifier">convert_to_via</span></code>
              function.
            </li>
</ul></div>
<p>
          <span class="bold"><strong>Test:</strong></span>
        </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
              Added test for the new features
            </li></ul></div>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost.conversion.appendices.history.__version_0_2_0__mai_16__2009__"></a><a class="link" href="index.html#boost.conversion.appendices.history.__version_0_2_0__mai_16__2009__" title="Version 0.2.0, Mai 16, 2009"><span class="bold"><strong>Version 0.2.0, Mai 16, 2009</strong></span> </a>
</h4></div></div></div>
<p>
          <span class="emphasis"><em>Adding array + fusion::tuples + Adaptation to Boost 1.39</em></span>
        </p>
<p>
          <span class="bold"><strong>New Features:</strong></span>
        </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
              conversion between <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">array</span></code>
              of explicitly convertible types.
            </li>
<li class="listitem">
              conversion between Boost.Fusion sequences of explicitly convertible
              types.
            </li>
</ul></div>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost.conversion.appendices.history.__version_0_1_0__april_16__2009__"></a><a class="link" href="index.html#boost.conversion.appendices.history.__version_0_1_0__april_16__2009__" title="Version 0.1.0, April 16, 2009"><span class="bold"><strong>Version 0.1.0, April 16, 2009</strong></span> </a>
</h4></div></div></div>
<p>
          <span class="emphasis"><em>Announcement of Conversions</em></span>
        </p>
<p>
          <span class="bold"><strong>Features:</strong></span>
        </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
              a generic <code class="computeroutput"><span class="identifier">convert_to</span></code>
              function which can be specialized by the user to make explicit conversion
              between unrelated types.
            </li>
<li class="listitem">
              a generic <code class="computeroutput"><span class="identifier">assign_to</span></code>
              function which can be specialized by the user to make explicit assignment
              between unrelated types.
            </li>
<li class="listitem">
              conversion between C-arrays of explicitly convertible types.
            </li>
<li class="listitem">
              conversion between <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">complex</span></code>
              of explicitly convertible types.
            </li>
<li class="listitem">
              conversion between <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span></code>
              of explicitly convertible types.
            </li>
<li class="listitem">
              conversion between <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></code>
              and Streamable types.
            </li>
<li class="listitem">
              conversion between <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">optional</span></code>
              of explicitly convertible types.
            </li>
<li class="listitem">
              conversion between <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">rational</span></code>
              of explicitly convertible types.
            </li>
<li class="listitem">
              conversion between <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">interval</span></code>
              of explicitly convertible types.
            </li>
<li class="listitem">
              conversion between <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span></code>
              and <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">ptime</span></code>.
            </li>
<li class="listitem">
              conversion between <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span></code>
              and <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">time_duration</span></code>.
            </li>
</ul></div>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost.conversion.appendices.rationale"></a><a class="link" href="index.html#boost.conversion.appendices.rationale" title="Appendix: Design Rationale">Appendix: Design
      Rationale</a>
</h3></div></div></div>
<a name="boost.conversion.appendices.rationale.why_overloading_the_conversion_functions_doesn_t_works_"></a><h5>
<a name="idp19776896"></a>
        <a class="link" href="index.html#boost.conversion.appendices.rationale.why_overloading_the_conversion_functions_doesn_t_works_">Why
        overloading the conversion functions doesn't works?</a>
      </h5>
<p>
        For example, the prototype of <code class="computeroutput"><span class="identifier">implicit_convert_to</span></code>
        is
      </p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Target</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Source</span><span class="special">&gt;</span>
<span class="identifier">Target</span>
<span class="identifier">implicit_convert_to</span><span class="special">(</span><span class="identifier">Source</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">from</span><span class="special">);</span>
</pre>
<p>
        The users could overload this function with a specific source type, as it
        appears as a parameter of the function, but they can not overload on the
        source and the target types.
      </p>
<p>
        To overcome this limitation the library could opt for two alternatives:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
            Add a dummy parameter that can covey the Target type.
          </li>
<li class="listitem">
            Implements the conversion function forwarding the call to a specific
            converter functor.
          </li>
</ul></div>
<p>
        Adding a dummy parameter could look something like
      </p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Target</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Source</span><span class="special">&gt;</span>
<span class="identifier">Target</span> <span class="identifier">implicit_convert_to</span><span class="special">(</span><span class="identifier">Source</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">from</span><span class="special">,</span> <span class="identifier">dummy</span><span class="special">::</span><span class="identifier">type_tag</span><span class="special">&lt;</span><span class="identifier">Target</span><span class="special">&gt;</span> <span class="keyword">const</span><span class="special">&amp;);</span>
</pre>
<p>
        Callers of this function need to pass the additional parameter as for example
      </p>
<pre class="programlisting"><span class="identifier">MyTarget</span> <span class="identifier">t</span> <span class="special">=</span> <span class="identifier">implicit_convert_to</span><span class="special">(</span><span class="identifier">from</span><span class="special">,</span> <span class="identifier">dummy</span><span class="special">::</span><span class="identifier">type_tag</span><span class="special">&lt;</span><span class="identifier">MyTarget</span><span class="special">&gt;());</span> 
</pre>
<p>
        User specializations consists just in overloading this function.
      </p>
<pre class="programlisting"><span class="identifier">MyTarget</span> <span class="identifier">implicit_convert_to</span><span class="special">(</span><span class="identifier">MySource</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">from</span><span class="special">,</span> <span class="identifier">dummy</span><span class="special">&lt;</span><span class="identifier">MyTarget</span><span class="special">&gt;</span> <span class="keyword">const</span><span class="special">&amp;);</span>
</pre>
<p>
        The advantages are
      </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
            the call doesn't needs to be qualified by the boost::conversion namespace
            and ADL will choose the correct overload.
          </li></ul></div>
<p>
        The drawbacks are
      </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
            the unreadable syntax,
          </li>
<li class="listitem">
            the possible default implementation provided by the library would not
            be accessible as far as the user doesn't includes the boost::conversion
            namespace.
          </li>
<li class="listitem">
            we can not add new functions on the std namespace, so we can not overload
            the behavior for standard classes, so a different technique is needed.
          </li>
</ul></div>
<p>
        Implementing the conversion function by forwarding the call to a specific
        converter functor as follows
      </p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Target</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Source</span><span class="special">&gt;</span>
<span class="identifier">Target</span>
<span class="identifier">implicit_convert_to</span><span class="special">(</span><span class="identifier">Source</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">from</span><span class="special">)</span>
<span class="special">{</span>
  <span class="keyword">return</span> <span class="identifier">implicit_converter</span><span class="special">&lt;</span><span class="identifier">Target</span><span class="special">,</span><span class="identifier">Source</span><span class="special">&gt;()(</span><span class="identifier">from</span><span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
        User specializations consists just in specializing the functor implicit_converter.
      </p>
<pre class="programlisting"><span class="keyword">namespace</span> <span class="identifier">boost</span> <span class="special">{</span> 
  <span class="keyword">namespace</span> <span class="identifier">conversion</span> <span class="special">{</span>
    <span class="keyword">struct</span> <span class="identifier">implicit_converter</span><span class="special">&lt;</span><span class="identifier">MyTarget</span><span class="special">,</span> <span class="identifier">MySource</span><span class="special">&gt;</span> <span class="special">{</span>
      <span class="identifier">MyTarget</span> <span class="keyword">operator</span><span class="special">()(</span><span class="identifier">MySource</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">from</span><span class="special">)</span> 
      <span class="special">{</span>
        <span class="comment">// return the specific conversion;
</span>      <span class="special">}</span>
    <span class="special">};</span>
  <span class="special">}</span> 
<span class="special">}</span>
</pre>
<p>
        The advantages are
      </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
            the technique can be applied to types on the standard namespace
          </li>
<li class="listitem">
            the library can call to the customization point after providing a default
            implementation.
          </li>
</ul></div>
<p>
        The drawbacks are
      </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
            The users need to qualify with boost::conversion every call to implicit_converter
            or introduce the namespace boost::conversion via the using statement.
          </li></ul></div>
<p>
        The library provides a mixture of the preceding alternatives:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
            defines a boost::conversion::convert_to function
          </li>
<li class="listitem">
            that relies on an internal function which introduces an internal namespace
            on which the default implementation is found by ADL if no best choice
            is found.
          </li>
<li class="listitem">
            this default implementation forwards the call to the customization functor
          </li>
<li class="listitem">
            which can be partially specialized by the user.
          </li>
</ul></div>
<p>
        The library implements the conversion function forwarding the call to a specific
        converter functor as follows
      </p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Target</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Source</span><span class="special">&gt;</span>
<span class="identifier">Target</span>
<span class="identifier">implicit_convert_to</span><span class="special">(</span><span class="identifier">Source</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">from</span><span class="special">)</span>
<span class="special">{</span>
  <span class="keyword">return</span> <span class="identifier">implicit_converter</span><span class="special">&lt;</span><span class="identifier">Target</span><span class="special">,</span><span class="identifier">Source</span><span class="special">&gt;()(</span><span class="identifier">from</span><span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
        The converter functor must define the operator() as follows:
      </p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Target</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Source</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Enable</span> <span class="special">=</span> <span class="keyword">void</span> <span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">implicit_converter</span>
<span class="special">{</span>
  <span class="identifier">Target</span> <span class="keyword">operator</span><span class="special">()(</span><span class="keyword">typename</span> <span class="identifier">add_reference</span><span class="special">&lt;</span><span class="keyword">const</span> <span class="identifier">Source</span><span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">val</span><span class="special">)</span>
  <span class="special">{</span>
    <span class="special">...</span>
  <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
        The library provides a specialization of this class for classes Target and
        Source satisfying Convertible&lt;Source,Target&gt; as follows:
      </p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Target</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Source</span> <span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">implicit_converter</span><span class="special">&lt;</span><span class="identifier">Target</span><span class="special">,</span> <span class="identifier">Source</span>
    <span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">enable_if_c</span><span class="special">&lt;</span> <span class="identifier">is_convertible</span><span class="special">&lt;</span><span class="identifier">Source</span><span class="special">,</span><span class="identifier">Target</span><span class="special">&gt;::</span><span class="identifier">value</span> <span class="special">&gt;::</span><span class="identifier">type</span>
<span class="special">&gt;</span> <span class="special">:</span> <span class="identifier">true_type</span>
<span class="special">{</span>
  <span class="identifier">Target</span> <span class="keyword">operator</span><span class="special">()(</span><span class="keyword">typename</span> <span class="identifier">add_reference</span><span class="special">&lt;</span><span class="keyword">const</span> <span class="identifier">Source</span><span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">val</span><span class="special">)</span>
  <span class="special">{</span>
    <span class="keyword">return</span> <span class="identifier">val</span><span class="special">;</span>
  <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
        In the same way the library provides a specialization of this class, the
        users can specialize this converter functor as the class has the source and
        the target types as parameters.
      </p>
<p>
        One of the problems using SFINAE, is that all the conditions must be complementary.
        So the user needs to know what are the other conditions and ensure that there
        is no ambiguity.
      </p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span>  <span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">implicit_converter</span><span class="special">&lt;</span><span class="identifier">MyTarget</span><span class="special">,</span> <span class="identifier">MySource</span>
    <span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">enable_if_c</span><span class="special">&lt;</span> <span class="special">!</span> <span class="identifier">is_convertible</span><span class="special">&lt;</span><span class="identifier">MySource</span><span class="special">,</span><span class="identifier">MyTarget</span><span class="special">&gt;::</span><span class="identifier">value</span> <span class="special">&gt;::</span><span class="identifier">type</span>
<span class="special">&gt;</span> <span class="special">:</span> <span class="identifier">true_type</span>
<span class="special">{</span>
  <span class="identifier">MyTarget</span> <span class="keyword">operator</span><span class="special">()(</span><span class="keyword">typename</span> <span class="identifier">add_reference</span><span class="special">&lt;</span><span class="keyword">const</span> <span class="identifier">MySource</span><span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">val</span><span class="special">)</span>
  <span class="special">{</span>
    <span class="comment">// return a specific conversion ;
</span>  <span class="special">}</span>
<span class="special">};</span>
</pre>
<a name="boost.conversion.appendices.rationale.why_the_library_provides_two_level_customization_point_for_conversion_functions_"></a><h5>
<a name="idp19967952"></a>
        <a class="link" href="index.html#boost.conversion.appendices.rationale.why_the_library_provides_two_level_customization_point_for_conversion_functions_">Why
        the library provides two-level customization point for conversion functions?</a>
      </h5>
<p>
        While the preceding technique allows the users to override the default specialization,
        it is quite dependent on the conditions the library makes a specialization.
        While the condition for the implicit_converter is simple, other functions
        can have a much more complex condition for which the library makes a specialization.
      </p>
<p>
        To make easier the work of the users the library defines a catch all definition
        that delegates to a second functor.
      </p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Target</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Source</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Enable</span> <span class="special">=</span> <span class="keyword">void</span> <span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">implicit_converter_cp</span> <span class="special">:</span> <span class="identifier">false_type</span> <span class="special">{};</span>

<span class="keyword">template</span> <span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Target</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Source</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Enable</span> <span class="special">=</span> <span class="keyword">void</span> <span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">implicit_converter</span> <span class="special">:</span> <span class="identifier">implicit_converter_cp</span><span class="special">&lt;</span><span class="identifier">Target</span><span class="special">,</span><span class="identifier">Source</span><span class="special">,</span><span class="identifier">Enable</span><span class="special">&gt;</span> <span class="special">{};</span>
</pre>
<p>
        Now the users can friendly specialize implicit_converter_cp as the library
        doesn't provides any specialization of this class by default.
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost.conversion.appendices.implementation"></a><a class="link" href="index.html#boost.conversion.appendices.implementation" title="Appendix: Implementation Notes">Appendix:
      Implementation Notes</a>
</h3></div></div></div>
<a name="boost.conversion.appendices.implementation.why__code__phrase_role__identifier__implicit_converter_cp__phrase__phrase_role__special___lt___phrase___phrase_role__identifier__std__phrase__phrase_role__special______phrase__phrase_role__identifier__vector__phrase__phrase_role__special___lt___phrase__phrase_role__identifier__t1__phrase__phrase_role__special_____phrase__phrase_role__identifier__a1__phrase__phrase_role__special___gt____phrase___phrase_role__identifier__std__phrase__phrase_role__special______phrase__phrase_role__identifier__vector__phrase__phrase_role__special___lt___phrase__phrase_role__identifier__t2__phrase__phrase_role__special_____phrase__phrase_role__identifier__a2__phrase__phrase_role__special___gt___phrase___phrase_role__special___gt___phrase___code__can_not_relay_on__code__phrase_role__identifier__assign_to__phrase__phrase_role__special___lt___phrase___phrase_role__identifier__std__phrase__phrase_role__special______phrase__phrase_role__identifier__vector__phrase__phrase_role__special___lt___phrase__phrase_role__identifier__t1__phrase__phrase_role__special_____phrase__phrase_role__identifier__a1__phrase__phrase_role__special___gt____phrase___phrase_role__identifier__std__phrase__phrase_role__special______phrase__phrase_role__identifier__vector__phrase__phrase_role__special___lt___phrase__phrase_role__identifier__t2__phrase__phrase_role__special_____phrase__phrase_role__identifier__a2__phrase__phrase_role__special___gt___phrase___phrase_role__special___gt___phrase___code__"></a><h5>
<a name="idp20000640"></a>
        <a class="link" href="index.html#boost.conversion.appendices.implementation.why__code__phrase_role__identifier__implicit_converter_cp__phrase__phrase_role__special___lt___phrase___phrase_role__identifier__std__phrase__phrase_role__special______phrase__phrase_role__identifier__vector__phrase__phrase_role__special___lt___phrase__phrase_role__identifier__t1__phrase__phrase_role__special_____phrase__phrase_role__identifier__a1__phrase__phrase_role__special___gt____phrase___phrase_role__identifier__std__phrase__phrase_role__special______phrase__phrase_role__identifier__vector__phrase__phrase_role__special___lt___phrase__phrase_role__identifier__t2__phrase__phrase_role__special_____phrase__phrase_role__identifier__a2__phrase__phrase_role__special___gt___phrase___phrase_role__special___gt___phrase___code__can_not_relay_on__code__phrase_role__identifier__assign_to__phrase__phrase_role__special___lt___phrase___phrase_role__identifier__std__phrase__phrase_role__special______phrase__phrase_role__identifier__vector__phrase__phrase_role__special___lt___phrase__phrase_role__identifier__t1__phrase__phrase_role__special_____phrase__phrase_role__identifier__a1__phrase__phrase_role__special___gt____phrase___phrase_role__identifier__std__phrase__phrase_role__special______phrase__phrase_role__identifier__vector__phrase__phrase_role__special___lt___phrase__phrase_role__identifier__t2__phrase__phrase_role__special_____phrase__phrase_role__identifier__a2__phrase__phrase_role__special___gt___phrase___phrase_role__special___gt___phrase___code__">Why
        <code class="computeroutput"><span class="identifier">implicit_converter_cp</span><span class="special">&lt;</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">T1</span><span class="special">,</span><span class="identifier">A1</span><span class="special">&gt;,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">T2</span><span class="special">,</span><span class="identifier">A2</span><span class="special">&gt;</span>
        <span class="special">&gt;</span></code> can not relay on <code class="computeroutput"><span class="identifier">assign_to</span><span class="special">&lt;</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">T1</span><span class="special">,</span><span class="identifier">A1</span><span class="special">&gt;,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">T2</span><span class="special">,</span><span class="identifier">A2</span><span class="special">&gt;</span>
        <span class="special">&gt;</span></code>?</a>
      </h5>
<a name="boost.conversion.appendices.implementation.why__code__phrase_role__identifier__convert_to__phrase___code__between_tuples_is_not_implemented_using__code__phrase_role__identifier__boost__phrase__phrase_role__special______phrase__phrase_role__identifier__fusion__phrase__phrase_role__special______phrase__phrase_role__identifier__transform__phrase___code__"></a><h5>
<a name="idp20024064"></a>
        <a class="link" href="index.html#boost.conversion.appendices.implementation.why__code__phrase_role__identifier__convert_to__phrase___code__between_tuples_is_not_implemented_using__code__phrase_role__identifier__boost__phrase__phrase_role__special______phrase__phrase_role__identifier__fusion__phrase__phrase_role__special______phrase__phrase_role__identifier__transform__phrase___code__">Why
        <code class="computeroutput"><span class="identifier">convert_to</span></code> between tuples
        is not implemented using <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">fusion</span><span class="special">::</span><span class="identifier">transform</span></code>?</a>
      </h5>
<p>
        <code class="computeroutput"><span class="identifier">convert_to</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span></code> is
        a kind of transformation, so the natural implementation of <code class="computeroutput"><span class="identifier">convert_to</span></code> for homogeneous containers could
        be to use the transform function.
      </p>
<p>
        This can not be applied to heterogeneous containers as tuples because the
        function change with the type.
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost.conversion.appendices.acknowledgements"></a><a class="link" href="index.html#boost.conversion.appendices.acknowledgements" title="Appendix: Acknowledgements">Appendix:
      Acknowledgements</a>
</h3></div></div></div>
<p>
        Thanks to Vladimir Batov for proposing Boost.StringConversion. The discussions
        on the Boost ML of his library were the source of inspiration of this generic
        library. Boost.Conversion has inherited from some of the needs of Boost.StringConversion.
        Thanks to Edward Diener for showing me indirectly that multiple assignments
        should be taken in account. Thanks to Jeffrey Lee Hellrung for showing me
        that Boost.Conversion should use also ADL as customization point, even if
        I have decided to disable it so simplify the library. Thanks to Robert Stewart
        for suggesting the use of a functor as customization point and for all the
        constructive comments he made on the Boost ML. Thanks to Tomas Heller to
        showing me how to cut the dependency on Boost.Phoenix while introducing the
        overload of convert_to on Phoenix actors.
      </p>
<p>
        And last thanks to Gordon Woodhull for proposing himself as review manager
        of the library.
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost.conversion.appendices.todo"></a><a class="link" href="index.html#boost.conversion.appendices.todo" title="Appendix : Future plans">Appendix : Future plans</a>
</h3></div></div></div>
<a name="boost.conversion.appendices.todo.tasks_to_do_before_review"></a><h5>
<a name="idp20042032"></a>
        <a class="link" href="index.html#boost.conversion.appendices.todo.tasks_to_do_before_review">Tasks
        to do before review</a>
      </h5>
<div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
            Improve the doc as much as possible.
          </li></ul></div>
<a name="boost.conversion.appendices.todo.tasks_to_do_if_the_library_is_accepted"></a><h5>
<a name="idp20045584"></a>
        <a class="link" href="index.html#boost.conversion.appendices.todo.tasks_to_do_if_the_library_is_accepted">Tasks
        to do if the library is accepted</a>
      </h5>
<div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
            Add the type traits specializations for the C++ Standard types.
          </li></ul></div>
<a name="boost.conversion.appendices.todo.for_later_releases"></a><h5>
<a name="idp20049184"></a>
        <a class="link" href="index.html#boost.conversion.appendices.todo.for_later_releases">For later
        releases</a>
      </h5>
<div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
            Analyze the impact of move semantics to the extrinsic conversion and
            assignments functions.
          </li></ul></div>
</div>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"><p><small>Last revised: August 15, 2011 at 17:01:43 GMT</small></p></td>
<td align="right"><div class="copyright-footer"></div></td>
</tr></table>
<hr>
<div class="spirit-nav"><a accesskey="n" href="boost/is_assignable.html"><img src="../../../../doc/src/images/next.png" alt="Next"></a></div>
</body>
</html>
