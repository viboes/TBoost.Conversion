<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Motivation</title>
<link rel="stylesheet" href="../../../../../../../doc/html/boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.69.1">
<link rel="start" href="../../../index.html" title="Toward Boost.Conversion">
<link rel="up" href="../overview.html" title="Overview">
<link rel="prev" href="../overview.html" title="Overview">
<link rel="next" href="../users_guide.html" title=" Users' Guide">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../../../../../boost.png"></td>
<td align="center"><a href="../../../../../../../index.html">Home</a></td>
<td align="center"><a href="../../../../../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../../../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../overview.html"><img src="../../../../../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../overview.html"><img src="../../../../../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../../../index.html"><img src="../../../../../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="../users_guide.html"><img src="../../../../../../../doc/html/images/next.png" alt="Next"></a>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost.conversion.overview.motivation"></a><a href="motivation.html" title="Motivation">Motivation</a>
</h3></div></div></div>
<p>
        I've needed recently to convert from boost::chrono::time_point&lt;Clock,
        Duration&gt; to boost::posix_time::ptime and from boost::chrono::duration&lt;Rep,
        Period&gt; to boost::posix_time::time_duration. This kind of conversions
        are needed quite often when you use code from two different libraries that
        have implemented the same concept using of course different representations
        and have hard coded the library interface to its own implementation. Well
        this is a normal situation we can't avoid. Life is life.
      </p>
<p>
        Quite often we need to convert unrelated types <code class="computeroutput"><span class="identifier">Source</span></code>
        and <code class="computeroutput"><span class="identifier">Target</span></code>. As these classes
        are unrelated, neither of them offers conversion operators to the other.
        Usually we get it by defining a specific function such as
      </p>
<pre class="programlisting"><span class="identifier">Target</span> <span class="identifier">ConvertToTarget</span><span class="special">(</span><span class="identifier">Source</span><span class="special">&amp;</span> <span class="identifier">v</span><span class="special">);</span>
</pre>
<p>
        In my case I started by defining
      </p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Period</span><span class="special">&gt;</span>
<span class="identifier">boost</span><span class="special">::</span><span class="identifier">posix_time</span><span class="special">::</span><span class="identifier">time_duration</span> <span class="identifier">convert_to_posix_time_time_duration</span><span class="special">(</span>
        <span class="keyword">const</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span> <span class="identifier">from</span><span class="special">);</span>

<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Duration</span><span class="special">&gt;</span>
<span class="identifier">posix_time</span><span class="special">::</span><span class="identifier">ptime</span> <span class="identifier">convert_to_posix_time_ptime</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span> <span class="identifier">from</span><span class="special">);</span>
</pre>
<p>
        Imagine now that you need to convert a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&lt;</span><span class="identifier">Source</span><span class="special">,</span> <span class="identifier">Source</span><span class="special">&gt;</span></code> to a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&lt;</span><span class="identifier">Target</span><span class="special">,</span> <span class="identifier">Target</span><span class="special">&gt;</span></code>. The standard defines conversions of
        pairs if the related types are C++ convertible:
      </p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T1</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">T2</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">pair</span> <span class="special">{</span>
    <span class="special">...</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">U</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">V</span><span class="special">&gt;</span>
    <span class="comment">//requires Constructible&lt;T1, const U&amp;&gt; &amp;&amp; Constructible&lt;T2, const V&amp;&gt;
</span>    <span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">pair</span><span class="special">&lt;</span><span class="identifier">U</span><span class="special">,</span> <span class="identifier">V</span><span class="special">&gt;&amp;</span> <span class="identifier">p</span><span class="special">);</span>

    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">U</span> <span class="special">,</span> <span class="keyword">class</span> <span class="identifier">V</span><span class="special">&gt;</span>
    <span class="comment">//requires HasAssign&lt;T1, const U&amp;&gt; &amp;&amp; HasAssign&lt;T2, const V&amp;&gt;
</span>    <span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span><span class="keyword">const</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&lt;</span><span class="identifier">U</span> <span class="special">,</span> <span class="identifier">V</span><span class="special">&gt;&amp;</span> <span class="identifier">p</span><span class="special">);</span>
    <span class="special">...</span>
<span class="special">};</span>
</pre>
<p>
        But as the types <code class="computeroutput"><span class="identifier">Target</span></code> and
        <code class="computeroutput"><span class="identifier">Source</span></code> are not C++ convertible
        other than using a specific function.
      </p>
<p>
        Well we can again define a specific function
      </p>
<pre class="programlisting"><span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&lt;</span><span class="identifier">Target</span><span class="special">,</span><span class="identifier">Target</span><span class="special">&gt;</span> <span class="identifier">ConvertToPairOfTarget</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&lt;</span><span class="identifier">Source</span><span class="special">,</span><span class="identifier">Source</span><span class="special">&gt;&amp;</span> <span class="identifier">v</span><span class="special">)</span> <span class="special">{</span>
    <span class="keyword">return</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">make_pair</span><span class="special">(</span><span class="identifier">ConvertToTarget</span><span class="special">(</span><span class="identifier">v</span><span class="special">.</span><span class="identifier">fisrt</span><span class="special">),</span> <span class="identifier">ConvertToTarget</span><span class="special">(</span><span class="identifier">v</span><span class="special">.</span><span class="identifier">second</span><span class="special">));</span>
<span class="special">}</span>
</pre>
<p>
        While the <code class="computeroutput"><span class="identifier">ConvertToTarget</span></code>
        could be specific, the <code class="computeroutput"><span class="identifier">ConvertToPairOfTarget</span></code>
        should be generic
      </p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Target1</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Target2</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Source1</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Source2</span><span class="special">)</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&lt;</span><span class="identifier">Target1</span><span class="special">,</span><span class="identifier">Target2</span><span class="special">&gt;</span> <span class="identifier">ConvertToPair</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&lt;</span><span class="identifier">Source1</span><span class="special">,</span><span class="identifier">Source2</span><span class="special">&gt;&amp;</span> <span class="identifier">v</span><span class="special">);</span>
</pre>
<p>
        In order to do that we need that the pair template parameters define a common
        function, let it call <code class="computeroutput"><span class="identifier">convert_to</span></code>,
      </p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Target</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Source</span><span class="special">)</span>
<span class="identifier">Target</span> <span class="identifier">convert_to</span><span class="special">(</span><span class="identifier">Source</span><span class="special">&amp;</span> <span class="identifier">v</span><span class="special">);</span>
</pre>
<p>
        so <code class="computeroutput"><span class="identifier">ConvertToPair</span></code> can be defined
        as
      </p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Target1</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Target2</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Source1</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Source2</span><span class="special">)</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&lt;</span><span class="identifier">Target1</span><span class="special">,</span><span class="identifier">Target2</span><span class="special">&gt;</span> <span class="identifier">ConvertToPair</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&lt;</span><span class="identifier">Source1</span><span class="special">,</span><span class="identifier">Source2</span><span class="special">&gt;&amp;</span> <span class="identifier">v</span><span class="special">)</span> <span class="special">{</span>
    <span class="keyword">return</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">make_pair</span><span class="special">(</span><span class="identifier">convert_to</span><span class="special">&lt;</span><span class="identifier">Target1</span><span class="special">&gt;(</span><span class="identifier">v</span><span class="special">.</span><span class="identifier">fisrt</span><span class="special">),</span> <span class="identifier">convert_to</span><span class="special">&lt;</span><span class="identifier">Target2</span><span class="special">&gt;(</span><span class="identifier">v</span><span class="special">.</span><span class="identifier">second</span><span class="special">));</span>
<span class="special">}</span>
</pre>
<p>
        We need to specialize the <code class="computeroutput"><span class="identifier">convert_to</span></code>
        function for the specific classes <code class="computeroutput"><span class="identifier">Source</span></code>
        and <code class="computeroutput"><span class="identifier">Target</span></code>. We can do it
        as follows
      </p>
<pre class="programlisting"><span class="identifier">Target</span>  <span class="identifier">convert_to</span><span class="special">(</span><span class="identifier">Source</span><span class="special">&amp;</span> <span class="identifier">v</span><span class="special">)</span> <span class="special">{</span><span class="keyword">return</span> <span class="identifier">ConvertToTarget</span><span class="special">(</span><span class="identifier">v</span><span class="special">);}</span>
</pre>
<p>
        In my case I needed
      </p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Period</span><span class="special">&gt;</span>
<span class="identifier">boost</span><span class="special">::</span><span class="identifier">posix_time</span><span class="special">::</span><span class="identifier">time_duration</span> <span class="identifier">convert_to</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;&amp;</span> <span class="identifier">from</span><span class="special">)</span>
<span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">convert_to_posix_time_time_duration</span><span class="special">(</span><span class="identifier">from</span><span class="special">);</span>
<span class="special">}</span>

<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Duration</span><span class="special">&gt;</span>
<span class="identifier">boost</span><span class="special">::</span><span class="identifier">posix_time</span><span class="special">::</span><span class="identifier">ptime</span> <span class="identifier">convert_to</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;&amp;</span> <span class="identifier">from</span><span class="special">)</span>
<span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">convert_to_posix_time_ptime</span><span class="special">(</span><span class="identifier">from</span><span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
        So now I can convert
      </p>
<pre class="programlisting"><span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&lt;</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span><span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span><span class="special">&gt;,</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span><span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span><span class="special">&gt;</span> <span class="special">&gt;</span>
</pre>
<p>
        to
      </p>
<pre class="programlisting"><span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">posix_time</span><span class="special">::</span><span class="identifier">ptime</span><span class="special">,</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">posix_time</span><span class="special">::</span><span class="identifier">time_duration</span><span class="special">&gt;</span>
</pre>
<p>
        using the <code class="computeroutput"><span class="identifier">ConvertToPair</span></code> function.
      </p>
<p>
        What about converting <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&lt;</span><span class="identifier">Source</span><span class="special">,</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&lt;</span><span class="identifier">Source</span><span class="special">,</span><span class="identifier">Source</span><span class="special">&gt;</span> <span class="special">&gt;</span></code> to <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&lt;</span><span class="identifier">Target</span><span class="special">,</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&lt;</span><span class="identifier">Target</span><span class="special">,</span><span class="identifier">Target</span><span class="special">&gt;</span> <span class="special">&gt;</span></code>? The issue now is that <code class="computeroutput"><span class="identifier">convert_to</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">make_pair</span><span class="special">&lt;</span><span class="identifier">to</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">make_pair</span><span class="special">&lt;</span><span class="identifier">to</span><span class="special">,</span><span class="identifier">to</span><span class="special">&gt;</span> <span class="special">&gt;)</span></code>
        do not compiles because the conversion of <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span></code>
        is named <code class="computeroutput"><span class="identifier">ConvertToPair</span></code>. So
        we need to specialize the function <code class="computeroutput"><span class="identifier">convert_to</span></code>
        for pairs.
      </p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T1</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">T2</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">S1</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">S2</span><span class="special">)</span>
<span class="keyword">static</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&lt;</span><span class="identifier">T1</span><span class="special">,</span><span class="identifier">T2</span><span class="special">&gt;</span> <span class="identifier">convert_to</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&lt;</span><span class="identifier">Source1</span><span class="special">,</span><span class="identifier">Source2</span><span class="special">&gt;&amp;</span> <span class="identifier">from</span><span class="special">)</span> <span class="special">{</span>
<span class="special">{</span>
    <span class="keyword">return</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&lt;</span><span class="identifier">T1</span><span class="special">,</span><span class="identifier">T2</span><span class="special">&gt;(</span><span class="identifier">convert_to</span><span class="special">&lt;</span><span class="identifier">T1</span><span class="special">&gt;(</span><span class="identifier">from</span><span class="special">.</span><span class="identifier">first</span><span class="special">),</span> <span class="identifier">convert_to</span><span class="special">&lt;</span><span class="identifier">T2</span><span class="special">&gt;(</span><span class="identifier">from</span><span class="special">.</span><span class="identifier">second</span><span class="special">));</span>
<span class="special">}</span>
</pre>
<p>
        There is still a last point. The preceding design works well with unrelated
        classes, but what about classes that already define some kind of conversion,
        using a constructor or a conversion operator. Do we need to make specialization
        for these conversion? The answer is no. We need just to define the default
        implementation of convert_to function to just return the explicit conversion.
      </p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Target</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Source</span><span class="special">&gt;</span>
<span class="identifier">Target</span> <span class="identifier">convert_to</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">Source</span><span class="special">&amp;</span> <span class="identifier">from</span><span class="special">)</span>
<span class="special">{</span>
    <span class="keyword">return</span> <span class="identifier">Target</span><span class="special">(</span><span class="identifier">from</span><span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
        What have we learned? Classes or algorithms relying on a conversion by copy-construction
        or by the conversion operator can be made more generic by relaying in a function
        that explicitly states this conversion. Thus, instead of requiring
      </p>
<pre class="programlisting"><span class="identifier">Target</span><span class="special">(</span><span class="identifier">from</span><span class="special">)</span>
</pre>
<p>
        requires
      </p>
<pre class="programlisting"><span class="identifier">convert_to</span><span class="special">&lt;</span><span class="identifier">Target</span><span class="special">&gt;(</span><span class="identifier">from</span><span class="special">)</span>
</pre>
<p>
        The same applies to classes or algorithms relying on the assignment operator.
        So instead of requiring
      </p>
<pre class="programlisting"><span class="identifier">to</span> <span class="special">=</span> <span class="identifier">from</span>
</pre>
<p>
        requires
      </p>
<pre class="programlisting"><span class="identifier">assign_to</span><span class="special">(</span><span class="identifier">to</span><span class="special">,</span> <span class="identifier">from</span><span class="special">);</span>
</pre>
<p>
        The default implementation of <code class="computeroutput"><span class="identifier">assign_to</span></code>
        relies on the assignment operator
      </p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Target</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Source</span> <span class="special">&gt;</span>
<span class="identifier">To</span><span class="special">&amp;</span> <span class="identifier">assign_to</span><span class="special">(</span><span class="identifier">Target</span><span class="special">&amp;</span> <span class="identifier">to</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">Source</span><span class="special">&amp;</span> <span class="identifier">from</span><span class="special">)</span>
<span class="special">{</span>
    <span class="identifier">to</span> <span class="special">=</span> <span class="identifier">from</span><span class="special">;</span>
    <span class="keyword">return</span> <span class="identifier">to</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
        For classes that are explicitly convertible and having a self assignment
        operator it is easy to make a specialization of <code class="computeroutput"><span class="identifier">assign_to</span></code>
        as follows.
      </p>
<pre class="programlisting"><span class="identifier">to</span> <span class="special">=</span> <span class="identifier">convert_to</span><span class="special">&lt;</span><span class="identifier">Target</span><span class="special">&gt;(</span><span class="identifier">from</span><span class="special">);</span>
</pre>
<p>
        The rationale is that if there was not a copy constructor from a Source seems
        reasonable to think that there will not be an assignment operator. So in
        most of the cases, once we have specialized the convert_to function we recover
        a reasonable implementation for the <code class="computeroutput"><span class="identifier">assign_to</span></code>
        function.
      </p>
<p>
        When doing multiple assignments we use to do
      </p>
<pre class="programlisting"><span class="identifier">a</span> <span class="special">=</span> <span class="identifier">b</span> <span class="special">=</span> <span class="identifier">c</span><span class="special">;</span>
</pre>
<p>
        With <code class="computeroutput"><span class="identifier">assign_to</span></code> we could do
      </p>
<pre class="programlisting"><span class="identifier">assign_to</span><span class="special">(</span><span class="identifier">a</span><span class="special">,</span> <span class="identifier">assign_to</span><span class="special">(</span><span class="identifier">b</span><span class="special">,</span> <span class="identifier">c</span><span class="special">));</span>
</pre>
<p>
        and if we find this not really readable we can try with
      </p>
<pre class="programlisting"><span class="identifier">mca</span><span class="special">(</span><span class="identifier">a</span><span class="special">)</span> <span class="special">=</span> <span class="identifier">mca</span><span class="special">(</span><span class="identifier">b</span><span class="special">)</span> <span class="special">=</span> <span class="identifier">c</span><span class="special">;</span>
</pre>
<p>
        The behavior of mca recall the tie function of Boost.Tuple, but instead of
        allowing multiple assignations, allows a single assign_to call.
      </p>
<p>
        We can even generalize this, so classes or algorithms relying on a member
        function can be made more generic by relaying on a function. The default
        function implementation could just to call to the member function with the
        equivalent prototype, but this is out of the scope of this library.
      </p>
<p>
        So one of the advantages of using this common functions is uniformity. The
        other is that now we are able to find all the explicit conversions to one
        type, as we can do with explicit casts.
      </p>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2009 Vicente J. Botet Escriba<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../overview.html"><img src="../../../../../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../overview.html"><img src="../../../../../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../../../index.html"><img src="../../../../../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="../users_guide.html"><img src="../../../../../../../doc/html/images/next.png" alt="Next"></a>
</div>
</body>
</html>
