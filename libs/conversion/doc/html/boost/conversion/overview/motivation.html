<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Motivation</title>
<link rel="stylesheet" href="../../../../../../../doc/html/boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.69.1">
<link rel="start" href="../../../index.html" title="Toward Boost.Conversion">
<link rel="up" href="../overview.html" title="Overview">
<link rel="prev" href="../overview.html" title="Overview">
<link rel="next" href="../users_guide.html" title=" Users'Guide">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../../../../../boost.png"></td>
<td align="center"><a href="../../../../../../../index.html">Home</a></td>
<td align="center"><a href="../../../../../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../../../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../overview.html"><img src="../../../../../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../overview.html"><img src="../../../../../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../../../index.html"><img src="../../../../../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="../users_guide.html"><img src="../../../../../../../doc/html/images/next.png" alt="Next"></a>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost.conversion.overview.motivation"></a><a href="motivation.html" title="Motivation">Motivation</a>
</h3></div></div></div>
<p>
        Imagine you need to convert unrelated types <code class="computeroutput"><span class="identifier">Source</span></code>
        and <code class="computeroutput"><span class="identifier">Target</span></code>. You can get it
        by defining a specific function such as
      </p>
<pre class="programlisting"><span class="identifier">Target</span> <span class="identifier">SourceToTarget</span><span class="special">(</span><span class="identifier">Source</span><span class="special">&amp;</span> <span class="identifier">v</span><span class="special">);</span>
</pre>
<p>
        Imagine now that you need to convert a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&lt;</span><span class="identifier">Source</span><span class="special">,</span> <span class="identifier">Source</span><span class="special">&gt;</span></code> to a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&lt;</span><span class="identifier">Target</span><span class="special">,</span> <span class="identifier">Target</span><span class="special">&gt;</span></code>. Well you can again define a specific
        function
      </p>
<pre class="programlisting"><span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&lt;</span><span class="identifier">Target</span><span class="special">,</span><span class="identifier">Target</span><span class="special">&gt;</span> <span class="identifier">PairOfSourceToPairOfTarget</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&lt;</span><span class="identifier">Source</span><span class="special">,</span><span class="identifier">Source</span><span class="special">&gt;&amp;</span> <span class="identifier">v</span><span class="special">)</span> <span class="special">{</span>
    <span class="keyword">return</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">make_pair</span><span class="special">(</span><span class="identifier">SourceToTarget</span><span class="special">(</span><span class="identifier">v</span><span class="special">.</span><span class="identifier">fisrt</span><span class="special">),</span> <span class="identifier">SourceToTarget</span><span class="special">(</span><span class="identifier">v</span><span class="special">.</span><span class="identifier">second</span><span class="special">));</span>
<span class="special">}</span>
</pre>
<p>
        While the <code class="computeroutput"><span class="identifier">SourceToTarget</span></code>
        could be specific, the <code class="computeroutput"><span class="identifier">PairOfSourceToPairOfTarget</span></code>
        sould be generic
      </p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Target1</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Target2</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Source1</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Source2</span><span class="special">)</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&lt;</span><span class="identifier">Target1</span><span class="special">,</span><span class="identifier">Target2</span><span class="special">&gt;</span> <span class="identifier">ConvertPair</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&lt;</span><span class="identifier">Source1</span><span class="special">,</span><span class="identifier">Source2</span><span class="special">&gt;&amp;</span> <span class="identifier">v</span><span class="special">);</span>
</pre>
<p>
        In order to do that we need that the pair template parameters define a common
        function, let it call <code class="computeroutput"><span class="identifier">convert_to</span></code>,
      </p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Target</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Source</span><span class="special">)</span>
<span class="identifier">Target</span> <span class="identifier">convert_to</span><span class="special">(</span><span class="identifier">Source</span><span class="special">&amp;</span> <span class="identifier">v</span><span class="special">);</span>
</pre>
<p>
        so <code class="computeroutput"><span class="identifier">ConvertPair</span></code> can be defined
        as
      </p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Target1</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Target2</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Source1</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Source2</span><span class="special">)</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&lt;</span><span class="identifier">Target1</span><span class="special">,</span><span class="identifier">Target2</span><span class="special">&gt;</span> <span class="identifier">ConvertPair</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&lt;</span><span class="identifier">Source1</span><span class="special">,</span><span class="identifier">Source2</span><span class="special">&gt;&amp;</span> <span class="identifier">v</span><span class="special">)</span> <span class="special">{</span>
    <span class="keyword">return</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">make_pair</span><span class="special">(</span><span class="identifier">convert_to</span><span class="special">(</span><span class="identifier">v</span><span class="special">.</span><span class="identifier">fisrt</span><span class="special">),</span> <span class="identifier">convert_to</span><span class="special">(</span><span class="identifier">v</span><span class="special">.</span><span class="identifier">second</span><span class="special">));</span>
<span class="special">}</span>
</pre>
<p>
        The issue is that we need to specialize the <code class="computeroutput"><span class="identifier">convert_to</span></code>
        function for the classes <code class="computeroutput"><span class="identifier">Source</span></code>
        and <code class="computeroutput"><span class="identifier">Target</span></code>. We can do it
        as follows
      </p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;&gt;</span>
<span class="identifier">Target</span>  <span class="identifier">convert_to</span><span class="special">&lt;</span><span class="identifier">Target</span><span class="special">,</span> <span class="identifier">Source</span><span class="special">&gt;(</span><span class="identifier">Source</span><span class="special">&amp;</span> <span class="identifier">v</span><span class="special">)</span> <span class="special">{</span><span class="keyword">return</span> <span class="identifier">SourceToTarget</span><span class="special">(</span><span class="identifier">v</span><span class="special">);}</span>
</pre>
<p>
        What about converting <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&lt;</span><span class="identifier">Source</span><span class="special">,</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&lt;</span><span class="identifier">Source</span><span class="special">,</span><span class="identifier">Source</span><span class="special">&gt;</span> <span class="special">&gt;</span></code> to <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&lt;</span><span class="identifier">Target</span><span class="special">,</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&lt;</span><span class="identifier">Target</span><span class="special">,</span><span class="identifier">Target</span><span class="special">&gt;</span> <span class="special">&gt;</span></code>? The issue now is that <code class="computeroutput"><span class="identifier">convert_to</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">make_pair</span><span class="special">&lt;</span><span class="identifier">to</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">make_pair</span><span class="special">&lt;</span><span class="identifier">to</span><span class="special">,</span><span class="identifier">to</span><span class="special">&gt;</span> <span class="special">&gt;)</span></code>
        do not compiles because the conversion of <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span></code>
        is named <code class="computeroutput"><span class="identifier">ConvertPair</span></code>. So
        we need to specialize the function <code class="computeroutput"><span class="identifier">convert_to</span></code>
        for pairs. There is no major problem with compilers supporting partial specialization
        of function templates. If this is not the case, we need to use a trick; as
        it allows partial specialization of classes we can define <code class="computeroutput"><span class="identifier">convert_to</span></code>
        by as relying to a specific function of a class, as follows:
      </p>
<pre class="programlisting"><span class="keyword">namespace</span> <span class="identifier">partial_specialization_workaround</span> <span class="special">{</span>
  <span class="keyword">template</span> <span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Target</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Source</span> <span class="special">&gt;</span>
  <span class="keyword">struct</span> <span class="identifier">convert_to</span> <span class="special">{</span>
    <span class="keyword">static</span> <span class="identifier">Target</span> <span class="identifier">apply</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">Source</span><span class="special">&amp;</span> <span class="identifier">val</span><span class="special">);</span>
  <span class="special">};</span>
<span class="special">}</span>

<span class="keyword">template</span> <span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Target</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Source</span> <span class="special">&gt;</span>
<span class="identifier">Target</span> <span class="identifier">convert_to</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">Source</span><span class="special">&amp;</span> <span class="identifier">val</span><span class="special">)</span> <span class="special">{</span>
  <span class="keyword">return</span> <span class="identifier">partial_specialization_workaround</span><span class="special">::</span><span class="identifier">convert_to</span><span class="special">&lt;</span><span class="identifier">Target</span><span class="special">,</span><span class="identifier">Source</span><span class="special">&gt;::</span><span class="identifier">apply</span><span class="special">(</span><span class="identifier">val</span><span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
        So now we can specialize <code class="computeroutput"><span class="identifier">partial_specialization_workaround</span><span class="special">::</span><span class="identifier">convert_to</span></code>
        for pairs as follows:
      </p>
<pre class="programlisting"><span class="keyword">namespace</span> <span class="identifier">partial_specialization_workaround</span> <span class="special">{</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Target1</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Target2</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Source1</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Source2</span><span class="special">)</span>
    <span class="keyword">struct</span> <span class="identifier">convert_to</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&lt;</span><span class="identifier">Target1</span><span class="special">,</span><span class="identifier">Target2</span><span class="special">&gt;,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&lt;</span><span class="identifier">Source1</span><span class="special">,</span><span class="identifier">Source2</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="special">{</span>
        <span class="keyword">inline</span> <span class="keyword">static</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&lt;</span><span class="identifier">Target1</span><span class="special">,</span><span class="identifier">Target2</span><span class="special">&gt;</span> <span class="identifier">apply</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&lt;</span><span class="identifier">Source1</span><span class="special">,</span><span class="identifier">Source2</span><span class="special">&gt;&amp;</span> <span class="identifier">v</span><span class="special">)</span> <span class="special">{</span>
        <span class="special">{</span>
            <span class="keyword">return</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&lt;</span><span class="identifier">T1</span><span class="special">,</span><span class="identifier">T2</span><span class="special">&gt;(</span><span class="identifier">convert_to</span><span class="special">&lt;</span><span class="identifier">T1</span><span class="special">&gt;(</span><span class="identifier">from</span><span class="special">.</span><span class="identifier">first</span><span class="special">),</span> <span class="identifier">convert_to</span><span class="special">&lt;</span><span class="identifier">T2</span><span class="special">&gt;(</span><span class="identifier">from</span><span class="special">.</span><span class="identifier">second</span><span class="special">));</span>
        <span class="special">}</span>
    <span class="special">};</span>

<span class="special">}</span>
</pre>
<p>
        There is one more issue. The preceding design works well with unrelated classes,
        but what about classes that already define some kind of conversion, unisng
        a constructor or a conversion operator. Do we need to make specialization
        for these conversion? The answer is no. We need just to define the default
        implementation of the partial_specialization_workaround::convert_to::apply
        function to just return the explicit conversion.
      </p>
<pre class="programlisting"><span class="keyword">namespace</span> <span class="identifier">partial_specialization_work_around</span> <span class="special">{</span>
  <span class="keyword">template</span> <span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">T</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">U</span><span class="special">&gt;</span>
    <span class="keyword">struct</span> <span class="identifier">convert_to</span> <span class="special">{</span>
      <span class="keyword">inline</span> <span class="keyword">static</span> <span class="identifier">T</span> <span class="identifier">apply</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">U</span><span class="special">&amp;</span> <span class="identifier">val</span><span class="special">)</span>
      <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">T</span><span class="special">(</span><span class="identifier">val</span><span class="special">);</span>
      <span class="special">}</span>
   <span class="special">};</span>
<span class="special">}</span>
</pre>
<p>
        What have we learned? Classes or algorithms relying on a conversion by copy-construction
        or by the conversion operator can be made more generic by relaying in a function
        that explicitly states this conversion. Thus, instead of requiring
      </p>
<pre class="programlisting"><span class="identifier">Target</span><span class="special">(</span><span class="identifier">from</span><span class="special">)</span>
</pre>
<p>
        requires
      </p>
<pre class="programlisting"><span class="identifier">convert_to</span><span class="special">&lt;</span><span class="identifier">Target</span><span class="special">&gt;(</span><span class="identifier">from</span><span class="special">)</span>
</pre>
<p>
        The same applies to classes or algorithms relying on the assignment operator.
        So instead of requiring
      </p>
<pre class="programlisting"><span class="identifier">to</span> <span class="special">=</span> <span class="identifier">from</span>
</pre>
<p>
        requires
      </p>
<pre class="programlisting"><span class="identifier">assign_to</span><span class="special">(</span><span class="identifier">to</span><span class="special">,</span> <span class="identifier">from</span><span class="special">);</span>
</pre>
<p>
        The default implementation of <code class="computeroutput"><span class="identifier">assign_to</span></code>
        relies on the assignement operator
      </p>
<pre class="programlisting"><span class="keyword">namespace</span> <span class="identifier">partial_specialization_workaround</span> <span class="special">{</span>
    <span class="keyword">template</span> <span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Target</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Source</span> <span class="special">&gt;</span>
    <span class="keyword">struct</span> <span class="identifier">assign_to</span> <span class="special">{</span>
        <span class="keyword">inline</span> <span class="keyword">static</span> <span class="identifier">To</span><span class="special">&amp;</span> <span class="identifier">apply</span><span class="special">(</span><span class="identifier">Target</span><span class="special">&amp;</span> <span class="identifier">to</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">Source</span><span class="special">&amp;</span> <span class="identifier">from</span><span class="special">)</span>
        <span class="special">{</span>
            <span class="identifier">to</span> <span class="special">=</span> <span class="identifier">from</span><span class="special">;</span>
            <span class="keyword">return</span> <span class="identifier">to</span><span class="special">;</span>
        <span class="special">}</span>
    <span class="special">};</span>
<span class="special">}</span>
<span class="keyword">template</span> <span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Target</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Source</span> <span class="special">&gt;</span>
<span class="identifier">To</span><span class="special">&amp;</span> <span class="identifier">assign_to</span><span class="special">(</span><span class="identifier">Target</span><span class="special">&amp;</span> <span class="identifier">to</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">Source</span><span class="special">&amp;</span> <span class="identifier">from</span><span class="special">)</span> <span class="special">{</span>
    <span class="keyword">return</span> <span class="identifier">partial_specialization_workaround</span><span class="special">::</span><span class="identifier">assign_to</span><span class="special">&lt;</span><span class="identifier">Target</span><span class="special">,</span><span class="identifier">Source</span><span class="special">&gt;::</span><span class="identifier">apply</span><span class="special">(</span><span class="identifier">to</span><span class="special">,</span> <span class="identifier">from</span><span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
        For classes that are explicitly convertible and having a self assignment
        operator it is easy to make a specialization of <code class="computeroutput"><span class="identifier">assign_to</span></code>
        as follows.
      </p>
<pre class="programlisting"><span class="identifier">to</span> <span class="special">=</span> <span class="identifier">convert_to</span><span class="special">&lt;</span><span class="identifier">Target</span><span class="special">&gt;(</span><span class="identifier">from</span><span class="special">);</span>
</pre>
<p>
        The rationale is that if there was not a copy constructor from a Source seems
        reasonable to think that there will not be an assignment operator. So in
        most of the cases, once we have specialized the convert_to function we recover
        a reasonable implementation for the <code class="computeroutput"><span class="identifier">assign_to</span></code>
        function.
      </p>
<p>
        When doing multiple assignements we use to do
      </p>
<pre class="programlisting"><span class="identifier">a</span> <span class="special">=</span> <span class="identifier">b</span> <span class="special">=</span> <span class="identifier">c</span><span class="special">;</span>
</pre>
<p>
        With <code class="computeroutput"><span class="identifier">assign_to</span></code> we could do
      </p>
<pre class="programlisting"><span class="identifier">assign_to</span><span class="special">(</span><span class="identifier">a</span><span class="special">,</span> <span class="identifier">assign_to</span><span class="special">(</span><span class="identifier">b</span><span class="special">,</span> <span class="identifier">c</span><span class="special">));</span>
</pre>
<p>
        and if we find this not really readable we can try with
      </p>
<pre class="programlisting"><span class="identifier">mca</span><span class="special">(</span><span class="identifier">a</span><span class="special">)</span> <span class="special">=</span> <span class="identifier">mca</span><span class="special">(</span><span class="identifier">b</span><span class="special">)</span> <span class="special">=</span> <span class="identifier">c</span><span class="special">;</span>
</pre>
<p>
        The behavior of mca recall the tie function of Boost.Tuple, but instead of
        allowing multiple assignations, allows a single assign_to call.
      </p>
<p>
        We can even generalize this, so classes or algorithms relying on a member
        function can be made more generic by relaying on a function. The default
        function implementation could just to call to the member function with the
        equivalent prototype, but this is out of the scope of this library.
      </p>
<p>
        So one of the advantages of using this common functions is uniformity. The
        other is that now we are able to find all the explicit conversions to one
        type, as we can do with explict casts.
      </p>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright © 2009 Vicente J. Botet Escriba<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../overview.html"><img src="../../../../../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../overview.html"><img src="../../../../../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../../../index.html"><img src="../../../../../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="../users_guide.html"><img src="../../../../../../../doc/html/images/next.png" alt="Next"></a>
</div>
</body>
</html>
